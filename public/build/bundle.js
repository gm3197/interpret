
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false }) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.48.0' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /* src/components/Button.svelte generated by Svelte v3.48.0 */

    const file$e = "src/components/Button.svelte";

    // (16:10) {#if symbol}
    function create_if_block$7(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*symbol*/ ctx[2]);
    			attr_dev(span, "class", "icon svelte-fdulut");
    			add_location(span, file$e, 15, 22, 394);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*symbol*/ 4) set_data_dev(t, /*symbol*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(16:10) {#if symbol}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let button;
    	let t;
    	let button_class_value;
    	let mounted;
    	let dispose;
    	let if_block = /*symbol*/ ctx[2] && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(/*title*/ ctx[0]);
    			if (if_block) if_block.c();
    			attr_dev(button, "class", button_class_value = "" + (null_to_empty((/*secondary*/ ctx[1] ? "secondary" : "primary") + (/*active*/ ctx[5] ? " active" : "") + (/*noBold*/ ctx[6] ? " noBold" : "")) + " svelte-fdulut"));
    			button.disabled = /*disabled*/ ctx[4];
    			add_location(button, file$e, 9, 0, 218);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    			if (if_block) if_block.m(button, null);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*onClick*/ ctx[3])) /*onClick*/ ctx[3].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			if (dirty & /*title*/ 1) set_data_dev(t, /*title*/ ctx[0]);

    			if (/*symbol*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					if_block.m(button, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*secondary, active, noBold*/ 98 && button_class_value !== (button_class_value = "" + (null_to_empty((/*secondary*/ ctx[1] ? "secondary" : "primary") + (/*active*/ ctx[5] ? " active" : "") + (/*noBold*/ ctx[6] ? " noBold" : "")) + " svelte-fdulut"))) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (dirty & /*disabled*/ 16) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[4]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, []);
    	let { title } = $$props;
    	let { secondary = false } = $$props;
    	let { symbol = null } = $$props;

    	let { onClick = () => {
    		
    	} } = $$props;

    	let { disabled = false } = $$props;
    	let { active = false } = $$props;
    	let { noBold = false } = $$props;
    	const writable_props = ['title', 'secondary', 'symbol', 'onClick', 'disabled', 'active', 'noBold'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Button> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('secondary' in $$props) $$invalidate(1, secondary = $$props.secondary);
    		if ('symbol' in $$props) $$invalidate(2, symbol = $$props.symbol);
    		if ('onClick' in $$props) $$invalidate(3, onClick = $$props.onClick);
    		if ('disabled' in $$props) $$invalidate(4, disabled = $$props.disabled);
    		if ('active' in $$props) $$invalidate(5, active = $$props.active);
    		if ('noBold' in $$props) $$invalidate(6, noBold = $$props.noBold);
    	};

    	$$self.$capture_state = () => ({
    		title,
    		secondary,
    		symbol,
    		onClick,
    		disabled,
    		active,
    		noBold
    	});

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('secondary' in $$props) $$invalidate(1, secondary = $$props.secondary);
    		if ('symbol' in $$props) $$invalidate(2, symbol = $$props.symbol);
    		if ('onClick' in $$props) $$invalidate(3, onClick = $$props.onClick);
    		if ('disabled' in $$props) $$invalidate(4, disabled = $$props.disabled);
    		if ('active' in $$props) $$invalidate(5, active = $$props.active);
    		if ('noBold' in $$props) $$invalidate(6, noBold = $$props.noBold);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, secondary, symbol, onClick, disabled, active, noBold];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
    			title: 0,
    			secondary: 1,
    			symbol: 2,
    			onClick: 3,
    			disabled: 4,
    			active: 5,
    			noBold: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*title*/ ctx[0] === undefined && !('title' in props)) {
    			console.warn("<Button> was created without expected prop 'title'");
    		}
    	}

    	get title() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get secondary() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set secondary(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get symbol() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set symbol(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noBold() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noBold(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Radio.svelte generated by Svelte v3.48.0 */

    const file$d = "src/components/Radio.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    // (6:2) {#each options as o, i}
    function create_each_block$5(ctx) {
    	let span;
    	let t_value = /*o*/ ctx[3] + "";
    	let t;
    	let span_class_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[2](/*i*/ ctx[5]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);

    			attr_dev(span, "class", span_class_value = "" + (null_to_empty("option" + (/*i*/ ctx[5] == /*selectedOption*/ ctx[0]
    			? " selected"
    			: "")) + " svelte-l3mle9"));

    			add_location(span, file$d, 6, 4, 114);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*options*/ 2 && t_value !== (t_value = /*o*/ ctx[3] + "")) set_data_dev(t, t_value);

    			if (dirty & /*selectedOption*/ 1 && span_class_value !== (span_class_value = "" + (null_to_empty("option" + (/*i*/ ctx[5] == /*selectedOption*/ ctx[0]
    			? " selected"
    			: "")) + " svelte-l3mle9"))) {
    				attr_dev(span, "class", span_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(6:2) {#each options as o, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let p;
    	let each_value = /*options*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			p = element("p");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(p, file$d, 4, 0, 80);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(p, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*selectedOption, options*/ 3) {
    				each_value = /*options*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(p, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Radio', slots, []);
    	let { options } = $$props;
    	let { selectedOption = 0 } = $$props;
    	const writable_props = ['options', 'selectedOption'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Radio> was created with unknown prop '${key}'`);
    	});

    	const click_handler = i => {
    		$$invalidate(0, selectedOption = i);
    	};

    	$$self.$$set = $$props => {
    		if ('options' in $$props) $$invalidate(1, options = $$props.options);
    		if ('selectedOption' in $$props) $$invalidate(0, selectedOption = $$props.selectedOption);
    	};

    	$$self.$capture_state = () => ({ options, selectedOption });

    	$$self.$inject_state = $$props => {
    		if ('options' in $$props) $$invalidate(1, options = $$props.options);
    		if ('selectedOption' in $$props) $$invalidate(0, selectedOption = $$props.selectedOption);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selectedOption, options, click_handler];
    }

    class Radio extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { options: 1, selectedOption: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Radio",
    			options,
    			id: create_fragment$d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*options*/ ctx[1] === undefined && !('options' in props)) {
    			console.warn("<Radio> was created without expected prop 'options'");
    		}
    	}

    	get options() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedOption() {
    		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedOption(value) {
    		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const arrayBufferToBase64 = (buffer) => {
        let binary = "";
        let bytes = new Uint8Array(buffer);
        let len = bytes.length;
        for (var i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    };
    const base64ToArrayBuffer = (base64) => {
        let binStr = window.atob(base64);
        let len = binStr.length;
        let bytes = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            bytes[i] = binStr.charCodeAt(i);
        }
        return bytes.buffer;
    };
    const hexToArrayBuffer = (hex) => {
        let typedArray = new Uint8Array(hex.match(/[\da-f]{2}/gi).map(function (h) {
            return parseInt(h, 16);
        }));
        return typedArray.buffer;
    };
    const arrayBufferToHex = (buffer) => {
        return Array.from(new Uint8Array(buffer), (byte) => {
            return ('0' + (byte & 0xFF).toString(16)).slice(-2);
        }).join("");
    };
    const binaryStringToArrayBuffer = (binary) => {
        let bytesCount = binary.length / 8;
        let typedArray = new Uint8Array(bytesCount);
        for (var i = 0; i < bytesCount; i++) {
            let byte = binary.substring(i * 8, (i * 8) + 8);
            typedArray[i] = parseInt(byte, 2);
        }
        return typedArray.buffer;
    };
    const asciiStringToArrayBuffer = (text) => {
        let typedArray = new Uint8Array(text.length);
        for (var i = 0; i < text.length; i++) {
            typedArray[i] = text.charCodeAt(i);
        }
        return typedArray.buffer;
    };
    const base64urlToBase64 = (base64url) => {
        return base64url.replace(/\-/g, "+").replace(/\_/g, "/");
    };
    const camelCaseToString = (name) => {
        if (!name) {
            return "";
        }
        let str = name[0].toUpperCase() + name.substring(1).replace(/([A-Z])/g, " $1");
        let words = str.split(" ");
        let res = "";
        for (var i = 0; i < words.length; i++) {
            if (words[i].length == 1 && words[i].match(/[A-Z]/)) {
                res += words[i];
            }
            else {
                if (i == 0) {
                    res += words[i];
                }
                else {
                    res += " " + words[i];
                }
            }
        }
        return res;
    };

    /* src/components/InputBox.svelte generated by Svelte v3.48.0 */

    const file$c = "src/components/InputBox.svelte";

    // (111:4) {#if data.length > 0}
    function create_if_block$6(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*dataIsValid*/ ctx[4]) return create_if_block_1$4;
    		return create_else_block$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(111:4) {#if data.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (126:6) {:else}
    function create_else_block$5(ctx) {
    	let p;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Invalid ");
    			t1 = text(/*dataType*/ ctx[2]);
    			attr_dev(p, "class", "error svelte-gnnepy");
    			add_location(p, file$c, 126, 8, 3884);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dataType*/ 4) set_data_dev(t1, /*dataType*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(126:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (112:6) {#if dataIsValid}
    function create_if_block_1$4(ctx) {
    	let p;

    	function select_block_type_1(ctx, dirty) {
    		if (/*dataType*/ ctx[2] == "binary") return create_if_block_2$1;
    		if (/*dataType*/ ctx[2] == "hex") return create_if_block_3$1;
    		if (/*dataType*/ ctx[2] == "base64") return create_if_block_4;
    		if (/*dataType*/ ctx[2] == "base64url") return create_if_block_5;
    		if (/*dataType*/ ctx[2] == "ascii") return create_if_block_6;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			p = element("p");
    			if (if_block) if_block.c();
    			attr_dev(p, "class", "info svelte-gnnepy");
    			add_location(p, file$c, 112, 8, 3356);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			if (if_block) if_block.m(p, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(p, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(112:6) {#if dataIsValid}",
    		ctx
    	});

    	return block;
    }

    // (122:40) 
    function create_if_block_6(ctx) {
    	let t0_value = /*data*/ ctx[0].length + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text(" characters");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*data*/ ctx[0].length + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(122:40) ",
    		ctx
    	});

    	return block;
    }

    // (120:44) 
    function create_if_block_5(ctx) {
    	let t0_value = window.atob(base64urlToBase64(/*data*/ ctx[0])).length + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text(" bytes");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && t0_value !== (t0_value = window.atob(base64urlToBase64(/*data*/ ctx[0])).length + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(120:44) ",
    		ctx
    	});

    	return block;
    }

    // (118:41) 
    function create_if_block_4(ctx) {
    	let t0_value = window.atob(/*data*/ ctx[0]).length + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text(" bytes");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && t0_value !== (t0_value = window.atob(/*data*/ ctx[0]).length + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(118:41) ",
    		ctx
    	});

    	return block;
    }

    // (116:38) 
    function create_if_block_3$1(ctx) {
    	let t0_value = /*data*/ ctx[0].replace(/\s/g, "").length / 2 + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text(" bytes");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*data*/ ctx[0].replace(/\s/g, "").length / 2 + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(116:38) ",
    		ctx
    	});

    	return block;
    }

    // (114:10) {#if dataType == "binary"}
    function create_if_block_2$1(ctx) {
    	let t0_value = /*data*/ ctx[0].replace(/\s/g, "").length / 8 + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text(" bytes");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*data*/ ctx[0].replace(/\s/g, "").length / 8 + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(114:10) {#if dataType == \\\"binary\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div2;
    	let div0;
    	let p;
    	let t1;
    	let radio;
    	let updating_selectedOption;
    	let t2;
    	let textarea;
    	let textarea_placeholder_value;
    	let t3;
    	let div1;
    	let button0;
    	let t4;
    	let t5;
    	let button1;
    	let t6;
    	let input;
    	let current;
    	let mounted;
    	let dispose;

    	function radio_selectedOption_binding(value) {
    		/*radio_selectedOption_binding*/ ctx[8](value);
    	}

    	let radio_props = {
    		options: [
    			/*data*/ ctx[0].length > 0 && /*dataTypeSelected*/ ctx[1] == 0
    			? /*dataType*/ ctx[2].charAt(0).toUpperCase() + /*dataType*/ ctx[2].substring(1, /*dataType*/ ctx[2].length) + " - Detected"
    			: "Auto-detect",
    			"Binary",
    			"Hex",
    			"Base64",
    			"Ascii"
    		]
    	};

    	if (/*dataTypeSelected*/ ctx[1] !== void 0) {
    		radio_props.selectedOption = /*dataTypeSelected*/ ctx[1];
    	}

    	radio = new Radio({ props: radio_props, $$inline: true });
    	binding_callbacks.push(() => bind(radio, 'selectedOption', radio_selectedOption_binding));

    	button0 = new Button({
    			props: {
    				secondary: true,
    				title: "Load from file ",
    				symbol: "📁",
    				onClick: /*func*/ ctx[10]
    			},
    			$$inline: true
    		});

    	let if_block = /*data*/ ctx[0].length > 0 && create_if_block$6(ctx);

    	button1 = new Button({
    			props: {
    				title: "GO",
    				symbol: "▸",
    				disabled: /*data*/ ctx[0].length == 0 || !/*dataIsValid*/ ctx[4],
    				onClick: /*onGoBtnPressed*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			p = element("p");
    			p.textContent = "Input format:";
    			t1 = space();
    			create_component(radio.$$.fragment);
    			t2 = space();
    			textarea = element("textarea");
    			t3 = space();
    			div1 = element("div");
    			create_component(button0.$$.fragment);
    			t4 = space();
    			if (if_block) if_block.c();
    			t5 = space();
    			create_component(button1.$$.fragment);
    			t6 = space();
    			input = element("input");
    			add_location(p, file$c, 78, 4, 2558);
    			attr_dev(div0, "class", "top svelte-gnnepy");
    			add_location(div0, file$c, 77, 2, 2536);

    			attr_dev(textarea, "placeholder", textarea_placeholder_value = /*dataTypeSelected*/ ctx[1] == 0
    			? "Paste some data here."
    			: "Paste some " + /*dataType*/ ctx[2] + " data here.");

    			textarea.autofocus = true;
    			attr_dev(textarea, "class", "svelte-gnnepy");
    			add_location(textarea, file$c, 94, 2, 2949);
    			attr_dev(div1, "class", "buttons svelte-gnnepy");
    			add_location(div1, file$c, 101, 2, 3123);
    			attr_dev(input, "class", "hidden svelte-gnnepy");
    			attr_dev(input, "type", "file");
    			add_location(input, file$c, 138, 2, 4117);
    			attr_dev(div2, "class", "input svelte-gnnepy");
    			add_location(div2, file$c, 76, 0, 2514);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, p);
    			append_dev(div0, t1);
    			mount_component(radio, div0, null);
    			append_dev(div2, t2);
    			append_dev(div2, textarea);
    			set_input_value(textarea, /*data*/ ctx[0]);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			mount_component(button0, div1, null);
    			append_dev(div1, t4);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t5);
    			mount_component(button1, div1, null);
    			append_dev(div2, t6);
    			append_dev(div2, input);
    			/*input_binding*/ ctx[11](input);
    			current = true;
    			textarea.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[9]),
    					listen_dev(input, "change", /*fileSelected*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const radio_changes = {};

    			if (dirty & /*data, dataTypeSelected, dataType*/ 7) radio_changes.options = [
    				/*data*/ ctx[0].length > 0 && /*dataTypeSelected*/ ctx[1] == 0
    				? /*dataType*/ ctx[2].charAt(0).toUpperCase() + /*dataType*/ ctx[2].substring(1, /*dataType*/ ctx[2].length) + " - Detected"
    				: "Auto-detect",
    				"Binary",
    				"Hex",
    				"Base64",
    				"Ascii"
    			];

    			if (!updating_selectedOption && dirty & /*dataTypeSelected*/ 2) {
    				updating_selectedOption = true;
    				radio_changes.selectedOption = /*dataTypeSelected*/ ctx[1];
    				add_flush_callback(() => updating_selectedOption = false);
    			}

    			radio.$set(radio_changes);

    			if (!current || dirty & /*dataTypeSelected, dataType*/ 6 && textarea_placeholder_value !== (textarea_placeholder_value = /*dataTypeSelected*/ ctx[1] == 0
    			? "Paste some data here."
    			: "Paste some " + /*dataType*/ ctx[2] + " data here.")) {
    				attr_dev(textarea, "placeholder", textarea_placeholder_value);
    			}

    			if (dirty & /*data*/ 1) {
    				set_input_value(textarea, /*data*/ ctx[0]);
    			}

    			const button0_changes = {};
    			if (dirty & /*fileSelectBtn*/ 8) button0_changes.onClick = /*func*/ ctx[10];
    			button0.$set(button0_changes);

    			if (/*data*/ ctx[0].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					if_block.m(div1, t5);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const button1_changes = {};
    			if (dirty & /*data, dataIsValid*/ 17) button1_changes.disabled = /*data*/ ctx[0].length == 0 || !/*dataIsValid*/ ctx[4];
    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(radio.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(radio.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(radio);
    			destroy_component(button0);
    			if (if_block) if_block.d();
    			destroy_component(button1);
    			/*input_binding*/ ctx[11](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('InputBox', slots, []);
    	let { onInputConfirm } = $$props;
    	let data = "";
    	let dataType = null;
    	let dataTypeSelected;
    	let fileSelectBtn;
    	let dataIsValid = true;
    	let reader = new FileReader();

    	const onGoBtnPressed = () => {
    		if (dataType == "base64") {
    			onInputConfirm(dataType, "bytes", base64ToArrayBuffer(data));
    		} else if (dataType == "base64url") {
    			onInputConfirm(dataType, "bytes", base64ToArrayBuffer(base64urlToBase64(data)));
    		} else if (dataType == "hex") {
    			onInputConfirm(dataType, "bytes", hexToArrayBuffer(data.replace(/\s/g, "")));
    		} else if (dataType == "binary") {
    			onInputConfirm(dataType, "bytes", binaryStringToArrayBuffer(data));
    		} else if (dataType == "ascii") {
    			onInputConfirm(dataType, "text", data);
    		}
    	};

    	reader.onload = () => {
    		$$invalidate(0, data = arrayBufferToBase64(reader.result));
    		$$invalidate(1, dataTypeSelected = 0);
    	};

    	const fileSelected = () => {
    		if (fileSelectBtn.files.length > 0) {
    			reader.readAsArrayBuffer(fileSelectBtn.files[0]);
    		}
    	};

    	const writable_props = ['onInputConfirm'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InputBox> was created with unknown prop '${key}'`);
    	});

    	function radio_selectedOption_binding(value) {
    		dataTypeSelected = value;
    		$$invalidate(1, dataTypeSelected);
    	}

    	function textarea_input_handler() {
    		data = this.value;
    		$$invalidate(0, data);
    	}

    	const func = () => {
    		fileSelectBtn.click();
    	};

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			fileSelectBtn = $$value;
    			$$invalidate(3, fileSelectBtn);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('onInputConfirm' in $$props) $$invalidate(7, onInputConfirm = $$props.onInputConfirm);
    	};

    	$$self.$capture_state = () => ({
    		Button,
    		Radio,
    		arrayBufferToBase64,
    		base64ToArrayBuffer,
    		hexToArrayBuffer,
    		binaryStringToArrayBuffer,
    		base64urlToBase64,
    		onInputConfirm,
    		data,
    		dataType,
    		dataTypeSelected,
    		fileSelectBtn,
    		dataIsValid,
    		reader,
    		onGoBtnPressed,
    		fileSelected
    	});

    	$$self.$inject_state = $$props => {
    		if ('onInputConfirm' in $$props) $$invalidate(7, onInputConfirm = $$props.onInputConfirm);
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('dataType' in $$props) $$invalidate(2, dataType = $$props.dataType);
    		if ('dataTypeSelected' in $$props) $$invalidate(1, dataTypeSelected = $$props.dataTypeSelected);
    		if ('fileSelectBtn' in $$props) $$invalidate(3, fileSelectBtn = $$props.fileSelectBtn);
    		if ('dataIsValid' in $$props) $$invalidate(4, dataIsValid = $$props.dataIsValid);
    		if ('reader' in $$props) reader = $$props.reader;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*dataTypeSelected, data*/ 3) {
    			{
    				if (dataTypeSelected == 0) {
    					$$invalidate(4, dataIsValid = true);

    					if ((/^[01 ]+$/g).test(data) && data.replace(/\s/g, "").length % 8 == 0) {
    						$$invalidate(2, dataType = "binary");
    					} else if ((/^([0-9a-f][0-9a-f] ?)+$/gi).test(data)) {
    						$$invalidate(2, dataType = "hex");
    					} else if ((/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}(?:=)?)?$/g).test(data)) {
    						$$invalidate(2, dataType = "base64");
    					} else if ((/^(?:[A-Za-z0-9\-\_]{4})*(?:[A-Za-z0-9\-\_]{2}(?:==)?|[A-Za-z0-9\-\_]{3}(?:=)?)?$/g).test(data)) {
    						$$invalidate(2, dataType = "base64url");
    					} else {
    						$$invalidate(2, dataType = "ascii");
    					}
    				} else if (dataTypeSelected == 1) {
    					$$invalidate(2, dataType = "binary");
    					$$invalidate(4, dataIsValid = (/^[01 ]+$/g).test(data) && data.replace(/\s/g, "").length % 8 == 0);
    				} else if (dataTypeSelected == 2) {
    					$$invalidate(2, dataType = "hex");
    					$$invalidate(4, dataIsValid = (/^([0-9a-f][0-9a-f] ?)+$/gi).test(data));
    				} else if (dataTypeSelected == 3) {
    					$$invalidate(2, dataType = "base64");
    					$$invalidate(4, dataIsValid = (/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}(?:=)?)?$/g).test(data));
    				} else if (dataTypeSelected == 4) {
    					$$invalidate(2, dataType = "ascii");
    					$$invalidate(4, dataIsValid = true);
    				}
    			}
    		}
    	};

    	return [
    		data,
    		dataTypeSelected,
    		dataType,
    		fileSelectBtn,
    		dataIsValid,
    		onGoBtnPressed,
    		fileSelected,
    		onInputConfirm,
    		radio_selectedOption_binding,
    		textarea_input_handler,
    		func,
    		input_binding
    	];
    }

    class InputBox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { onInputConfirm: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InputBox",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onInputConfirm*/ ctx[7] === undefined && !('onInputConfirm' in props)) {
    			console.warn("<InputBox> was created without expected prop 'onInputConfirm'");
    		}
    	}

    	get onInputConfirm() {
    		throw new Error("<InputBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onInputConfirm(value) {
    		throw new Error("<InputBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/decoders/Ascii.svelte generated by Svelte v3.48.0 */
    const file$b = "src/components/decoders/Ascii.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (19:6) {#each hexBytes as byte, i}
    function create_each_block_1$1(ctx) {
    	let span;
    	let t_value = /*byte*/ ctx[10] + "";
    	let t;
    	let span_class_value;
    	let mounted;
    	let dispose;

    	function mouseenter_handler() {
    		return /*mouseenter_handler*/ ctx[3](/*i*/ ctx[9]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", span_class_value = "" + (null_to_empty(/*hoveredByte*/ ctx[2] == /*i*/ ctx[9] ? "selected" : "") + " svelte-1uhw6c8"));
    			add_location(span, file$b, 19, 8, 534);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(span, "mouseenter", mouseenter_handler, false, false, false),
    					listen_dev(span, "mouseleave", /*mouseleave_handler*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*hexBytes*/ 2 && t_value !== (t_value = /*byte*/ ctx[10] + "")) set_data_dev(t, t_value);

    			if (dirty & /*hoveredByte*/ 4 && span_class_value !== (span_class_value = "" + (null_to_empty(/*hoveredByte*/ ctx[2] == /*i*/ ctx[9] ? "selected" : "") + " svelte-1uhw6c8"))) {
    				attr_dev(span, "class", span_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(19:6) {#each hexBytes as byte, i}",
    		ctx
    	});

    	return block;
    }

    // (41:8) {:else}
    function create_else_block$4(ctx) {
    	let span;
    	let t_value = /*char*/ ctx[7] + "";
    	let t;
    	let span_class_value;
    	let mounted;
    	let dispose;

    	function mouseenter_handler_1() {
    		return /*mouseenter_handler_1*/ ctx[5](/*i*/ ctx[9]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", span_class_value = "" + (null_to_empty(/*hoveredByte*/ ctx[2] == /*i*/ ctx[9] ? "selected" : "") + " svelte-1uhw6c8"));
    			add_location(span, file$b, 41, 10, 1071);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(span, "mouseenter", mouseenter_handler_1, false, false, false),
    					listen_dev(span, "mouseleave", /*mouseleave_handler_1*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*result*/ 1 && t_value !== (t_value = /*char*/ ctx[7] + "")) set_data_dev(t, t_value);

    			if (dirty & /*hoveredByte*/ 4 && span_class_value !== (span_class_value = "" + (null_to_empty(/*hoveredByte*/ ctx[2] == /*i*/ ctx[9] ? "selected" : "") + " svelte-1uhw6c8"))) {
    				attr_dev(span, "class", span_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(41:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (36:8) {#if char == "\n"}
    function create_if_block$5(ctx) {
    	let t;
    	let br;
    	let if_block = /*hoveredByte*/ ctx[2] == /*i*/ ctx[9] && create_if_block_1$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			br = element("br");
    			add_location(br, file$b, 39, 10, 1038);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*hoveredByte*/ ctx[2] == /*i*/ ctx[9]) {
    				if (if_block) ; else {
    					if_block = create_if_block_1$3(ctx);
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(36:8) {#if char == \\\"\\n\\\"}",
    		ctx
    	});

    	return block;
    }

    // (37:10) {#if hoveredByte == i}
    function create_if_block_1$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "\\n";
    			attr_dev(span, "class", "selected svelte-1uhw6c8");
    			add_location(span, file$b, 37, 12, 979);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(37:10) {#if hoveredByte == i}",
    		ctx
    	});

    	return block;
    }

    // (35:6) {#each result.value.split("") as char, i}
    function create_each_block$4(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*char*/ ctx[7] == "\n") return create_if_block$5;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(35:6) {#each result.value.split(\\\"\\\") as char, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let div4;
    	let div1;
    	let p0;
    	let t1;
    	let div0;
    	let t2;
    	let div3;
    	let p1;
    	let t4;
    	let div2;
    	let each_value_1 = /*hexBytes*/ ctx[1];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	let each_value = /*result*/ ctx[0].value.split("");
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div1 = element("div");
    			p0 = element("p");
    			p0.textContent = "Input bytes as hexadecimal";
    			t1 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t2 = space();
    			div3 = element("div");
    			p1 = element("p");
    			p1.textContent = "Ascii String";
    			t4 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(p0, "class", "svelte-1uhw6c8");
    			add_location(p0, file$b, 16, 4, 448);
    			attr_dev(div0, "class", "svelte-1uhw6c8");
    			add_location(div0, file$b, 17, 4, 486);
    			attr_dev(div1, "class", "hex svelte-1uhw6c8");
    			add_location(div1, file$b, 15, 2, 426);
    			attr_dev(p1, "class", "svelte-1uhw6c8");
    			add_location(p1, file$b, 32, 4, 829);
    			attr_dev(div2, "class", "svelte-1uhw6c8");
    			add_location(div2, file$b, 33, 4, 853);
    			attr_dev(div3, "class", "ascii svelte-1uhw6c8");
    			add_location(div3, file$b, 31, 2, 805);
    			attr_dev(div4, "class", "ascii-container svelte-1uhw6c8");
    			add_location(div4, file$b, 14, 0, 394);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div1);
    			append_dev(div1, p0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div0, null);
    			}

    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			append_dev(div3, p1);
    			append_dev(div3, t4);
    			append_dev(div3, div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*hoveredByte, hexBytes*/ 6) {
    				each_value_1 = /*hexBytes*/ ctx[1];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*hoveredByte, result*/ 5) {
    				each_value = /*result*/ ctx[0].value.split("");
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ascii', slots, []);
    	let { result } = $$props;
    	let hexBytes = [];
    	let hoveredByte = null;
    	const writable_props = ['result'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Ascii> was created with unknown prop '${key}'`);
    	});

    	const mouseenter_handler = i => {
    		$$invalidate(2, hoveredByte = i);
    	};

    	const mouseleave_handler = () => {
    		$$invalidate(2, hoveredByte = null);
    	};

    	const mouseenter_handler_1 = i => {
    		$$invalidate(2, hoveredByte = i);
    	};

    	const mouseleave_handler_1 = () => {
    		$$invalidate(2, hoveredByte = null);
    	};

    	$$self.$$set = $$props => {
    		if ('result' in $$props) $$invalidate(0, result = $$props.result);
    	};

    	$$self.$capture_state = () => ({
    		arrayBufferToHex,
    		asciiStringToArrayBuffer,
    		result,
    		hexBytes,
    		hoveredByte
    	});

    	$$self.$inject_state = $$props => {
    		if ('result' in $$props) $$invalidate(0, result = $$props.result);
    		if ('hexBytes' in $$props) $$invalidate(1, hexBytes = $$props.hexBytes);
    		if ('hoveredByte' in $$props) $$invalidate(2, hoveredByte = $$props.hoveredByte);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*result, hexBytes*/ 3) {
    			{
    				let hex = arrayBufferToHex(asciiStringToArrayBuffer(result.value));
    				$$invalidate(1, hexBytes = []);

    				for (let i = 0; i < hex.length / 2; i++) {
    					hexBytes.push(hex.substring(i * 2, i * 2 + 2));
    				}
    			}
    		}
    	};

    	return [
    		result,
    		hexBytes,
    		hoveredByte,
    		mouseenter_handler,
    		mouseleave_handler,
    		mouseenter_handler_1,
    		mouseleave_handler_1
    	];
    }

    class Ascii extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { result: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ascii",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*result*/ ctx[0] === undefined && !('result' in props)) {
    			console.warn("<Ascii> was created without expected prop 'result'");
    		}
    	}

    	get result() {
    		throw new Error("<Ascii>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set result(value) {
    		throw new Error("<Ascii>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var asciiDecoder = {
        name: "Ascii",
        fullName: "American Standard Code for Information Interchange",
        rfc: 20,
        inputType: "bytes",
        outputType: "text",
        display: Ascii,
        f: (bytes) => {
            let byteArray = new Uint8Array(bytes);
            let outStr = "";
            for (var i = 0; i < byteArray.length; i++) {
                let b = byteArray[i];
                if (b >= 0 && b <= 255) {
                    outStr += String.fromCharCode(b);
                }
                else {
                    return [null, null];
                }
            }
            return [outStr, null];
        }
    };

    var base64Decoder = {
        name: "Base64",
        rfc: 3548,
        inputType: "text",
        outputType: "bytes",
        f: (text) => {
            if (/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}(?:=)?)?$/g.test(text)) {
                return [base64ToArrayBuffer(text), null];
            }
            else {
                return [null, null];
            }
        }
    };

    var base64urlDecoder = {
        name: "Base64url",
        rfc: 4648,
        inputType: "text",
        outputType: "bytes",
        f: (text) => {
            if (/^(?:[A-Za-z0-9\-\_]{4})*(?:[A-Za-z0-9\-\_]{2}(?:==)?|[A-Za-z0-9\-\_]{3}(?:=)?)?$/g.test(text)) {
                return [base64ToArrayBuffer(base64urlToBase64(text)), null];
            }
            else {
                return [null, null];
            }
        }
    };

    var hexDecoder = {
        name: "Hex",
        fullName: "Hexadecimal / Base16",
        rfc: 3548,
        inputType: "text",
        outputType: "bytes",
        f: (text) => {
            if (/^([0-9a-f][0-9a-f] ?)+$/gi.test(text)) {
                return [hexToArrayBuffer(text.replace(/\s/g, "")), null];
            }
            else {
                return [null, null];
            }
        }
    };

    /* src/components/Code.svelte generated by Svelte v3.48.0 */

    const file$a = "src/components/Code.svelte";

    function create_fragment$a(ctx) {
    	let textarea;

    	const block = {
    		c: function create() {
    			textarea = element("textarea");
    			textarea.disabled = true;
    			textarea.value = /*string*/ ctx[0];
    			attr_dev(textarea, "class", "svelte-phsbod");
    			set_style(textarea, "color", /*fontColor*/ ctx[1], false);
    			set_style(textarea, "min-height", /*height*/ ctx[2], false);
    			add_location(textarea, file$a, 5, 0, 109);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*string*/ 1) {
    				prop_dev(textarea, "value", /*string*/ ctx[0]);
    			}

    			if (dirty & /*fontColor*/ 2) {
    				set_style(textarea, "color", /*fontColor*/ ctx[1], false);
    			}

    			if (dirty & /*height*/ 4) {
    				set_style(textarea, "min-height", /*height*/ ctx[2], false);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Code', slots, []);
    	let { string } = $$props;
    	let { fontColor = "black" } = $$props;
    	let { height = "220px" } = $$props;
    	const writable_props = ['string', 'fontColor', 'height'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Code> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('string' in $$props) $$invalidate(0, string = $$props.string);
    		if ('fontColor' in $$props) $$invalidate(1, fontColor = $$props.fontColor);
    		if ('height' in $$props) $$invalidate(2, height = $$props.height);
    	};

    	$$self.$capture_state = () => ({ string, fontColor, height });

    	$$self.$inject_state = $$props => {
    		if ('string' in $$props) $$invalidate(0, string = $$props.string);
    		if ('fontColor' in $$props) $$invalidate(1, fontColor = $$props.fontColor);
    		if ('height' in $$props) $$invalidate(2, height = $$props.height);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [string, fontColor, height];
    }

    class Code extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { string: 0, fontColor: 1, height: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Code",
    			options,
    			id: create_fragment$a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*string*/ ctx[0] === undefined && !('string' in props)) {
    			console.warn("<Code> was created without expected prop 'string'");
    		}
    	}

    	get string() {
    		throw new Error("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set string(value) {
    		throw new Error("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontColor() {
    		throw new Error("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontColor(value) {
    		throw new Error("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/decoders/JSON.svelte generated by Svelte v3.48.0 */
    const file$9 = "src/components/decoders/JSON.svelte";

    function create_fragment$9(ctx) {
    	let div2;
    	let div0;
    	let p0;
    	let t1;
    	let code0;
    	let t2;
    	let div1;
    	let p1;
    	let t4;
    	let code1;
    	let current;

    	code0 = new Code({
    			props: {
    				string: JSON.stringify(/*result*/ ctx[0].value)
    			},
    			$$inline: true
    		});

    	code1 = new Code({
    			props: {
    				string: JSON.stringify(/*result*/ ctx[0].value, null, 4)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			p0 = element("p");
    			p0.textContent = "Original";
    			t1 = space();
    			create_component(code0.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			p1 = element("p");
    			p1.textContent = "Beautified";
    			t4 = space();
    			create_component(code1.$$.fragment);
    			attr_dev(p0, "class", "svelte-1mkclug");
    			add_location(p0, file$9, 7, 4, 138);
    			attr_dev(div0, "class", "svelte-1mkclug");
    			add_location(div0, file$9, 6, 2, 128);
    			attr_dev(p1, "class", "svelte-1mkclug");
    			add_location(p1, file$9, 11, 4, 226);
    			attr_dev(div1, "class", "svelte-1mkclug");
    			add_location(div1, file$9, 10, 2, 216);
    			attr_dev(div2, "class", "json svelte-1mkclug");
    			add_location(div2, file$9, 5, 0, 107);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, p0);
    			append_dev(div0, t1);
    			mount_component(code0, div0, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, p1);
    			append_dev(div1, t4);
    			mount_component(code1, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const code0_changes = {};
    			if (dirty & /*result*/ 1) code0_changes.string = JSON.stringify(/*result*/ ctx[0].value);
    			code0.$set(code0_changes);
    			const code1_changes = {};
    			if (dirty & /*result*/ 1) code1_changes.string = JSON.stringify(/*result*/ ctx[0].value, null, 4);
    			code1.$set(code1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(code0.$$.fragment, local);
    			transition_in(code1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(code0.$$.fragment, local);
    			transition_out(code1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(code0);
    			destroy_component(code1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('JSON', slots, []);
    	let { result } = $$props;
    	const writable_props = ['result'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<JSON> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('result' in $$props) $$invalidate(0, result = $$props.result);
    	};

    	$$self.$capture_state = () => ({ Code, result });

    	$$self.$inject_state = $$props => {
    		if ('result' in $$props) $$invalidate(0, result = $$props.result);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [result];
    }

    class JSON_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { result: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "JSON_1",
    			options,
    			id: create_fragment$9.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*result*/ ctx[0] === undefined && !('result' in props)) {
    			console.warn("<JSON> was created without expected prop 'result'");
    		}
    	}

    	get result() {
    		throw new Error("<JSON>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set result(value) {
    		throw new Error("<JSON>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var jsonDecoder = {
        name: "JSON",
        fullName: "JavaScript Object Notation",
        rfc: 7159,
        inputType: "text",
        outputType: "json",
        display: JSON_1,
        f: (text) => {
            try {
                return [JSON.parse(text), null];
            }
            catch (_a) {
                return [null, null];
            }
        }
    };

    /* src/components/decoders/JWT.svelte generated by Svelte v3.48.0 */
    const file$8 = "src/components/decoders/JWT.svelte";

    function create_fragment$8(ctx) {
    	let div4;
    	let div1;
    	let p0;
    	let t1;
    	let div0;
    	let span0;
    	let t2_value = /*result*/ ctx[0].value.raw.split(".")[0] + "";
    	let t2;
    	let t3;
    	let span1;
    	let t4_value = /*result*/ ctx[0].value.raw.split(".")[1] + "";
    	let t4;
    	let t5;
    	let t6_value = /*result*/ ctx[0].value.raw.split(".")[2] + "";
    	let t6;
    	let t7;
    	let div3;
    	let p1;
    	let t9;
    	let code0;
    	let t10;
    	let div2;
    	let t11;
    	let p2;
    	let t13;
    	let code1;
    	let current;

    	code0 = new Code({
    			props: {
    				string: JSON.stringify(/*result*/ ctx[0].value.header, null, 4),
    				fontColor: "var(--tertiaryAccentColor)",
    				height: "100px"
    			},
    			$$inline: true
    		});

    	code1 = new Code({
    			props: {
    				string: JSON.stringify(/*result*/ ctx[0].value.payload, null, 4),
    				fontColor: "var(--secondaryAccentColor)",
    				height: "100px"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div1 = element("div");
    			p0 = element("p");
    			p0.textContent = "Token";
    			t1 = space();
    			div0 = element("div");
    			span0 = element("span");
    			t2 = text(t2_value);
    			t3 = text(".");
    			span1 = element("span");
    			t4 = text(t4_value);
    			t5 = text(".");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			p1 = element("p");
    			p1.textContent = "Header";
    			t9 = space();
    			create_component(code0.$$.fragment);
    			t10 = space();
    			div2 = element("div");
    			t11 = space();
    			p2 = element("p");
    			p2.textContent = "Payload";
    			t13 = space();
    			create_component(code1.$$.fragment);
    			attr_dev(p0, "class", "svelte-1dgfbee");
    			add_location(p0, file$8, 7, 4, 137);
    			attr_dev(span0, "class", "svelte-1dgfbee");
    			set_style(span0, "color", `var(--tertiaryAccentColor)`, false);
    			add_location(span0, file$8, 9, 6, 180);
    			attr_dev(span1, "class", "svelte-1dgfbee");
    			set_style(span1, "color", `var(--secondaryAccentColor)`, false);
    			add_location(span1, file$8, 11, 8, 283);
    			attr_dev(div0, "class", "token svelte-1dgfbee");
    			add_location(div0, file$8, 8, 4, 154);
    			attr_dev(div1, "class", "svelte-1dgfbee");
    			add_location(div1, file$8, 6, 2, 127);
    			attr_dev(p1, "class", "svelte-1dgfbee");
    			add_location(p1, file$8, 17, 4, 452);
    			attr_dev(div2, "class", "spacer svelte-1dgfbee");
    			add_location(div2, file$8, 23, 4, 613);
    			attr_dev(p2, "class", "svelte-1dgfbee");
    			add_location(p2, file$8, 24, 4, 640);
    			attr_dev(div3, "class", "svelte-1dgfbee");
    			add_location(div3, file$8, 16, 2, 442);
    			attr_dev(div4, "class", "jwt svelte-1dgfbee");
    			add_location(div4, file$8, 5, 0, 107);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div1);
    			append_dev(div1, p0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t2);
    			append_dev(div0, t3);
    			append_dev(div0, span1);
    			append_dev(span1, t4);
    			append_dev(div0, t5);
    			append_dev(div0, t6);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, p1);
    			append_dev(div3, t9);
    			mount_component(code0, div3, null);
    			append_dev(div3, t10);
    			append_dev(div3, div2);
    			append_dev(div3, t11);
    			append_dev(div3, p2);
    			append_dev(div3, t13);
    			mount_component(code1, div3, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*result*/ 1) && t2_value !== (t2_value = /*result*/ ctx[0].value.raw.split(".")[0] + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty & /*result*/ 1) && t4_value !== (t4_value = /*result*/ ctx[0].value.raw.split(".")[1] + "")) set_data_dev(t4, t4_value);
    			if ((!current || dirty & /*result*/ 1) && t6_value !== (t6_value = /*result*/ ctx[0].value.raw.split(".")[2] + "")) set_data_dev(t6, t6_value);
    			const code0_changes = {};
    			if (dirty & /*result*/ 1) code0_changes.string = JSON.stringify(/*result*/ ctx[0].value.header, null, 4);
    			code0.$set(code0_changes);
    			const code1_changes = {};
    			if (dirty & /*result*/ 1) code1_changes.string = JSON.stringify(/*result*/ ctx[0].value.payload, null, 4);
    			code1.$set(code1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(code0.$$.fragment, local);
    			transition_in(code1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(code0.$$.fragment, local);
    			transition_out(code1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(code0);
    			destroy_component(code1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('JWT', slots, []);
    	let { result } = $$props;
    	const writable_props = ['result'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<JWT> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('result' in $$props) $$invalidate(0, result = $$props.result);
    	};

    	$$self.$capture_state = () => ({ Code, result });

    	$$self.$inject_state = $$props => {
    		if ('result' in $$props) $$invalidate(0, result = $$props.result);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [result];
    }

    class JWT extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { result: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "JWT",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*result*/ ctx[0] === undefined && !('result' in props)) {
    			console.warn("<JWT> was created without expected prop 'result'");
    		}
    	}

    	get result() {
    		throw new Error("<JWT>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set result(value) {
    		throw new Error("<JWT>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var jwtDecoder = {
        name: "JWT",
        fullName: "JSON Web Token",
        rfc: 7519,
        inputType: "text",
        outputType: "jwt",
        display: JWT,
        f: (text) => {
            try {
                let parts = text.split(".");
                if (parts.length != 3) {
                    return [null, null];
                }
                let header = JSON.parse(window.atob(base64urlToBase64(parts[0])));
                let payload = JSON.parse(window.atob(base64urlToBase64(parts[1])));
                return [{
                        raw: text,
                        header,
                        payload
                    }, null];
            }
            catch (_a) {
                return [null, null];
            }
        }
    };

    /*!
     * MIT License
     * 
     * Copyright (c) 2017-2022 Peculiar Ventures, LLC
     * 
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     * 
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     * 
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     * 
     */



    const ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
    class BufferSourceConverter {
        static isArrayBuffer(data) {
            return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
        }
        static toArrayBuffer(data) {
            if (this.isArrayBuffer(data)) {
                return data;
            }
            if (data.byteLength === data.buffer.byteLength) {
                return data.buffer;
            }
            return this.toUint8Array(data).slice().buffer;
        }
        static toUint8Array(data) {
            return this.toView(data, Uint8Array);
        }
        static toView(data, type) {
            if (data.constructor === type) {
                return data;
            }
            if (this.isArrayBuffer(data)) {
                return new type(data);
            }
            if (this.isArrayBufferView(data)) {
                return new type(data.buffer, data.byteOffset, data.byteLength);
            }
            throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        static isBufferSource(data) {
            return this.isArrayBufferView(data)
                || this.isArrayBuffer(data);
        }
        static isArrayBufferView(data) {
            return ArrayBuffer.isView(data)
                || (data && this.isArrayBuffer(data.buffer));
        }
        static isEqual(a, b) {
            const aView = BufferSourceConverter.toUint8Array(a);
            const bView = BufferSourceConverter.toUint8Array(b);
            if (aView.length !== bView.byteLength) {
                return false;
            }
            for (let i = 0; i < aView.length; i++) {
                if (aView[i] !== bView[i]) {
                    return false;
                }
            }
            return true;
        }
        static concat(...args) {
            if (Array.isArray(args[0])) {
                const buffers = args[0];
                let size = 0;
                for (const buffer of buffers) {
                    size += buffer.byteLength;
                }
                const res = new Uint8Array(size);
                let offset = 0;
                for (const buffer of buffers) {
                    const view = this.toUint8Array(buffer);
                    res.set(view, offset);
                    offset += view.length;
                }
                if (args[1]) {
                    return this.toView(res, args[1]);
                }
                return res.buffer;
            }
            else {
                return this.concat(args);
            }
        }
    }

    class Utf8Converter {
        static fromString(text) {
            const s = unescape(encodeURIComponent(text));
            const uintArray = new Uint8Array(s.length);
            for (let i = 0; i < s.length; i++) {
                uintArray[i] = s.charCodeAt(i);
            }
            return uintArray.buffer;
        }
        static toString(buffer) {
            const buf = BufferSourceConverter.toUint8Array(buffer);
            let encodedString = "";
            for (let i = 0; i < buf.length; i++) {
                encodedString += String.fromCharCode(buf[i]);
            }
            const decodedString = decodeURIComponent(escape(encodedString));
            return decodedString;
        }
    }
    class Utf16Converter {
        static toString(buffer, littleEndian = false) {
            const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
            const dataView = new DataView(arrayBuffer);
            let res = "";
            for (let i = 0; i < arrayBuffer.byteLength; i += 2) {
                const code = dataView.getUint16(i, littleEndian);
                res += String.fromCharCode(code);
            }
            return res;
        }
        static fromString(text, littleEndian = false) {
            const res = new ArrayBuffer(text.length * 2);
            const dataView = new DataView(res);
            for (let i = 0; i < text.length; i++) {
                dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);
            }
            return res;
        }
    }
    class Convert {
        static isHex(data) {
            return typeof data === "string"
                && /^[a-z0-9]+$/i.test(data);
        }
        static isBase64(data) {
            return typeof data === "string"
                && /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(data);
        }
        static isBase64Url(data) {
            return typeof data === "string"
                && /^[a-zA-Z0-9-_]+$/i.test(data);
        }
        static ToString(buffer, enc = "utf8") {
            const buf = BufferSourceConverter.toUint8Array(buffer);
            switch (enc.toLowerCase()) {
                case "utf8":
                    return this.ToUtf8String(buf);
                case "binary":
                    return this.ToBinary(buf);
                case "hex":
                    return this.ToHex(buf);
                case "base64":
                    return this.ToBase64(buf);
                case "base64url":
                    return this.ToBase64Url(buf);
                case "utf16le":
                    return Utf16Converter.toString(buf, true);
                case "utf16":
                case "utf16be":
                    return Utf16Converter.toString(buf);
                default:
                    throw new Error(`Unknown type of encoding '${enc}'`);
            }
        }
        static FromString(str, enc = "utf8") {
            if (!str) {
                return new ArrayBuffer(0);
            }
            switch (enc.toLowerCase()) {
                case "utf8":
                    return this.FromUtf8String(str);
                case "binary":
                    return this.FromBinary(str);
                case "hex":
                    return this.FromHex(str);
                case "base64":
                    return this.FromBase64(str);
                case "base64url":
                    return this.FromBase64Url(str);
                case "utf16le":
                    return Utf16Converter.fromString(str, true);
                case "utf16":
                case "utf16be":
                    return Utf16Converter.fromString(str);
                default:
                    throw new Error(`Unknown type of encoding '${enc}'`);
            }
        }
        static ToBase64(buffer) {
            const buf = BufferSourceConverter.toUint8Array(buffer);
            if (typeof btoa !== "undefined") {
                const binary = this.ToString(buf, "binary");
                return btoa(binary);
            }
            else {
                return Buffer.from(buf).toString("base64");
            }
        }
        static FromBase64(base64) {
            const formatted = this.formatString(base64);
            if (!formatted) {
                return new ArrayBuffer(0);
            }
            if (!Convert.isBase64(formatted)) {
                throw new TypeError("Argument 'base64Text' is not Base64 encoded");
            }
            if (typeof atob !== "undefined") {
                return this.FromBinary(atob(formatted));
            }
            else {
                return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
            }
        }
        static FromBase64Url(base64url) {
            const formatted = this.formatString(base64url);
            if (!formatted) {
                return new ArrayBuffer(0);
            }
            if (!Convert.isBase64Url(formatted)) {
                throw new TypeError("Argument 'base64url' is not Base64Url encoded");
            }
            return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
        }
        static ToBase64Url(data) {
            return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
        }
        static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {
            switch (encoding) {
                case "ascii":
                    return this.FromBinary(text);
                case "utf8":
                    return Utf8Converter.fromString(text);
                case "utf16":
                case "utf16be":
                    return Utf16Converter.fromString(text);
                case "utf16le":
                case "usc2":
                    return Utf16Converter.fromString(text, true);
                default:
                    throw new Error(`Unknown type of encoding '${encoding}'`);
            }
        }
        static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {
            switch (encoding) {
                case "ascii":
                    return this.ToBinary(buffer);
                case "utf8":
                    return Utf8Converter.toString(buffer);
                case "utf16":
                case "utf16be":
                    return Utf16Converter.toString(buffer);
                case "utf16le":
                case "usc2":
                    return Utf16Converter.toString(buffer, true);
                default:
                    throw new Error(`Unknown type of encoding '${encoding}'`);
            }
        }
        static FromBinary(text) {
            const stringLength = text.length;
            const resultView = new Uint8Array(stringLength);
            for (let i = 0; i < stringLength; i++) {
                resultView[i] = text.charCodeAt(i);
            }
            return resultView.buffer;
        }
        static ToBinary(buffer) {
            const buf = BufferSourceConverter.toUint8Array(buffer);
            let res = "";
            for (let i = 0; i < buf.length; i++) {
                res += String.fromCharCode(buf[i]);
            }
            return res;
        }
        static ToHex(buffer) {
            const buf = BufferSourceConverter.toUint8Array(buffer);
            const splitter = "";
            const res = [];
            const len = buf.length;
            for (let i = 0; i < len; i++) {
                const char = buf[i].toString(16).padStart(2, "0");
                res.push(char);
            }
            return res.join(splitter);
        }
        static FromHex(hexString) {
            let formatted = this.formatString(hexString);
            if (!formatted) {
                return new ArrayBuffer(0);
            }
            if (!Convert.isHex(formatted)) {
                throw new TypeError("Argument 'hexString' is not HEX encoded");
            }
            if (formatted.length % 2) {
                formatted = `0${formatted}`;
            }
            const res = new Uint8Array(formatted.length / 2);
            for (let i = 0; i < formatted.length; i = i + 2) {
                const c = formatted.slice(i, i + 2);
                res[i / 2] = parseInt(c, 16);
            }
            return res.buffer;
        }
        static ToUtf16String(buffer, littleEndian = false) {
            return Utf16Converter.toString(buffer, littleEndian);
        }
        static FromUtf16String(text, littleEndian = false) {
            return Utf16Converter.fromString(text, littleEndian);
        }
        static Base64Padding(base64) {
            const padCount = 4 - (base64.length % 4);
            if (padCount < 4) {
                for (let i = 0; i < padCount; i++) {
                    base64 += "=";
                }
            }
            return base64;
        }
        static formatString(data) {
            return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
        }
    }
    Convert.DEFAULT_UTF8_ENCODING = "utf8";

    var BufferSourceConverter_1 = BufferSourceConverter;
    var Convert_1 = Convert;

    /*!
     Copyright (c) Peculiar Ventures, LLC
    */
    function getParametersValue(parameters, name, defaultValue) {
        var _a;
        if ((parameters instanceof Object) === false) {
            return defaultValue;
        }
        return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;
    }
    function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = (inputBuffer.byteLength - inputOffset), insertSpace = false) {
        let result = "";
        for (const item of (new Uint8Array(inputBuffer, inputOffset, inputLength))) {
            const str = item.toString(16).toUpperCase();
            if (str.length === 1) {
                result += "0";
            }
            result += str;
            if (insertSpace) {
                result += " ";
            }
        }
        return result.trim();
    }
    function utilFromBase(inputBuffer, inputBase) {
        let result = 0;
        if (inputBuffer.length === 1) {
            return inputBuffer[0];
        }
        for (let i = (inputBuffer.length - 1); i >= 0; i--) {
            result += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);
        }
        return result;
    }
    function utilToBase(value, base, reserved = (-1)) {
        const internalReserved = reserved;
        let internalValue = value;
        let result = 0;
        let biggest = Math.pow(2, base);
        for (let i = 1; i < 8; i++) {
            if (value < biggest) {
                let retBuf;
                if (internalReserved < 0) {
                    retBuf = new ArrayBuffer(i);
                    result = i;
                }
                else {
                    if (internalReserved < i) {
                        return (new ArrayBuffer(0));
                    }
                    retBuf = new ArrayBuffer(internalReserved);
                    result = internalReserved;
                }
                const retView = new Uint8Array(retBuf);
                for (let j = (i - 1); j >= 0; j--) {
                    const basis = Math.pow(2, j * base);
                    retView[result - j - 1] = Math.floor(internalValue / basis);
                    internalValue -= (retView[result - j - 1]) * basis;
                }
                return retBuf;
            }
            biggest *= Math.pow(2, base);
        }
        return new ArrayBuffer(0);
    }
    function utilConcatBuf(...buffers) {
        let outputLength = 0;
        let prevLength = 0;
        for (const buffer of buffers) {
            outputLength += buffer.byteLength;
        }
        const retBuf = new ArrayBuffer(outputLength);
        const retView = new Uint8Array(retBuf);
        for (const buffer of buffers) {
            retView.set(new Uint8Array(buffer), prevLength);
            prevLength += buffer.byteLength;
        }
        return retBuf;
    }
    function utilConcatView(...views) {
        let outputLength = 0;
        let prevLength = 0;
        for (const view of views) {
            outputLength += view.length;
        }
        const retBuf = new ArrayBuffer(outputLength);
        const retView = new Uint8Array(retBuf);
        for (const view of views) {
            retView.set(view, prevLength);
            prevLength += view.length;
        }
        return retView;
    }
    function utilDecodeTC() {
        const buf = new Uint8Array(this.valueHex);
        if (this.valueHex.byteLength >= 2) {
            const condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);
            const condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);
            if (condition1 || condition2) {
                this.warnings.push("Needlessly long format");
            }
        }
        const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
        const bigIntView = new Uint8Array(bigIntBuffer);
        for (let i = 0; i < this.valueHex.byteLength; i++) {
            bigIntView[i] = 0;
        }
        bigIntView[0] = (buf[0] & 0x80);
        const bigInt = utilFromBase(bigIntView, 8);
        const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
        const smallIntView = new Uint8Array(smallIntBuffer);
        for (let j = 0; j < this.valueHex.byteLength; j++) {
            smallIntView[j] = buf[j];
        }
        smallIntView[0] &= 0x7F;
        const smallInt = utilFromBase(smallIntView, 8);
        return (smallInt - bigInt);
    }
    function utilEncodeTC(value) {
        const modValue = (value < 0) ? (value * (-1)) : value;
        let bigInt = 128;
        for (let i = 1; i < 8; i++) {
            if (modValue <= bigInt) {
                if (value < 0) {
                    const smallInt = bigInt - modValue;
                    const retBuf = utilToBase(smallInt, 8, i);
                    const retView = new Uint8Array(retBuf);
                    retView[0] |= 0x80;
                    return retBuf;
                }
                let retBuf = utilToBase(modValue, 8, i);
                let retView = new Uint8Array(retBuf);
                if (retView[0] & 0x80) {
                    const tempBuf = retBuf.slice(0);
                    const tempView = new Uint8Array(tempBuf);
                    retBuf = new ArrayBuffer(retBuf.byteLength + 1);
                    retView = new Uint8Array(retBuf);
                    for (let k = 0; k < tempBuf.byteLength; k++) {
                        retView[k + 1] = tempView[k];
                    }
                    retView[0] = 0x00;
                }
                return retBuf;
            }
            bigInt *= Math.pow(2, 8);
        }
        return (new ArrayBuffer(0));
    }
    function isEqualBuffer(inputBuffer1, inputBuffer2) {
        if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
            return false;
        }
        const view1 = new Uint8Array(inputBuffer1);
        const view2 = new Uint8Array(inputBuffer2);
        for (let i = 0; i < view1.length; i++) {
            if (view1[i] !== view2[i]) {
                return false;
            }
        }
        return true;
    }
    function padNumber(inputNumber, fullLength) {
        const str = inputNumber.toString(10);
        if (fullLength < str.length) {
            return "";
        }
        const dif = fullLength - str.length;
        const padding = new Array(dif);
        for (let i = 0; i < dif; i++) {
            padding[i] = "0";
        }
        const paddingString = padding.join("");
        return paddingString.concat(str);
    }
    const base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    const base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
    function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {
        let i = 0;
        let flag1 = 0;
        let flag2 = 0;
        let output = "";
        const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;
        if (skipLeadingZeros) {
            let nonZeroPosition = 0;
            for (let i = 0; i < input.length; i++) {
                if (input.charCodeAt(i) !== 0) {
                    nonZeroPosition = i;
                    break;
                }
            }
            input = input.slice(nonZeroPosition);
        }
        while (i < input.length) {
            const chr1 = input.charCodeAt(i++);
            if (i >= input.length) {
                flag1 = 1;
            }
            const chr2 = input.charCodeAt(i++);
            if (i >= input.length) {
                flag2 = 1;
            }
            const chr3 = input.charCodeAt(i++);
            const enc1 = chr1 >> 2;
            const enc2 = ((chr1 & 0x03) << 4) | (chr2 >> 4);
            let enc3 = ((chr2 & 0x0F) << 2) | (chr3 >> 6);
            let enc4 = chr3 & 0x3F;
            if (flag1 === 1) {
                enc3 = enc4 = 64;
            }
            else {
                if (flag2 === 1) {
                    enc4 = 64;
                }
            }
            if (skipPadding) {
                if (enc3 === 64) {
                    output += `${template.charAt(enc1)}${template.charAt(enc2)}`;
                }
                else {
                    if (enc4 === 64) {
                        output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;
                    }
                    else {
                        output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
                    }
                }
            }
            else {
                output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
            }
        }
        return output;
    }
    function fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {
        const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;
        function indexOf(toSearch) {
            for (let i = 0; i < 64; i++) {
                if (template.charAt(i) === toSearch)
                    return i;
            }
            return 64;
        }
        function test(incoming) {
            return ((incoming === 64) ? 0x00 : incoming);
        }
        let i = 0;
        let output = "";
        while (i < input.length) {
            const enc1 = indexOf(input.charAt(i++));
            const enc2 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
            const enc3 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
            const enc4 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
            const chr1 = (test(enc1) << 2) | (test(enc2) >> 4);
            const chr2 = ((test(enc2) & 0x0F) << 4) | (test(enc3) >> 2);
            const chr3 = ((test(enc3) & 0x03) << 6) | test(enc4);
            output += String.fromCharCode(chr1);
            if (enc3 !== 64) {
                output += String.fromCharCode(chr2);
            }
            if (enc4 !== 64) {
                output += String.fromCharCode(chr3);
            }
        }
        if (cutTailZeros) {
            const outputLength = output.length;
            let nonZeroStart = (-1);
            for (let i = (outputLength - 1); i >= 0; i--) {
                if (output.charCodeAt(i) !== 0) {
                    nonZeroStart = i;
                    break;
                }
            }
            if (nonZeroStart !== (-1)) {
                output = output.slice(0, nonZeroStart + 1);
            }
            else {
                output = "";
            }
        }
        return output;
    }
    function arrayBufferToString(buffer) {
        let resultString = "";
        const view = new Uint8Array(buffer);
        for (const element of view) {
            resultString += String.fromCharCode(element);
        }
        return resultString;
    }
    function stringToArrayBuffer(str) {
        const stringLength = str.length;
        const resultBuffer = new ArrayBuffer(stringLength);
        const resultView = new Uint8Array(resultBuffer);
        for (let i = 0; i < stringLength; i++) {
            resultView[i] = str.charCodeAt(i);
        }
        return resultBuffer;
    }
    const log2 = Math.log(2);
    function nearestPowerOf2(length) {
        const base = (Math.log(length) / log2);
        const floor = Math.floor(base);
        const round = Math.round(base);
        return ((floor === round) ? floor : round);
    }
    function clearProps(object, propsArray) {
        for (const prop of propsArray) {
            delete object[prop];
        }
    }

    /*!
     * Copyright (c) 2014, GMO GlobalSign
     * Copyright (c) 2015-2022, Peculiar Ventures
     * All rights reserved.
     * 
     * Author 2014-2019, Yury Strozhevsky
     * 
     * Redistribution and use in source and binary forms, with or without modification,
     * are permitted provided that the following conditions are met:
     * 
     * * Redistributions of source code must retain the above copyright notice, this
     *   list of conditions and the following disclaimer.
     * 
     * * Redistributions in binary form must reproduce the above copyright notice, this
     *   list of conditions and the following disclaimer in the documentation and/or
     *   other materials provided with the distribution.
     * 
     * * Neither the name of the copyright holder nor the names of its
     *   contributors may be used to endorse or promote products derived from
     *   this software without specific prior written permission.
     * 
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     * 
     */

    function assertBigInt() {
        if (typeof BigInt === "undefined") {
            throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
        }
    }
    function concat(buffers) {
        let outputLength = 0;
        let prevLength = 0;
        for (let i = 0; i < buffers.length; i++) {
            const buffer = buffers[i];
            outputLength += buffer.byteLength;
        }
        const retView = new Uint8Array(outputLength);
        for (let i = 0; i < buffers.length; i++) {
            const buffer = buffers[i];
            retView.set(new Uint8Array(buffer), prevLength);
            prevLength += buffer.byteLength;
        }
        return retView.buffer;
    }
    function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
        if (!(inputBuffer instanceof Uint8Array)) {
            baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
            return false;
        }
        if (!inputBuffer.byteLength) {
            baseBlock.error = "Wrong parameter: inputBuffer has zero length";
            return false;
        }
        if (inputOffset < 0) {
            baseBlock.error = "Wrong parameter: inputOffset less than zero";
            return false;
        }
        if (inputLength < 0) {
            baseBlock.error = "Wrong parameter: inputLength less than zero";
            return false;
        }
        if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {
            baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
            return false;
        }
        return true;
    }

    class ViewWriter {
        constructor() {
            this.items = [];
        }
        write(buf) {
            this.items.push(buf);
        }
        final() {
            return concat(this.items);
        }
    }

    const powers2 = [new Uint8Array([1])];
    const digitsString = "0123456789";
    const NAME = "name";
    const VALUE_HEX_VIEW = "valueHexView";
    const IS_HEX_ONLY = "isHexOnly";
    const ID_BLOCK = "idBlock";
    const TAG_CLASS = "tagClass";
    const TAG_NUMBER = "tagNumber";
    const IS_CONSTRUCTED = "isConstructed";
    const FROM_BER = "fromBER";
    const TO_BER = "toBER";
    const LOCAL = "local";
    const EMPTY_STRING$1 = "";
    const EMPTY_BUFFER$1 = new ArrayBuffer(0);
    const EMPTY_VIEW = new Uint8Array(0);
    const END_OF_CONTENT_NAME = "EndOfContent";
    const OCTET_STRING_NAME = "OCTET STRING";
    const BIT_STRING_NAME = "BIT STRING";

    function HexBlock(BaseClass) {
        var _a;
        return _a = class Some extends BaseClass {
                constructor(...args) {
                    var _a;
                    super(...args);
                    const params = args[0] || {};
                    this.isHexOnly = (_a = params.isHexOnly) !== null && _a !== void 0 ? _a : false;
                    this.valueHexView = params.valueHex ? BufferSourceConverter_1.toUint8Array(params.valueHex) : EMPTY_VIEW;
                }
                get valueHex() {
                    return this.valueHexView.slice().buffer;
                }
                set valueHex(value) {
                    this.valueHexView = new Uint8Array(value);
                }
                fromBER(inputBuffer, inputOffset, inputLength) {
                    const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
                    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
                        return -1;
                    }
                    const endLength = inputOffset + inputLength;
                    this.valueHexView = view.subarray(inputOffset, endLength);
                    if (!this.valueHexView.length) {
                        this.warnings.push("Zero buffer length");
                        return inputOffset;
                    }
                    this.blockLength = inputLength;
                    return endLength;
                }
                toBER(sizeOnly = false) {
                    if (!this.isHexOnly) {
                        this.error = "Flag 'isHexOnly' is not set, abort";
                        return EMPTY_BUFFER$1;
                    }
                    if (sizeOnly) {
                        return new ArrayBuffer(this.valueHexView.byteLength);
                    }
                    return (this.valueHexView.byteLength === this.valueHexView.buffer.byteLength)
                        ? this.valueHexView.buffer
                        : this.valueHexView.slice().buffer;
                }
                toJSON() {
                    return {
                        ...super.toJSON(),
                        isHexOnly: this.isHexOnly,
                        valueHex: Convert_1.ToHex(this.valueHexView),
                    };
                }
            },
            _a.NAME = "hexBlock",
            _a;
    }

    class LocalBaseBlock {
        constructor({ blockLength = 0, error = EMPTY_STRING$1, warnings = [], valueBeforeDecode = EMPTY_VIEW, } = {}) {
            this.blockLength = blockLength;
            this.error = error;
            this.warnings = warnings;
            this.valueBeforeDecodeView = BufferSourceConverter_1.toUint8Array(valueBeforeDecode);
        }
        static blockName() {
            return this.NAME;
        }
        get valueBeforeDecode() {
            return this.valueBeforeDecodeView.slice().buffer;
        }
        set valueBeforeDecode(value) {
            this.valueBeforeDecodeView = new Uint8Array(value);
        }
        toJSON() {
            return {
                blockName: this.constructor.NAME,
                blockLength: this.blockLength,
                error: this.error,
                warnings: this.warnings,
                valueBeforeDecode: Convert_1.ToHex(this.valueBeforeDecodeView),
            };
        }
    }
    LocalBaseBlock.NAME = "baseBlock";

    class ValueBlock extends LocalBaseBlock {
        fromBER(inputBuffer, inputOffset, inputLength) {
            throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
        }
        toBER(sizeOnly, writer) {
            throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
        }
    }
    ValueBlock.NAME = "valueBlock";

    class LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {
        constructor({ idBlock = {}, } = {}) {
            var _a, _b, _c, _d;
            super();
            if (idBlock) {
                this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;
                this.valueHexView = idBlock.valueHex ? BufferSourceConverter_1.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
                this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
                this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
                this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
            }
            else {
                this.tagClass = -1;
                this.tagNumber = -1;
                this.isConstructed = false;
            }
        }
        toBER(sizeOnly = false) {
            let firstOctet = 0;
            switch (this.tagClass) {
                case 1:
                    firstOctet |= 0x00;
                    break;
                case 2:
                    firstOctet |= 0x40;
                    break;
                case 3:
                    firstOctet |= 0x80;
                    break;
                case 4:
                    firstOctet |= 0xC0;
                    break;
                default:
                    this.error = "Unknown tag class";
                    return EMPTY_BUFFER$1;
            }
            if (this.isConstructed)
                firstOctet |= 0x20;
            if (this.tagNumber < 31 && !this.isHexOnly) {
                const retView = new Uint8Array(1);
                if (!sizeOnly) {
                    let number = this.tagNumber;
                    number &= 0x1F;
                    firstOctet |= number;
                    retView[0] = firstOctet;
                }
                return retView.buffer;
            }
            if (!this.isHexOnly) {
                const encodedBuf = utilToBase(this.tagNumber, 7);
                const encodedView = new Uint8Array(encodedBuf);
                const size = encodedBuf.byteLength;
                const retView = new Uint8Array(size + 1);
                retView[0] = (firstOctet | 0x1F);
                if (!sizeOnly) {
                    for (let i = 0; i < (size - 1); i++)
                        retView[i + 1] = encodedView[i] | 0x80;
                    retView[size] = encodedView[size - 1];
                }
                return retView.buffer;
            }
            const retView = new Uint8Array(this.valueHexView.byteLength + 1);
            retView[0] = (firstOctet | 0x1F);
            if (!sizeOnly) {
                const curView = this.valueHexView;
                for (let i = 0; i < (curView.length - 1); i++)
                    retView[i + 1] = curView[i] | 0x80;
                retView[this.valueHexView.byteLength] = curView[curView.length - 1];
            }
            return retView.buffer;
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            const inputView = BufferSourceConverter_1.toUint8Array(inputBuffer);
            if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
                return -1;
            }
            const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
            if (intBuffer.length === 0) {
                this.error = "Zero buffer length";
                return -1;
            }
            const tagClassMask = intBuffer[0] & 0xC0;
            switch (tagClassMask) {
                case 0x00:
                    this.tagClass = (1);
                    break;
                case 0x40:
                    this.tagClass = (2);
                    break;
                case 0x80:
                    this.tagClass = (3);
                    break;
                case 0xC0:
                    this.tagClass = (4);
                    break;
                default:
                    this.error = "Unknown tag class";
                    return -1;
            }
            this.isConstructed = (intBuffer[0] & 0x20) === 0x20;
            this.isHexOnly = false;
            const tagNumberMask = intBuffer[0] & 0x1F;
            if (tagNumberMask !== 0x1F) {
                this.tagNumber = (tagNumberMask);
                this.blockLength = 1;
            }
            else {
                let count = 1;
                let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
                let tagNumberBufferMaxLength = 255;
                while (intBuffer[count] & 0x80) {
                    intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
                    count++;
                    if (count >= intBuffer.length) {
                        this.error = "End of input reached before message was fully decoded";
                        return -1;
                    }
                    if (count === tagNumberBufferMaxLength) {
                        tagNumberBufferMaxLength += 255;
                        const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);
                        for (let i = 0; i < intTagNumberBuffer.length; i++)
                            tempBufferView[i] = intTagNumberBuffer[i];
                        intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
                    }
                }
                this.blockLength = (count + 1);
                intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
                const tempBufferView = new Uint8Array(count);
                for (let i = 0; i < count; i++)
                    tempBufferView[i] = intTagNumberBuffer[i];
                intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
                intTagNumberBuffer.set(tempBufferView);
                if (this.blockLength <= 9)
                    this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
                else {
                    this.isHexOnly = true;
                    this.warnings.push("Tag too long, represented as hex-coded");
                }
            }
            if (((this.tagClass === 1)) &&
                (this.isConstructed)) {
                switch (this.tagNumber) {
                    case 1:
                    case 2:
                    case 5:
                    case 6:
                    case 9:
                    case 13:
                    case 14:
                    case 23:
                    case 24:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                        this.error = "Constructed encoding used for primitive type";
                        return -1;
                }
            }
            return (inputOffset + this.blockLength);
        }
        toJSON() {
            return {
                ...super.toJSON(),
                tagClass: this.tagClass,
                tagNumber: this.tagNumber,
                isConstructed: this.isConstructed,
            };
        }
    }
    LocalIdentificationBlock.NAME = "identificationBlock";

    class LocalLengthBlock extends LocalBaseBlock {
        constructor({ lenBlock = {}, } = {}) {
            var _a, _b, _c;
            super();
            this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;
            this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
            this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            const view = BufferSourceConverter_1.toUint8Array(inputBuffer);
            if (!checkBufferParams(this, view, inputOffset, inputLength)) {
                return -1;
            }
            const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
            if (intBuffer.length === 0) {
                this.error = "Zero buffer length";
                return -1;
            }
            if (intBuffer[0] === 0xFF) {
                this.error = "Length block 0xFF is reserved by standard";
                return -1;
            }
            this.isIndefiniteForm = intBuffer[0] === 0x80;
            if (this.isIndefiniteForm) {
                this.blockLength = 1;
                return (inputOffset + this.blockLength);
            }
            this.longFormUsed = !!(intBuffer[0] & 0x80);
            if (this.longFormUsed === false) {
                this.length = (intBuffer[0]);
                this.blockLength = 1;
                return (inputOffset + this.blockLength);
            }
            const count = intBuffer[0] & 0x7F;
            if (count > 8) {
                this.error = "Too big integer";
                return -1;
            }
            if ((count + 1) > intBuffer.length) {
                this.error = "End of input reached before message was fully decoded";
                return -1;
            }
            const lenOffset = inputOffset + 1;
            const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
            if (lengthBufferView[count - 1] === 0x00)
                this.warnings.push("Needlessly long encoded length");
            this.length = utilFromBase(lengthBufferView, 8);
            if (this.longFormUsed && (this.length <= 127))
                this.warnings.push("Unnecessary usage of long length form");
            this.blockLength = count + 1;
            return (inputOffset + this.blockLength);
        }
        toBER(sizeOnly = false) {
            let retBuf;
            let retView;
            if (this.length > 127)
                this.longFormUsed = true;
            if (this.isIndefiniteForm) {
                retBuf = new ArrayBuffer(1);
                if (sizeOnly === false) {
                    retView = new Uint8Array(retBuf);
                    retView[0] = 0x80;
                }
                return retBuf;
            }
            if (this.longFormUsed) {
                const encodedBuf = utilToBase(this.length, 8);
                if (encodedBuf.byteLength > 127) {
                    this.error = "Too big length";
                    return (EMPTY_BUFFER$1);
                }
                retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
                if (sizeOnly)
                    return retBuf;
                const encodedView = new Uint8Array(encodedBuf);
                retView = new Uint8Array(retBuf);
                retView[0] = encodedBuf.byteLength | 0x80;
                for (let i = 0; i < encodedBuf.byteLength; i++)
                    retView[i + 1] = encodedView[i];
                return retBuf;
            }
            retBuf = new ArrayBuffer(1);
            if (sizeOnly === false) {
                retView = new Uint8Array(retBuf);
                retView[0] = this.length;
            }
            return retBuf;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                isIndefiniteForm: this.isIndefiniteForm,
                longFormUsed: this.longFormUsed,
                length: this.length,
            };
        }
    }
    LocalLengthBlock.NAME = "lengthBlock";

    const typeStore = {};

    class BaseBlock extends LocalBaseBlock {
        constructor({ name = EMPTY_STRING$1, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
            super(parameters);
            this.name = name;
            this.optional = optional;
            if (primitiveSchema) {
                this.primitiveSchema = primitiveSchema;
            }
            this.idBlock = new LocalIdentificationBlock(parameters);
            this.lenBlock = new LocalLengthBlock(parameters);
            this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);
            if (resultOffset === -1) {
                this.error = this.valueBlock.error;
                return resultOffset;
            }
            if (!this.idBlock.error.length)
                this.blockLength += this.idBlock.blockLength;
            if (!this.lenBlock.error.length)
                this.blockLength += this.lenBlock.blockLength;
            if (!this.valueBlock.error.length)
                this.blockLength += this.valueBlock.blockLength;
            return resultOffset;
        }
        toBER(sizeOnly, writer) {
            const _writer = writer || new ViewWriter();
            if (!writer) {
                prepareIndefiniteForm(this);
            }
            const idBlockBuf = this.idBlock.toBER(sizeOnly);
            _writer.write(idBlockBuf);
            if (this.lenBlock.isIndefiniteForm) {
                _writer.write(new Uint8Array([0x80]).buffer);
                this.valueBlock.toBER(sizeOnly, _writer);
                _writer.write(new ArrayBuffer(2));
            }
            else {
                const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
                this.lenBlock.length = valueBlockBuf.byteLength;
                const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
                _writer.write(lenBlockBuf);
                _writer.write(valueBlockBuf);
            }
            if (!writer) {
                return _writer.final();
            }
            return EMPTY_BUFFER$1;
        }
        toJSON() {
            const object = {
                ...super.toJSON(),
                idBlock: this.idBlock.toJSON(),
                lenBlock: this.lenBlock.toJSON(),
                valueBlock: this.valueBlock.toJSON(),
                name: this.name,
                optional: this.optional,
            };
            if (this.primitiveSchema)
                object.primitiveSchema = this.primitiveSchema.toJSON();
            return object;
        }
        toString(encoding = "ascii") {
            if (encoding === "ascii") {
                return this.onAsciiEncoding();
            }
            return Convert_1.ToHex(this.toBER());
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME} : ${Convert_1.ToHex(this.valueBlock.valueBeforeDecodeView)}`;
        }
        isEqual(other) {
            if (this === other) {
                return true;
            }
            if (!(other instanceof this.constructor)) {
                return false;
            }
            const thisRaw = this.toBER();
            const otherRaw = other.toBER();
            return isEqualBuffer(thisRaw, otherRaw);
        }
    }
    BaseBlock.NAME = "BaseBlock";
    function prepareIndefiniteForm(baseBlock) {
        if (baseBlock instanceof typeStore.Constructed) {
            for (const value of baseBlock.valueBlock.value) {
                if (prepareIndefiniteForm(value)) {
                    baseBlock.lenBlock.isIndefiniteForm = true;
                }
            }
        }
        return !!baseBlock.lenBlock.isIndefiniteForm;
    }

    class BaseStringBlock extends BaseBlock {
        constructor({ value = EMPTY_STRING$1, ...parameters } = {}, stringValueBlockType) {
            super(parameters, stringValueBlockType);
            if (value) {
                this.fromString(value);
            }
        }
        getValue() {
            return this.valueBlock.value;
        }
        setValue(value) {
            this.valueBlock.value = value;
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);
            if (resultOffset === -1) {
                this.error = this.valueBlock.error;
                return resultOffset;
            }
            this.fromBuffer(this.valueBlock.valueHexView);
            if (!this.idBlock.error.length)
                this.blockLength += this.idBlock.blockLength;
            if (!this.lenBlock.error.length)
                this.blockLength += this.lenBlock.blockLength;
            if (!this.valueBlock.error.length)
                this.blockLength += this.valueBlock.blockLength;
            return resultOffset;
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
        }
    }
    BaseStringBlock.NAME = "BaseStringBlock";

    class LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {
        constructor({ isHexOnly = true, ...parameters } = {}) {
            super(parameters);
            this.isHexOnly = isHexOnly;
        }
    }
    LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";

    var _a$w;
    class Primitive extends BaseBlock {
        constructor(parameters = {}) {
            super(parameters, LocalPrimitiveValueBlock);
            this.idBlock.isConstructed = false;
        }
    }
    _a$w = Primitive;
    (() => {
        typeStore.Primitive = _a$w;
    })();
    Primitive.NAME = "PRIMITIVE";

    function localChangeType(inputObject, newType) {
        if (inputObject instanceof newType) {
            return inputObject;
        }
        const newObject = new newType();
        newObject.idBlock = inputObject.idBlock;
        newObject.lenBlock = inputObject.lenBlock;
        newObject.warnings = inputObject.warnings;
        newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
        return newObject;
    }
    function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
        const incomingOffset = inputOffset;
        let returnObject = new BaseBlock({}, ValueBlock);
        const baseBlock = new LocalBaseBlock();
        if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
            returnObject.error = baseBlock.error;
            return {
                offset: -1,
                result: returnObject
            };
        }
        const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
        if (!intBuffer.length) {
            returnObject.error = "Zero buffer length";
            return {
                offset: -1,
                result: returnObject
            };
        }
        let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
        if (returnObject.idBlock.warnings.length) {
            returnObject.warnings.concat(returnObject.idBlock.warnings);
        }
        if (resultOffset === -1) {
            returnObject.error = returnObject.idBlock.error;
            return {
                offset: -1,
                result: returnObject
            };
        }
        inputOffset = resultOffset;
        inputLength -= returnObject.idBlock.blockLength;
        resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
        if (returnObject.lenBlock.warnings.length) {
            returnObject.warnings.concat(returnObject.lenBlock.warnings);
        }
        if (resultOffset === -1) {
            returnObject.error = returnObject.lenBlock.error;
            return {
                offset: -1,
                result: returnObject
            };
        }
        inputOffset = resultOffset;
        inputLength -= returnObject.lenBlock.blockLength;
        if (!returnObject.idBlock.isConstructed &&
            returnObject.lenBlock.isIndefiniteForm) {
            returnObject.error = "Indefinite length form used for primitive encoding form";
            return {
                offset: -1,
                result: returnObject
            };
        }
        let newASN1Type = BaseBlock;
        switch (returnObject.idBlock.tagClass) {
            case 1:
                if ((returnObject.idBlock.tagNumber >= 37) &&
                    (returnObject.idBlock.isHexOnly === false)) {
                    returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
                    return {
                        offset: -1,
                        result: returnObject
                    };
                }
                switch (returnObject.idBlock.tagNumber) {
                    case 0:
                        if ((returnObject.idBlock.isConstructed) &&
                            (returnObject.lenBlock.length > 0)) {
                            returnObject.error = "Type [UNIVERSAL 0] is reserved";
                            return {
                                offset: -1,
                                result: returnObject
                            };
                        }
                        newASN1Type = typeStore.EndOfContent;
                        break;
                    case 1:
                        newASN1Type = typeStore.Boolean;
                        break;
                    case 2:
                        newASN1Type = typeStore.Integer;
                        break;
                    case 3:
                        newASN1Type = typeStore.BitString;
                        break;
                    case 4:
                        newASN1Type = typeStore.OctetString;
                        break;
                    case 5:
                        newASN1Type = typeStore.Null;
                        break;
                    case 6:
                        newASN1Type = typeStore.ObjectIdentifier;
                        break;
                    case 10:
                        newASN1Type = typeStore.Enumerated;
                        break;
                    case 12:
                        newASN1Type = typeStore.Utf8String;
                        break;
                    case 13:
                        newASN1Type = typeStore.RelativeObjectIdentifier;
                        break;
                    case 14:
                        newASN1Type = typeStore.TIME;
                        break;
                    case 15:
                        returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
                        return {
                            offset: -1,
                            result: returnObject
                        };
                    case 16:
                        newASN1Type = typeStore.Sequence;
                        break;
                    case 17:
                        newASN1Type = typeStore.Set;
                        break;
                    case 18:
                        newASN1Type = typeStore.NumericString;
                        break;
                    case 19:
                        newASN1Type = typeStore.PrintableString;
                        break;
                    case 20:
                        newASN1Type = typeStore.TeletexString;
                        break;
                    case 21:
                        newASN1Type = typeStore.VideotexString;
                        break;
                    case 22:
                        newASN1Type = typeStore.IA5String;
                        break;
                    case 23:
                        newASN1Type = typeStore.UTCTime;
                        break;
                    case 24:
                        newASN1Type = typeStore.GeneralizedTime;
                        break;
                    case 25:
                        newASN1Type = typeStore.GraphicString;
                        break;
                    case 26:
                        newASN1Type = typeStore.VisibleString;
                        break;
                    case 27:
                        newASN1Type = typeStore.GeneralString;
                        break;
                    case 28:
                        newASN1Type = typeStore.UniversalString;
                        break;
                    case 29:
                        newASN1Type = typeStore.CharacterString;
                        break;
                    case 30:
                        newASN1Type = typeStore.BmpString;
                        break;
                    case 31:
                        newASN1Type = typeStore.DATE;
                        break;
                    case 32:
                        newASN1Type = typeStore.TimeOfDay;
                        break;
                    case 33:
                        newASN1Type = typeStore.DateTime;
                        break;
                    case 34:
                        newASN1Type = typeStore.Duration;
                        break;
                    default: {
                        const newObject = returnObject.idBlock.isConstructed
                            ? new typeStore.Constructed()
                            : new typeStore.Primitive();
                        newObject.idBlock = returnObject.idBlock;
                        newObject.lenBlock = returnObject.lenBlock;
                        newObject.warnings = returnObject.warnings;
                        returnObject = newObject;
                    }
                }
                break;
            case 2:
            case 3:
            case 4:
            default: {
                newASN1Type = returnObject.idBlock.isConstructed
                    ? typeStore.Constructed
                    : typeStore.Primitive;
            }
        }
        returnObject = localChangeType(returnObject, newASN1Type);
        resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
        returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
        return {
            offset: resultOffset,
            result: returnObject
        };
    }
    function fromBER(inputBuffer) {
        if (!inputBuffer.byteLength) {
            const result = new BaseBlock({}, ValueBlock);
            result.error = "Input buffer has zero length";
            return {
                offset: -1,
                result
            };
        }
        return localFromBER(BufferSourceConverter_1.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
    }

    function checkLen(indefiniteLength, length) {
        if (indefiniteLength) {
            return 1;
        }
        return length;
    }
    class LocalConstructedValueBlock extends ValueBlock {
        constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
            super(parameters);
            this.value = value;
            this.isIndefiniteForm = isIndefiniteForm;
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            const view = BufferSourceConverter_1.toUint8Array(inputBuffer);
            if (!checkBufferParams(this, view, inputOffset, inputLength)) {
                return -1;
            }
            this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
            if (this.valueBeforeDecodeView.length === 0) {
                this.warnings.push("Zero buffer length");
                return inputOffset;
            }
            let currentOffset = inputOffset;
            while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
                const returnObject = localFromBER(view, currentOffset, inputLength);
                if (returnObject.offset === -1) {
                    this.error = returnObject.result.error;
                    this.warnings.concat(returnObject.result.warnings);
                    return -1;
                }
                currentOffset = returnObject.offset;
                this.blockLength += returnObject.result.blockLength;
                inputLength -= returnObject.result.blockLength;
                this.value.push(returnObject.result);
                if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
                    break;
                }
            }
            if (this.isIndefiniteForm) {
                if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
                    this.value.pop();
                }
                else {
                    this.warnings.push("No EndOfContent block encoded");
                }
            }
            return currentOffset;
        }
        toBER(sizeOnly, writer) {
            const _writer = writer || new ViewWriter();
            for (let i = 0; i < this.value.length; i++) {
                this.value[i].toBER(sizeOnly, _writer);
            }
            if (!writer) {
                return _writer.final();
            }
            return EMPTY_BUFFER$1;
        }
        toJSON() {
            const object = {
                ...super.toJSON(),
                isIndefiniteForm: this.isIndefiniteForm,
                value: [],
            };
            for (const value of this.value) {
                object.value.push(value.toJSON());
            }
            return object;
        }
    }
    LocalConstructedValueBlock.NAME = "ConstructedValueBlock";

    var _a$v;
    class Constructed extends BaseBlock {
        constructor(parameters = {}) {
            super(parameters, LocalConstructedValueBlock);
            this.idBlock.isConstructed = true;
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
            const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);
            if (resultOffset === -1) {
                this.error = this.valueBlock.error;
                return resultOffset;
            }
            if (!this.idBlock.error.length)
                this.blockLength += this.idBlock.blockLength;
            if (!this.lenBlock.error.length)
                this.blockLength += this.lenBlock.blockLength;
            if (!this.valueBlock.error.length)
                this.blockLength += this.valueBlock.blockLength;
            return resultOffset;
        }
        onAsciiEncoding() {
            const values = [];
            for (const value of this.valueBlock.value) {
                values.push(value.toString("ascii").split("\n").map(o => `  ${o}`).join("\n"));
            }
            const blockName = this.idBlock.tagClass === 3
                ? `[${this.idBlock.tagNumber}]`
                : this.constructor.NAME;
            return values.length
                ? `${blockName} :\n${values.join("\n")}`
                : `${blockName} :`;
        }
    }
    _a$v = Constructed;
    (() => {
        typeStore.Constructed = _a$v;
    })();
    Constructed.NAME = "CONSTRUCTED";

    class LocalEndOfContentValueBlock extends ValueBlock {
        fromBER(inputBuffer, inputOffset, inputLength) {
            return inputOffset;
        }
        toBER(sizeOnly) {
            return EMPTY_BUFFER$1;
        }
    }
    LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";

    var _a$u;
    class EndOfContent extends BaseBlock {
        constructor(parameters = {}) {
            super(parameters, LocalEndOfContentValueBlock);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 0;
        }
    }
    _a$u = EndOfContent;
    (() => {
        typeStore.EndOfContent = _a$u;
    })();
    EndOfContent.NAME = END_OF_CONTENT_NAME;

    var _a$t;
    class Null extends BaseBlock {
        constructor(parameters = {}) {
            super(parameters, ValueBlock);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 5;
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            if (this.lenBlock.length > 0)
                this.warnings.push("Non-zero length of value block for Null type");
            if (!this.idBlock.error.length)
                this.blockLength += this.idBlock.blockLength;
            if (!this.lenBlock.error.length)
                this.blockLength += this.lenBlock.blockLength;
            this.blockLength += inputLength;
            if ((inputOffset + inputLength) > inputBuffer.byteLength) {
                this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
                return -1;
            }
            return (inputOffset + inputLength);
        }
        toBER(sizeOnly, writer) {
            const retBuf = new ArrayBuffer(2);
            if (!sizeOnly) {
                const retView = new Uint8Array(retBuf);
                retView[0] = 0x05;
                retView[1] = 0x00;
            }
            if (writer) {
                writer.write(retBuf);
            }
            return retBuf;
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME}`;
        }
    }
    _a$t = Null;
    (() => {
        typeStore.Null = _a$t;
    })();
    Null.NAME = "NULL";

    class LocalBooleanValueBlock extends HexBlock(ValueBlock) {
        constructor({ value, ...parameters } = {}) {
            super(parameters);
            if (parameters.valueHex) {
                this.valueHexView = BufferSourceConverter_1.toUint8Array(parameters.valueHex);
            }
            else {
                this.valueHexView = new Uint8Array(1);
            }
            if (value) {
                this.value = value;
            }
        }
        get value() {
            for (const octet of this.valueHexView) {
                if (octet > 0) {
                    return true;
                }
            }
            return false;
        }
        set value(value) {
            this.valueHexView[0] = value ? 0xFF : 0x00;
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            const inputView = BufferSourceConverter_1.toUint8Array(inputBuffer);
            if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
                return -1;
            }
            this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
            if (inputLength > 1)
                this.warnings.push("Boolean value encoded in more then 1 octet");
            this.isHexOnly = true;
            utilDecodeTC.call(this);
            this.blockLength = inputLength;
            return (inputOffset + inputLength);
        }
        toBER() {
            return this.valueHexView.slice();
        }
        toJSON() {
            return {
                ...super.toJSON(),
                value: this.value,
            };
        }
    }
    LocalBooleanValueBlock.NAME = "BooleanValueBlock";

    var _a$s;
    class Boolean$1 extends BaseBlock {
        constructor(parameters = {}) {
            super(parameters, LocalBooleanValueBlock);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 1;
        }
        getValue() {
            return this.valueBlock.value;
        }
        setValue(value) {
            this.valueBlock.value = value;
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME} : ${this.getValue}`;
        }
    }
    _a$s = Boolean$1;
    (() => {
        typeStore.Boolean = _a$s;
    })();
    Boolean$1.NAME = "BOOLEAN";

    class LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
        constructor({ isConstructed = false, ...parameters } = {}) {
            super(parameters);
            this.isConstructed = isConstructed;
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            let resultOffset = 0;
            if (this.isConstructed) {
                this.isHexOnly = false;
                resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
                if (resultOffset === -1)
                    return resultOffset;
                for (let i = 0; i < this.value.length; i++) {
                    const currentBlockName = this.value[i].constructor.NAME;
                    if (currentBlockName === END_OF_CONTENT_NAME) {
                        if (this.isIndefiniteForm)
                            break;
                        else {
                            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
                            return -1;
                        }
                    }
                    if (currentBlockName !== OCTET_STRING_NAME) {
                        this.error = "OCTET STRING may consists of OCTET STRINGs only";
                        return -1;
                    }
                }
            }
            else {
                this.isHexOnly = true;
                resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
                this.blockLength = inputLength;
            }
            return resultOffset;
        }
        toBER(sizeOnly, writer) {
            if (this.isConstructed)
                return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
            return sizeOnly
                ? new ArrayBuffer(this.valueHexView.byteLength)
                : this.valueHexView.slice().buffer;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                isConstructed: this.isConstructed,
            };
        }
    }
    LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";

    var _a$r;
    class OctetString extends BaseBlock {
        constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
            var _b, _c;
            (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));
            super({
                idBlock: {
                    isConstructed: parameters.isConstructed,
                    ...idBlock,
                },
                lenBlock: {
                    ...lenBlock,
                    isIndefiniteForm: !!parameters.isIndefiniteForm,
                },
                ...parameters,
            }, LocalOctetStringValueBlock);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 4;
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            this.valueBlock.isConstructed = this.idBlock.isConstructed;
            this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
            if (inputLength === 0) {
                if (this.idBlock.error.length === 0)
                    this.blockLength += this.idBlock.blockLength;
                if (this.lenBlock.error.length === 0)
                    this.blockLength += this.lenBlock.blockLength;
                return inputOffset;
            }
            if (!this.valueBlock.isConstructed) {
                const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
                const buf = view.subarray(inputOffset, inputOffset + inputLength);
                try {
                    if (buf.byteLength) {
                        const asn = localFromBER(buf, 0, buf.byteLength);
                        if (asn.offset !== -1 && asn.offset === inputLength) {
                            this.valueBlock.value = [asn.result];
                        }
                    }
                }
                catch (e) {
                }
            }
            return super.fromBER(inputBuffer, inputOffset, inputLength);
        }
        onAsciiEncoding() {
            if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {
                return Constructed.prototype.onAsciiEncoding.call(this);
            }
            return `${this.constructor.NAME} : ${Convert_1.ToHex(this.valueBlock.valueHexView)}`;
        }
        getValue() {
            if (!this.idBlock.isConstructed) {
                return this.valueBlock.valueHexView.slice().buffer;
            }
            const array = [];
            for (const content of this.valueBlock.value) {
                if (content instanceof OctetString) {
                    array.push(content.valueBlock.valueHexView);
                }
            }
            return BufferSourceConverter_1.concat(array);
        }
    }
    _a$r = OctetString;
    (() => {
        typeStore.OctetString = _a$r;
    })();
    OctetString.NAME = OCTET_STRING_NAME;

    class LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
        constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
            super(parameters);
            this.unusedBits = unusedBits;
            this.isConstructed = isConstructed;
            this.blockLength = this.valueHexView.byteLength;
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            if (!inputLength) {
                return inputOffset;
            }
            let resultOffset = -1;
            if (this.isConstructed) {
                resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
                if (resultOffset === -1)
                    return resultOffset;
                for (const value of this.value) {
                    const currentBlockName = value.constructor.NAME;
                    if (currentBlockName === END_OF_CONTENT_NAME) {
                        if (this.isIndefiniteForm)
                            break;
                        else {
                            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
                            return -1;
                        }
                    }
                    if (currentBlockName !== BIT_STRING_NAME) {
                        this.error = "BIT STRING may consists of BIT STRINGs only";
                        return -1;
                    }
                    const valueBlock = value.valueBlock;
                    if ((this.unusedBits > 0) && (valueBlock.unusedBits > 0)) {
                        this.error = "Using of \"unused bits\" inside constructive BIT STRING allowed for least one only";
                        return -1;
                    }
                    this.unusedBits = valueBlock.unusedBits;
                }
                return resultOffset;
            }
            const inputView = BufferSourceConverter_1.toUint8Array(inputBuffer);
            if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
                return -1;
            }
            const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
            this.unusedBits = intBuffer[0];
            if (this.unusedBits > 7) {
                this.error = "Unused bits for BitString must be in range 0-7";
                return -1;
            }
            if (!this.unusedBits) {
                const buf = intBuffer.subarray(1);
                try {
                    if (buf.byteLength) {
                        const asn = localFromBER(buf, 0, buf.byteLength);
                        if (asn.offset !== -1 && asn.offset === (inputLength - 1)) {
                            this.value = [asn.result];
                        }
                    }
                }
                catch (e) {
                }
            }
            this.valueHexView = intBuffer.subarray(1);
            this.blockLength = intBuffer.length;
            return (inputOffset + inputLength);
        }
        toBER(sizeOnly, writer) {
            if (this.isConstructed) {
                return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
            }
            if (sizeOnly) {
                return new ArrayBuffer(this.valueHexView.byteLength + 1);
            }
            if (!this.valueHexView.byteLength) {
                return EMPTY_BUFFER$1;
            }
            const retView = new Uint8Array(this.valueHexView.length + 1);
            retView[0] = this.unusedBits;
            retView.set(this.valueHexView, 1);
            return retView.buffer;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                unusedBits: this.unusedBits,
                isConstructed: this.isConstructed,
            };
        }
    }
    LocalBitStringValueBlock.NAME = "BitStringValueBlock";

    var _a$q;
    class BitString extends BaseBlock {
        constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
            var _b, _c;
            (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));
            super({
                idBlock: {
                    isConstructed: parameters.isConstructed,
                    ...idBlock,
                },
                lenBlock: {
                    ...lenBlock,
                    isIndefiniteForm: !!parameters.isIndefiniteForm,
                },
                ...parameters,
            }, LocalBitStringValueBlock);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 3;
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            this.valueBlock.isConstructed = this.idBlock.isConstructed;
            this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
            return super.fromBER(inputBuffer, inputOffset, inputLength);
        }
        onAsciiEncoding() {
            if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {
                return Constructed.prototype.onAsciiEncoding.call(this);
            }
            else {
                const bits = [];
                const valueHex = this.valueBlock.valueHexView;
                for (const byte of valueHex) {
                    bits.push(byte.toString(2).padStart(8, "0"));
                }
                const bitsStr = bits.join("");
                return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;
            }
        }
    }
    _a$q = BitString;
    (() => {
        typeStore.BitString = _a$q;
    })();
    BitString.NAME = BIT_STRING_NAME;

    var _a$p;
    function viewAdd(first, second) {
        const c = new Uint8Array([0]);
        const firstView = new Uint8Array(first);
        const secondView = new Uint8Array(second);
        let firstViewCopy = firstView.slice(0);
        const firstViewCopyLength = firstViewCopy.length - 1;
        const secondViewCopy = secondView.slice(0);
        const secondViewCopyLength = secondViewCopy.length - 1;
        let value = 0;
        const max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;
        let counter = 0;
        for (let i = max; i >= 0; i--, counter++) {
            switch (true) {
                case (counter < secondViewCopy.length):
                    value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
                    break;
                default:
                    value = firstViewCopy[firstViewCopyLength - counter] + c[0];
            }
            c[0] = value / 10;
            switch (true) {
                case (counter >= firstViewCopy.length):
                    firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
                    break;
                default:
                    firstViewCopy[firstViewCopyLength - counter] = value % 10;
            }
        }
        if (c[0] > 0)
            firstViewCopy = utilConcatView(c, firstViewCopy);
        return firstViewCopy;
    }
    function power2(n) {
        if (n >= powers2.length) {
            for (let p = powers2.length; p <= n; p++) {
                const c = new Uint8Array([0]);
                let digits = (powers2[p - 1]).slice(0);
                for (let i = (digits.length - 1); i >= 0; i--) {
                    const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
                    c[0] = newValue[0] / 10;
                    digits[i] = newValue[0] % 10;
                }
                if (c[0] > 0)
                    digits = utilConcatView(c, digits);
                powers2.push(digits);
            }
        }
        return powers2[n];
    }
    function viewSub(first, second) {
        let b = 0;
        const firstView = new Uint8Array(first);
        const secondView = new Uint8Array(second);
        const firstViewCopy = firstView.slice(0);
        const firstViewCopyLength = firstViewCopy.length - 1;
        const secondViewCopy = secondView.slice(0);
        const secondViewCopyLength = secondViewCopy.length - 1;
        let value;
        let counter = 0;
        for (let i = secondViewCopyLength; i >= 0; i--, counter++) {
            value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
            switch (true) {
                case (value < 0):
                    b = 1;
                    firstViewCopy[firstViewCopyLength - counter] = value + 10;
                    break;
                default:
                    b = 0;
                    firstViewCopy[firstViewCopyLength - counter] = value;
            }
        }
        if (b > 0) {
            for (let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++) {
                value = firstViewCopy[firstViewCopyLength - counter] - b;
                if (value < 0) {
                    b = 1;
                    firstViewCopy[firstViewCopyLength - counter] = value + 10;
                }
                else {
                    b = 0;
                    firstViewCopy[firstViewCopyLength - counter] = value;
                    break;
                }
            }
        }
        return firstViewCopy.slice();
    }
    class LocalIntegerValueBlock extends HexBlock(ValueBlock) {
        constructor({ value, ...parameters } = {}) {
            super(parameters);
            this._valueDec = 0;
            if (parameters.valueHex) {
                this.setValueHex();
            }
            if (value !== undefined) {
                this.valueDec = value;
            }
        }
        setValueHex() {
            if (this.valueHexView.length >= 4) {
                this.warnings.push("Too big Integer for decoding, hex only");
                this.isHexOnly = true;
                this._valueDec = 0;
            }
            else {
                this.isHexOnly = false;
                if (this.valueHexView.length > 0) {
                    this._valueDec = utilDecodeTC.call(this);
                }
            }
        }
        set valueDec(v) {
            this._valueDec = v;
            this.isHexOnly = false;
            this.valueHexView = new Uint8Array(utilEncodeTC(v));
        }
        get valueDec() {
            return this._valueDec;
        }
        fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
            const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
            if (offset === -1)
                return offset;
            const view = this.valueHexView;
            if ((view[0] === 0x00) && ((view[1] & 0x80) !== 0)) {
                this.valueHexView = view.subarray(1);
            }
            else {
                if (expectedLength !== 0) {
                    if (view.length < expectedLength) {
                        if ((expectedLength - view.length) > 1)
                            expectedLength = view.length + 1;
                        this.valueHexView = view.subarray(expectedLength - view.length);
                    }
                }
            }
            return offset;
        }
        toDER(sizeOnly = false) {
            const view = this.valueHexView;
            switch (true) {
                case ((view[0] & 0x80) !== 0):
                    {
                        const updatedView = new Uint8Array(this.valueHexView.length + 1);
                        updatedView[0] = 0x00;
                        updatedView.set(view, 1);
                        this.valueHexView = updatedView;
                    }
                    break;
                case ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):
                    {
                        this.valueHexView = this.valueHexView.subarray(1);
                    }
                    break;
            }
            return this.toBER(sizeOnly);
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
            if (resultOffset === -1) {
                return resultOffset;
            }
            this.setValueHex();
            return resultOffset;
        }
        toBER(sizeOnly) {
            return sizeOnly
                ? new ArrayBuffer(this.valueHexView.length)
                : this.valueHexView.slice().buffer;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                valueDec: this.valueDec,
            };
        }
        toString() {
            const firstBit = (this.valueHexView.length * 8) - 1;
            let digits = new Uint8Array((this.valueHexView.length * 8) / 3);
            let bitNumber = 0;
            let currentByte;
            const asn1View = this.valueHexView;
            let result = "";
            let flag = false;
            for (let byteNumber = (asn1View.byteLength - 1); byteNumber >= 0; byteNumber--) {
                currentByte = asn1View[byteNumber];
                for (let i = 0; i < 8; i++) {
                    if ((currentByte & 1) === 1) {
                        switch (bitNumber) {
                            case firstBit:
                                digits = viewSub(power2(bitNumber), digits);
                                result = "-";
                                break;
                            default:
                                digits = viewAdd(digits, power2(bitNumber));
                        }
                    }
                    bitNumber++;
                    currentByte >>= 1;
                }
            }
            for (let i = 0; i < digits.length; i++) {
                if (digits[i])
                    flag = true;
                if (flag)
                    result += digitsString.charAt(digits[i]);
            }
            if (flag === false)
                result += digitsString.charAt(0);
            return result;
        }
    }
    _a$p = LocalIntegerValueBlock;
    LocalIntegerValueBlock.NAME = "IntegerValueBlock";
    (() => {
        Object.defineProperty(_a$p.prototype, "valueHex", {
            set: function (v) {
                this.valueHexView = new Uint8Array(v);
                this.setValueHex();
            },
            get: function () {
                return this.valueHexView.slice().buffer;
            },
        });
    })();

    var _a$o;
    class Integer extends BaseBlock {
        constructor(parameters = {}) {
            super(parameters, LocalIntegerValueBlock);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 2;
        }
        toBigInt() {
            assertBigInt();
            return BigInt(this.valueBlock.toString());
        }
        static fromBigInt(value) {
            assertBigInt();
            const bigIntValue = BigInt(value);
            const writer = new ViewWriter();
            const hex = bigIntValue.toString(16).replace(/^-/, "");
            const view = new Uint8Array(Convert_1.FromHex(hex));
            if (bigIntValue < 0) {
                const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));
                first[0] |= 0x80;
                const firstInt = BigInt(`0x${Convert_1.ToHex(first)}`);
                const secondInt = firstInt + bigIntValue;
                const second = BufferSourceConverter_1.toUint8Array(Convert_1.FromHex(secondInt.toString(16)));
                second[0] |= 0x80;
                writer.write(second);
            }
            else {
                if (view[0] & 0x80) {
                    writer.write(new Uint8Array([0]));
                }
                writer.write(view);
            }
            const res = new Integer({
                valueHex: writer.final(),
            });
            return res;
        }
        convertToDER() {
            const integer = new Integer({ valueHex: this.valueBlock.valueHexView });
            integer.valueBlock.toDER();
            return integer;
        }
        convertFromDER() {
            return new Integer({
                valueHex: this.valueBlock.valueHexView[0] === 0
                    ? this.valueBlock.valueHexView.subarray(1)
                    : this.valueBlock.valueHexView,
            });
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
        }
    }
    _a$o = Integer;
    (() => {
        typeStore.Integer = _a$o;
    })();
    Integer.NAME = "INTEGER";

    var _a$n;
    class Enumerated extends Integer {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 10;
        }
    }
    _a$n = Enumerated;
    (() => {
        typeStore.Enumerated = _a$n;
    })();
    Enumerated.NAME = "ENUMERATED";

    class LocalSidValueBlock extends HexBlock(ValueBlock) {
        constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
            super(parameters);
            this.valueDec = valueDec;
            this.isFirstSid = isFirstSid;
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            if (!inputLength) {
                return inputOffset;
            }
            const inputView = BufferSourceConverter_1.toUint8Array(inputBuffer);
            if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
                return -1;
            }
            const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
            this.valueHexView = new Uint8Array(inputLength);
            for (let i = 0; i < inputLength; i++) {
                this.valueHexView[i] = intBuffer[i] & 0x7F;
                this.blockLength++;
                if ((intBuffer[i] & 0x80) === 0x00)
                    break;
            }
            const tempView = new Uint8Array(this.blockLength);
            for (let i = 0; i < this.blockLength; i++) {
                tempView[i] = this.valueHexView[i];
            }
            this.valueHexView = tempView;
            if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
                this.error = "End of input reached before message was fully decoded";
                return -1;
            }
            if (this.valueHexView[0] === 0x00)
                this.warnings.push("Needlessly long format of SID encoding");
            if (this.blockLength <= 8)
                this.valueDec = utilFromBase(this.valueHexView, 7);
            else {
                this.isHexOnly = true;
                this.warnings.push("Too big SID for decoding, hex only");
            }
            return (inputOffset + this.blockLength);
        }
        set valueBigInt(value) {
            assertBigInt();
            let bits = BigInt(value).toString(2);
            while (bits.length % 7) {
                bits = "0" + bits;
            }
            const bytes = new Uint8Array(bits.length / 7);
            for (let i = 0; i < bytes.length; i++) {
                bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);
            }
            this.fromBER(bytes.buffer, 0, bytes.length);
        }
        toBER(sizeOnly) {
            if (this.isHexOnly) {
                if (sizeOnly)
                    return (new ArrayBuffer(this.valueHexView.byteLength));
                const curView = this.valueHexView;
                const retView = new Uint8Array(this.blockLength);
                for (let i = 0; i < (this.blockLength - 1); i++)
                    retView[i] = curView[i] | 0x80;
                retView[this.blockLength - 1] = curView[this.blockLength - 1];
                return retView.buffer;
            }
            const encodedBuf = utilToBase(this.valueDec, 7);
            if (encodedBuf.byteLength === 0) {
                this.error = "Error during encoding SID value";
                return EMPTY_BUFFER$1;
            }
            const retView = new Uint8Array(encodedBuf.byteLength);
            if (!sizeOnly) {
                const encodedView = new Uint8Array(encodedBuf);
                const len = encodedBuf.byteLength - 1;
                for (let i = 0; i < len; i++)
                    retView[i] = encodedView[i] | 0x80;
                retView[len] = encodedView[len];
            }
            return retView;
        }
        toString() {
            let result = "";
            if (this.isHexOnly)
                result = Convert_1.ToHex(this.valueHexView);
            else {
                if (this.isFirstSid) {
                    let sidValue = this.valueDec;
                    if (this.valueDec <= 39)
                        result = "0.";
                    else {
                        if (this.valueDec <= 79) {
                            result = "1.";
                            sidValue -= 40;
                        }
                        else {
                            result = "2.";
                            sidValue -= 80;
                        }
                    }
                    result += sidValue.toString();
                }
                else
                    result = this.valueDec.toString();
            }
            return result;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                valueDec: this.valueDec,
                isFirstSid: this.isFirstSid,
            };
        }
    }
    LocalSidValueBlock.NAME = "sidBlock";

    class LocalObjectIdentifierValueBlock extends ValueBlock {
        constructor({ value = EMPTY_STRING$1, ...parameters } = {}) {
            super(parameters);
            this.value = [];
            if (value) {
                this.fromString(value);
            }
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            let resultOffset = inputOffset;
            while (inputLength > 0) {
                const sidBlock = new LocalSidValueBlock();
                resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
                if (resultOffset === -1) {
                    this.blockLength = 0;
                    this.error = sidBlock.error;
                    return resultOffset;
                }
                if (this.value.length === 0)
                    sidBlock.isFirstSid = true;
                this.blockLength += sidBlock.blockLength;
                inputLength -= sidBlock.blockLength;
                this.value.push(sidBlock);
            }
            return resultOffset;
        }
        toBER(sizeOnly) {
            const retBuffers = [];
            for (let i = 0; i < this.value.length; i++) {
                const valueBuf = this.value[i].toBER(sizeOnly);
                if (valueBuf.byteLength === 0) {
                    this.error = this.value[i].error;
                    return EMPTY_BUFFER$1;
                }
                retBuffers.push(valueBuf);
            }
            return concat(retBuffers);
        }
        fromString(string) {
            this.value = [];
            let pos1 = 0;
            let pos2 = 0;
            let sid = "";
            let flag = false;
            do {
                pos2 = string.indexOf(".", pos1);
                if (pos2 === -1)
                    sid = string.substring(pos1);
                else
                    sid = string.substring(pos1, pos2);
                pos1 = pos2 + 1;
                if (flag) {
                    const sidBlock = this.value[0];
                    let plus = 0;
                    switch (sidBlock.valueDec) {
                        case 0:
                            break;
                        case 1:
                            plus = 40;
                            break;
                        case 2:
                            plus = 80;
                            break;
                        default:
                            this.value = [];
                            return;
                    }
                    const parsedSID = parseInt(sid, 10);
                    if (isNaN(parsedSID))
                        return;
                    sidBlock.valueDec = parsedSID + plus;
                    flag = false;
                }
                else {
                    const sidBlock = new LocalSidValueBlock();
                    if (sid > Number.MAX_SAFE_INTEGER) {
                        assertBigInt();
                        const sidValue = BigInt(sid);
                        sidBlock.valueBigInt = sidValue;
                    }
                    else {
                        sidBlock.valueDec = parseInt(sid, 10);
                        if (isNaN(sidBlock.valueDec))
                            return;
                    }
                    if (!this.value.length) {
                        sidBlock.isFirstSid = true;
                        flag = true;
                    }
                    this.value.push(sidBlock);
                }
            } while (pos2 !== -1);
        }
        toString() {
            let result = "";
            let isHexOnly = false;
            for (let i = 0; i < this.value.length; i++) {
                isHexOnly = this.value[i].isHexOnly;
                let sidStr = this.value[i].toString();
                if (i !== 0)
                    result = `${result}.`;
                if (isHexOnly) {
                    sidStr = `{${sidStr}}`;
                    if (this.value[i].isFirstSid)
                        result = `2.{${sidStr} - 80}`;
                    else
                        result += sidStr;
                }
                else
                    result += sidStr;
            }
            return result;
        }
        toJSON() {
            const object = {
                ...super.toJSON(),
                value: this.toString(),
                sidArray: [],
            };
            for (let i = 0; i < this.value.length; i++) {
                object.sidArray.push(this.value[i].toJSON());
            }
            return object;
        }
    }
    LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";

    var _a$m;
    class ObjectIdentifier extends BaseBlock {
        constructor(parameters = {}) {
            super(parameters, LocalObjectIdentifierValueBlock);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 6;
        }
        getValue() {
            return this.valueBlock.toString();
        }
        setValue(value) {
            this.valueBlock.fromString(value);
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                value: this.getValue(),
            };
        }
    }
    _a$m = ObjectIdentifier;
    (() => {
        typeStore.ObjectIdentifier = _a$m;
    })();
    ObjectIdentifier.NAME = "OBJECT IDENTIFIER";

    class LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {
        constructor({ valueDec = 0, ...parameters } = {}) {
            super(parameters);
            this.valueDec = valueDec;
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            if (inputLength === 0)
                return inputOffset;
            const inputView = BufferSourceConverter_1.toUint8Array(inputBuffer);
            if (!checkBufferParams(this, inputView, inputOffset, inputLength))
                return -1;
            const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
            this.valueHexView = new Uint8Array(inputLength);
            for (let i = 0; i < inputLength; i++) {
                this.valueHexView[i] = intBuffer[i] & 0x7F;
                this.blockLength++;
                if ((intBuffer[i] & 0x80) === 0x00)
                    break;
            }
            const tempView = new Uint8Array(this.blockLength);
            for (let i = 0; i < this.blockLength; i++)
                tempView[i] = this.valueHexView[i];
            this.valueHexView = tempView;
            if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
                this.error = "End of input reached before message was fully decoded";
                return -1;
            }
            if (this.valueHexView[0] === 0x00)
                this.warnings.push("Needlessly long format of SID encoding");
            if (this.blockLength <= 8)
                this.valueDec = utilFromBase(this.valueHexView, 7);
            else {
                this.isHexOnly = true;
                this.warnings.push("Too big SID for decoding, hex only");
            }
            return (inputOffset + this.blockLength);
        }
        toBER(sizeOnly) {
            if (this.isHexOnly) {
                if (sizeOnly)
                    return (new ArrayBuffer(this.valueHexView.byteLength));
                const curView = this.valueHexView;
                const retView = new Uint8Array(this.blockLength);
                for (let i = 0; i < (this.blockLength - 1); i++)
                    retView[i] = curView[i] | 0x80;
                retView[this.blockLength - 1] = curView[this.blockLength - 1];
                return retView.buffer;
            }
            const encodedBuf = utilToBase(this.valueDec, 7);
            if (encodedBuf.byteLength === 0) {
                this.error = "Error during encoding SID value";
                return EMPTY_BUFFER$1;
            }
            const retView = new Uint8Array(encodedBuf.byteLength);
            if (!sizeOnly) {
                const encodedView = new Uint8Array(encodedBuf);
                const len = encodedBuf.byteLength - 1;
                for (let i = 0; i < len; i++)
                    retView[i] = encodedView[i] | 0x80;
                retView[len] = encodedView[len];
            }
            return retView.buffer;
        }
        toString() {
            let result = "";
            if (this.isHexOnly)
                result = Convert_1.ToHex(this.valueHexView);
            else {
                result = this.valueDec.toString();
            }
            return result;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                valueDec: this.valueDec,
            };
        }
    }
    LocalRelativeSidValueBlock.NAME = "relativeSidBlock";

    class LocalRelativeObjectIdentifierValueBlock extends ValueBlock {
        constructor({ value = EMPTY_STRING$1, ...parameters } = {}) {
            super(parameters);
            this.value = [];
            if (value) {
                this.fromString(value);
            }
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            let resultOffset = inputOffset;
            while (inputLength > 0) {
                const sidBlock = new LocalRelativeSidValueBlock();
                resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
                if (resultOffset === -1) {
                    this.blockLength = 0;
                    this.error = sidBlock.error;
                    return resultOffset;
                }
                this.blockLength += sidBlock.blockLength;
                inputLength -= sidBlock.blockLength;
                this.value.push(sidBlock);
            }
            return resultOffset;
        }
        toBER(sizeOnly, writer) {
            const retBuffers = [];
            for (let i = 0; i < this.value.length; i++) {
                const valueBuf = this.value[i].toBER(sizeOnly);
                if (valueBuf.byteLength === 0) {
                    this.error = this.value[i].error;
                    return EMPTY_BUFFER$1;
                }
                retBuffers.push(valueBuf);
            }
            return concat(retBuffers);
        }
        fromString(string) {
            this.value = [];
            let pos1 = 0;
            let pos2 = 0;
            let sid = "";
            do {
                pos2 = string.indexOf(".", pos1);
                if (pos2 === -1)
                    sid = string.substring(pos1);
                else
                    sid = string.substring(pos1, pos2);
                pos1 = pos2 + 1;
                const sidBlock = new LocalRelativeSidValueBlock();
                sidBlock.valueDec = parseInt(sid, 10);
                if (isNaN(sidBlock.valueDec))
                    return true;
                this.value.push(sidBlock);
            } while (pos2 !== -1);
            return true;
        }
        toString() {
            let result = "";
            let isHexOnly = false;
            for (let i = 0; i < this.value.length; i++) {
                isHexOnly = this.value[i].isHexOnly;
                let sidStr = this.value[i].toString();
                if (i !== 0)
                    result = `${result}.`;
                if (isHexOnly) {
                    sidStr = `{${sidStr}}`;
                    result += sidStr;
                }
                else
                    result += sidStr;
            }
            return result;
        }
        toJSON() {
            const object = {
                ...super.toJSON(),
                value: this.toString(),
                sidArray: [],
            };
            for (let i = 0; i < this.value.length; i++)
                object.sidArray.push(this.value[i].toJSON());
            return object;
        }
    }
    LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";

    var _a$l;
    class RelativeObjectIdentifier extends BaseBlock {
        constructor(parameters = {}) {
            super(parameters, LocalRelativeObjectIdentifierValueBlock);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 13;
        }
        getValue() {
            return this.valueBlock.toString();
        }
        setValue(value) {
            this.valueBlock.fromString(value);
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                value: this.getValue(),
            };
        }
    }
    _a$l = RelativeObjectIdentifier;
    (() => {
        typeStore.RelativeObjectIdentifier = _a$l;
    })();
    RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";

    var _a$k;
    class Sequence extends Constructed {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 16;
        }
    }
    _a$k = Sequence;
    (() => {
        typeStore.Sequence = _a$k;
    })();
    Sequence.NAME = "SEQUENCE";

    var _a$j;
    class Set$1 extends Constructed {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 17;
        }
    }
    _a$j = Set$1;
    (() => {
        typeStore.Set = _a$j;
    })();
    Set$1.NAME = "SET";

    class LocalStringValueBlock extends HexBlock(ValueBlock) {
        constructor({ ...parameters } = {}) {
            super(parameters);
            this.isHexOnly = true;
            this.value = EMPTY_STRING$1;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                value: this.value,
            };
        }
    }
    LocalStringValueBlock.NAME = "StringValueBlock";

    class LocalSimpleStringValueBlock extends LocalStringValueBlock {
    }
    LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";

    class LocalSimpleStringBlock extends BaseStringBlock {
        constructor({ ...parameters } = {}) {
            super(parameters, LocalSimpleStringValueBlock);
        }
        fromBuffer(inputBuffer) {
            this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter_1.toUint8Array(inputBuffer));
        }
        fromString(inputString) {
            const strLen = inputString.length;
            const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
            for (let i = 0; i < strLen; i++)
                view[i] = inputString.charCodeAt(i);
            this.valueBlock.value = inputString;
        }
    }
    LocalSimpleStringBlock.NAME = "SIMPLE STRING";

    class LocalUtf8StringValueBlock extends LocalSimpleStringBlock {
        fromBuffer(inputBuffer) {
            this.valueBlock.valueHexView = BufferSourceConverter_1.toUint8Array(inputBuffer);
            try {
                this.valueBlock.value = Convert_1.ToUtf8String(inputBuffer);
            }
            catch (ex) {
                this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
                this.valueBlock.value = Convert_1.ToBinary(inputBuffer);
            }
        }
        fromString(inputString) {
            this.valueBlock.valueHexView = new Uint8Array(Convert_1.FromUtf8String(inputString));
            this.valueBlock.value = inputString;
        }
    }
    LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";

    var _a$i;
    class Utf8String extends LocalUtf8StringValueBlock {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 12;
        }
    }
    _a$i = Utf8String;
    (() => {
        typeStore.Utf8String = _a$i;
    })();
    Utf8String.NAME = "UTF8String";

    class LocalBmpStringValueBlock extends LocalSimpleStringBlock {
        fromBuffer(inputBuffer) {
            this.valueBlock.value = Convert_1.ToUtf16String(inputBuffer);
            this.valueBlock.valueHexView = BufferSourceConverter_1.toUint8Array(inputBuffer);
        }
        fromString(inputString) {
            this.valueBlock.value = inputString;
            this.valueBlock.valueHexView = new Uint8Array(Convert_1.FromUtf16String(inputString));
        }
    }
    LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";

    var _a$h;
    class BmpString extends LocalBmpStringValueBlock {
        constructor({ ...parameters } = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 30;
        }
    }
    _a$h = BmpString;
    (() => {
        typeStore.BmpString = _a$h;
    })();
    BmpString.NAME = "BMPString";

    class LocalUniversalStringValueBlock extends LocalSimpleStringBlock {
        fromBuffer(inputBuffer) {
            const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
            const valueView = new Uint8Array(copyBuffer);
            for (let i = 0; i < valueView.length; i += 4) {
                valueView[i] = valueView[i + 3];
                valueView[i + 1] = valueView[i + 2];
                valueView[i + 2] = 0x00;
                valueView[i + 3] = 0x00;
            }
            this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
        }
        fromString(inputString) {
            const strLength = inputString.length;
            const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
            for (let i = 0; i < strLength; i++) {
                const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
                const codeView = new Uint8Array(codeBuf);
                if (codeView.length > 4)
                    continue;
                const dif = 4 - codeView.length;
                for (let j = (codeView.length - 1); j >= 0; j--)
                    valueHexView[i * 4 + j + dif] = codeView[j];
            }
            this.valueBlock.value = inputString;
        }
    }
    LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";

    var _a$g;
    class UniversalString extends LocalUniversalStringValueBlock {
        constructor({ ...parameters } = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 28;
        }
    }
    _a$g = UniversalString;
    (() => {
        typeStore.UniversalString = _a$g;
    })();
    UniversalString.NAME = "UniversalString";

    var _a$f;
    class NumericString extends LocalSimpleStringBlock {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 18;
        }
    }
    _a$f = NumericString;
    (() => {
        typeStore.NumericString = _a$f;
    })();
    NumericString.NAME = "NumericString";

    var _a$e;
    class PrintableString extends LocalSimpleStringBlock {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 19;
        }
    }
    _a$e = PrintableString;
    (() => {
        typeStore.PrintableString = _a$e;
    })();
    PrintableString.NAME = "PrintableString";

    var _a$d;
    class TeletexString extends LocalSimpleStringBlock {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 20;
        }
    }
    _a$d = TeletexString;
    (() => {
        typeStore.TeletexString = _a$d;
    })();
    TeletexString.NAME = "TeletexString";

    var _a$c;
    class VideotexString extends LocalSimpleStringBlock {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 21;
        }
    }
    _a$c = VideotexString;
    (() => {
        typeStore.VideotexString = _a$c;
    })();
    VideotexString.NAME = "VideotexString";

    var _a$b;
    class IA5String extends LocalSimpleStringBlock {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 22;
        }
    }
    _a$b = IA5String;
    (() => {
        typeStore.IA5String = _a$b;
    })();
    IA5String.NAME = "IA5String";

    var _a$a;
    class GraphicString extends LocalSimpleStringBlock {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 25;
        }
    }
    _a$a = GraphicString;
    (() => {
        typeStore.GraphicString = _a$a;
    })();
    GraphicString.NAME = "GraphicString";

    var _a$9;
    class VisibleString extends LocalSimpleStringBlock {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 26;
        }
    }
    _a$9 = VisibleString;
    (() => {
        typeStore.VisibleString = _a$9;
    })();
    VisibleString.NAME = "VisibleString";

    var _a$8;
    class GeneralString extends LocalSimpleStringBlock {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 27;
        }
    }
    _a$8 = GeneralString;
    (() => {
        typeStore.GeneralString = _a$8;
    })();
    GeneralString.NAME = "GeneralString";

    var _a$7;
    class CharacterString extends LocalSimpleStringBlock {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 29;
        }
    }
    _a$7 = CharacterString;
    (() => {
        typeStore.CharacterString = _a$7;
    })();
    CharacterString.NAME = "CharacterString";

    var _a$6;
    class UTCTime extends VisibleString {
        constructor({ value, valueDate, ...parameters } = {}) {
            super(parameters);
            this.year = 0;
            this.month = 0;
            this.day = 0;
            this.hour = 0;
            this.minute = 0;
            this.second = 0;
            if (value) {
                this.fromString(value);
                this.valueBlock.valueHexView = new Uint8Array(value.length);
                for (let i = 0; i < value.length; i++)
                    this.valueBlock.valueHexView[i] = value.charCodeAt(i);
            }
            if (valueDate) {
                this.fromDate(valueDate);
                this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
            }
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 23;
        }
        fromBuffer(inputBuffer) {
            this.fromString(String.fromCharCode.apply(null, BufferSourceConverter_1.toUint8Array(inputBuffer)));
        }
        toBuffer() {
            const str = this.toString();
            const buffer = new ArrayBuffer(str.length);
            const view = new Uint8Array(buffer);
            for (let i = 0; i < str.length; i++)
                view[i] = str.charCodeAt(i);
            return buffer;
        }
        fromDate(inputDate) {
            this.year = inputDate.getUTCFullYear();
            this.month = inputDate.getUTCMonth() + 1;
            this.day = inputDate.getUTCDate();
            this.hour = inputDate.getUTCHours();
            this.minute = inputDate.getUTCMinutes();
            this.second = inputDate.getUTCSeconds();
        }
        toDate() {
            return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));
        }
        fromString(inputString) {
            const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
            const parserArray = parser.exec(inputString);
            if (parserArray === null) {
                this.error = "Wrong input string for conversion";
                return;
            }
            const year = parseInt(parserArray[1], 10);
            if (year >= 50)
                this.year = 1900 + year;
            else
                this.year = 2000 + year;
            this.month = parseInt(parserArray[2], 10);
            this.day = parseInt(parserArray[3], 10);
            this.hour = parseInt(parserArray[4], 10);
            this.minute = parseInt(parserArray[5], 10);
            this.second = parseInt(parserArray[6], 10);
        }
        toString(encoding = "iso") {
            if (encoding === "iso") {
                const outputArray = new Array(7);
                outputArray[0] = padNumber(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);
                outputArray[1] = padNumber(this.month, 2);
                outputArray[2] = padNumber(this.day, 2);
                outputArray[3] = padNumber(this.hour, 2);
                outputArray[4] = padNumber(this.minute, 2);
                outputArray[5] = padNumber(this.second, 2);
                outputArray[6] = "Z";
                return outputArray.join("");
            }
            return super.toString(encoding);
        }
        onAsciiEncoding() {
            return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                year: this.year,
                month: this.month,
                day: this.day,
                hour: this.hour,
                minute: this.minute,
                second: this.second,
            };
        }
    }
    _a$6 = UTCTime;
    (() => {
        typeStore.UTCTime = _a$6;
    })();
    UTCTime.NAME = "UTCTime";

    var _a$5;
    class GeneralizedTime extends UTCTime {
        constructor(parameters = {}) {
            var _b;
            super(parameters);
            (_b = this.millisecond) !== null && _b !== void 0 ? _b : (this.millisecond = 0);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 24;
        }
        fromDate(inputDate) {
            super.fromDate(inputDate);
            this.millisecond = inputDate.getUTCMilliseconds();
        }
        toDate() {
            return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)));
        }
        fromString(inputString) {
            let isUTC = false;
            let timeString = "";
            let dateTimeString = "";
            let fractionPart = 0;
            let parser;
            let hourDifference = 0;
            let minuteDifference = 0;
            if (inputString[inputString.length - 1] === "Z") {
                timeString = inputString.substring(0, inputString.length - 1);
                isUTC = true;
            }
            else {
                const number = new Number(inputString[inputString.length - 1]);
                if (isNaN(number.valueOf()))
                    throw new Error("Wrong input string for conversion");
                timeString = inputString;
            }
            if (isUTC) {
                if (timeString.indexOf("+") !== -1)
                    throw new Error("Wrong input string for conversion");
                if (timeString.indexOf("-") !== -1)
                    throw new Error("Wrong input string for conversion");
            }
            else {
                let multiplier = 1;
                let differencePosition = timeString.indexOf("+");
                let differenceString = "";
                if (differencePosition === -1) {
                    differencePosition = timeString.indexOf("-");
                    multiplier = -1;
                }
                if (differencePosition !== -1) {
                    differenceString = timeString.substring(differencePosition + 1);
                    timeString = timeString.substring(0, differencePosition);
                    if ((differenceString.length !== 2) && (differenceString.length !== 4))
                        throw new Error("Wrong input string for conversion");
                    let number = parseInt(differenceString.substring(0, 2), 10);
                    if (isNaN(number.valueOf()))
                        throw new Error("Wrong input string for conversion");
                    hourDifference = multiplier * number;
                    if (differenceString.length === 4) {
                        number = parseInt(differenceString.substring(2, 4), 10);
                        if (isNaN(number.valueOf()))
                            throw new Error("Wrong input string for conversion");
                        minuteDifference = multiplier * number;
                    }
                }
            }
            let fractionPointPosition = timeString.indexOf(".");
            if (fractionPointPosition === -1)
                fractionPointPosition = timeString.indexOf(",");
            if (fractionPointPosition !== -1) {
                const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
                if (isNaN(fractionPartCheck.valueOf()))
                    throw new Error("Wrong input string for conversion");
                fractionPart = fractionPartCheck.valueOf();
                dateTimeString = timeString.substring(0, fractionPointPosition);
            }
            else
                dateTimeString = timeString;
            switch (true) {
                case (dateTimeString.length === 8):
                    parser = /(\d{4})(\d{2})(\d{2})/ig;
                    if (fractionPointPosition !== -1)
                        throw new Error("Wrong input string for conversion");
                    break;
                case (dateTimeString.length === 10):
                    parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
                    if (fractionPointPosition !== -1) {
                        let fractionResult = 60 * fractionPart;
                        this.minute = Math.floor(fractionResult);
                        fractionResult = 60 * (fractionResult - this.minute);
                        this.second = Math.floor(fractionResult);
                        fractionResult = 1000 * (fractionResult - this.second);
                        this.millisecond = Math.floor(fractionResult);
                    }
                    break;
                case (dateTimeString.length === 12):
                    parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
                    if (fractionPointPosition !== -1) {
                        let fractionResult = 60 * fractionPart;
                        this.second = Math.floor(fractionResult);
                        fractionResult = 1000 * (fractionResult - this.second);
                        this.millisecond = Math.floor(fractionResult);
                    }
                    break;
                case (dateTimeString.length === 14):
                    parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
                    if (fractionPointPosition !== -1) {
                        const fractionResult = 1000 * fractionPart;
                        this.millisecond = Math.floor(fractionResult);
                    }
                    break;
                default:
                    throw new Error("Wrong input string for conversion");
            }
            const parserArray = parser.exec(dateTimeString);
            if (parserArray === null)
                throw new Error("Wrong input string for conversion");
            for (let j = 1; j < parserArray.length; j++) {
                switch (j) {
                    case 1:
                        this.year = parseInt(parserArray[j], 10);
                        break;
                    case 2:
                        this.month = parseInt(parserArray[j], 10);
                        break;
                    case 3:
                        this.day = parseInt(parserArray[j], 10);
                        break;
                    case 4:
                        this.hour = parseInt(parserArray[j], 10) + hourDifference;
                        break;
                    case 5:
                        this.minute = parseInt(parserArray[j], 10) + minuteDifference;
                        break;
                    case 6:
                        this.second = parseInt(parserArray[j], 10);
                        break;
                    default:
                        throw new Error("Wrong input string for conversion");
                }
            }
            if (isUTC === false) {
                const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
                this.year = tempDate.getUTCFullYear();
                this.month = tempDate.getUTCMonth();
                this.day = tempDate.getUTCDay();
                this.hour = tempDate.getUTCHours();
                this.minute = tempDate.getUTCMinutes();
                this.second = tempDate.getUTCSeconds();
                this.millisecond = tempDate.getUTCMilliseconds();
            }
        }
        toString(encoding = "iso") {
            if (encoding === "iso") {
                const outputArray = [];
                outputArray.push(padNumber(this.year, 4));
                outputArray.push(padNumber(this.month, 2));
                outputArray.push(padNumber(this.day, 2));
                outputArray.push(padNumber(this.hour, 2));
                outputArray.push(padNumber(this.minute, 2));
                outputArray.push(padNumber(this.second, 2));
                if (this.millisecond !== 0) {
                    outputArray.push(".");
                    outputArray.push(padNumber(this.millisecond, 3));
                }
                outputArray.push("Z");
                return outputArray.join("");
            }
            return super.toString(encoding);
        }
        toJSON() {
            return {
                ...super.toJSON(),
                millisecond: this.millisecond,
            };
        }
    }
    _a$5 = GeneralizedTime;
    (() => {
        typeStore.GeneralizedTime = _a$5;
    })();
    GeneralizedTime.NAME = "GeneralizedTime";

    var _a$4;
    class DATE$2 extends Utf8String {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 31;
        }
    }
    _a$4 = DATE$2;
    (() => {
        typeStore.DATE = _a$4;
    })();
    DATE$2.NAME = "DATE";

    var _a$3;
    class TimeOfDay extends Utf8String {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 32;
        }
    }
    _a$3 = TimeOfDay;
    (() => {
        typeStore.TimeOfDay = _a$3;
    })();
    TimeOfDay.NAME = "TimeOfDay";

    var _a$2;
    class DateTime extends Utf8String {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 33;
        }
    }
    _a$2 = DateTime;
    (() => {
        typeStore.DateTime = _a$2;
    })();
    DateTime.NAME = "DateTime";

    var _a$1;
    class Duration extends Utf8String {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 34;
        }
    }
    _a$1 = Duration;
    (() => {
        typeStore.Duration = _a$1;
    })();
    Duration.NAME = "Duration";

    var _a$x;
    class TIME extends Utf8String {
        constructor(parameters = {}) {
            super(parameters);
            this.idBlock.tagClass = 1;
            this.idBlock.tagNumber = 14;
        }
    }
    _a$x = TIME;
    (() => {
        typeStore.TIME = _a$x;
    })();
    TIME.NAME = "TIME";

    class Any {
        constructor({ name = EMPTY_STRING$1, optional = false, } = {}) {
            this.name = name;
            this.optional = optional;
        }
    }

    class Choice extends Any {
        constructor({ value = [], ...parameters } = {}) {
            super(parameters);
            this.value = value;
        }
    }

    class Repeated extends Any {
        constructor({ value = new Any(), local = false, ...parameters } = {}) {
            super(parameters);
            this.value = value;
            this.local = local;
        }
    }

    class RawData {
        constructor({ data = EMPTY_VIEW } = {}) {
            this.dataView = BufferSourceConverter_1.toUint8Array(data);
        }
        get data() {
            return this.dataView.slice().buffer;
        }
        set data(value) {
            this.dataView = BufferSourceConverter_1.toUint8Array(value);
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            const endLength = inputOffset + inputLength;
            this.dataView = BufferSourceConverter_1.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
            return endLength;
        }
        toBER(sizeOnly) {
            return this.dataView.slice().buffer;
        }
    }

    function compareSchema(root, inputData, inputSchema) {
        if (inputSchema instanceof Choice) {
            for (let j = 0; j < inputSchema.value.length; j++) {
                const result = compareSchema(root, inputData, inputSchema.value[j]);
                if (result.verified) {
                    return {
                        verified: true,
                        result: root
                    };
                }
            }
            {
                const _result = {
                    verified: false,
                    result: {
                        error: "Wrong values for Choice type"
                    },
                };
                if (inputSchema.hasOwnProperty(NAME))
                    _result.name = inputSchema.name;
                return _result;
            }
        }
        if (inputSchema instanceof Any) {
            if (inputSchema.hasOwnProperty(NAME))
                root[inputSchema.name] = inputData;
            return {
                verified: true,
                result: root
            };
        }
        if ((root instanceof Object) === false) {
            return {
                verified: false,
                result: { error: "Wrong root object" }
            };
        }
        if ((inputData instanceof Object) === false) {
            return {
                verified: false,
                result: { error: "Wrong ASN.1 data" }
            };
        }
        if ((inputSchema instanceof Object) === false) {
            return {
                verified: false,
                result: { error: "Wrong ASN.1 schema" }
            };
        }
        if ((ID_BLOCK in inputSchema) === false) {
            return {
                verified: false,
                result: { error: "Wrong ASN.1 schema" }
            };
        }
        if ((FROM_BER in inputSchema.idBlock) === false) {
            return {
                verified: false,
                result: { error: "Wrong ASN.1 schema" }
            };
        }
        if ((TO_BER in inputSchema.idBlock) === false) {
            return {
                verified: false,
                result: { error: "Wrong ASN.1 schema" }
            };
        }
        const encodedId = inputSchema.idBlock.toBER(false);
        if (encodedId.byteLength === 0) {
            return {
                verified: false,
                result: { error: "Error encoding idBlock for ASN.1 schema" }
            };
        }
        const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
        if (decodedOffset === -1) {
            return {
                verified: false,
                result: { error: "Error decoding idBlock for ASN.1 schema" }
            };
        }
        if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {
            return {
                verified: false,
                result: { error: "Wrong ASN.1 schema" }
            };
        }
        if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
            return {
                verified: false,
                result: root
            };
        }
        if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {
            return {
                verified: false,
                result: { error: "Wrong ASN.1 schema" }
            };
        }
        if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
            return {
                verified: false,
                result: root
            };
        }
        if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {
            return {
                verified: false,
                result: { error: "Wrong ASN.1 schema" }
            };
        }
        if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
            return {
                verified: false,
                result: root
            };
        }
        if (!(IS_HEX_ONLY in inputSchema.idBlock)) {
            return {
                verified: false,
                result: { error: "Wrong ASN.1 schema" }
            };
        }
        if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
            return {
                verified: false,
                result: root
            };
        }
        if (inputSchema.idBlock.isHexOnly) {
            if ((VALUE_HEX_VIEW in inputSchema.idBlock) === false) {
                return {
                    verified: false,
                    result: { error: "Wrong ASN.1 schema" }
                };
            }
            const schemaView = inputSchema.idBlock.valueHexView;
            const asn1View = inputData.idBlock.valueHexView;
            if (schemaView.length !== asn1View.length) {
                return {
                    verified: false,
                    result: root
                };
            }
            for (let i = 0; i < schemaView.length; i++) {
                if (schemaView[i] !== asn1View[1]) {
                    return {
                        verified: false,
                        result: root
                    };
                }
            }
        }
        if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
            if (inputSchema.name)
                root[inputSchema.name] = inputData;
        }
        if (inputSchema instanceof typeStore.Constructed) {
            let admission = 0;
            let result = {
                verified: false,
                result: {
                    error: "Unknown error",
                }
            };
            let maxLength = inputSchema.valueBlock.value.length;
            if (maxLength > 0) {
                if (inputSchema.valueBlock.value[0] instanceof Repeated) {
                    maxLength = inputData.valueBlock.value.length;
                }
            }
            if (maxLength === 0) {
                return {
                    verified: true,
                    result: root
                };
            }
            if ((inputData.valueBlock.value.length === 0) &&
                (inputSchema.valueBlock.value.length !== 0)) {
                let _optional = true;
                for (let i = 0; i < inputSchema.valueBlock.value.length; i++)
                    _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
                if (_optional) {
                    return {
                        verified: true,
                        result: root
                    };
                }
                if (inputSchema.name) {
                    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
                    if (inputSchema.name)
                        delete root[inputSchema.name];
                }
                root.error = "Inconsistent object length";
                return {
                    verified: false,
                    result: root
                };
            }
            for (let i = 0; i < maxLength; i++) {
                if ((i - admission) >= inputData.valueBlock.value.length) {
                    if (inputSchema.valueBlock.value[i].optional === false) {
                        const _result = {
                            verified: false,
                            result: root
                        };
                        root.error = "Inconsistent length between ASN.1 data and schema";
                        if (inputSchema.name) {
                            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
                            if (inputSchema.name) {
                                delete root[inputSchema.name];
                                _result.name = inputSchema.name;
                            }
                        }
                        return _result;
                    }
                }
                else {
                    if (inputSchema.valueBlock.value[0] instanceof Repeated) {
                        result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
                        if (result.verified === false) {
                            if (inputSchema.valueBlock.value[0].optional)
                                admission++;
                            else {
                                if (inputSchema.name) {
                                    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
                                    if (inputSchema.name)
                                        delete root[inputSchema.name];
                                }
                                return result;
                            }
                        }
                        if ((NAME in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].name.length > 0)) {
                            let arrayRoot = {};
                            if ((LOCAL in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].local))
                                arrayRoot = inputData;
                            else
                                arrayRoot = root;
                            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
                                arrayRoot[inputSchema.valueBlock.value[0].name] = [];
                            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
                        }
                    }
                    else {
                        result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
                        if (result.verified === false) {
                            if (inputSchema.valueBlock.value[i].optional)
                                admission++;
                            else {
                                if (inputSchema.name) {
                                    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
                                    if (inputSchema.name)
                                        delete root[inputSchema.name];
                                }
                                return result;
                            }
                        }
                    }
                }
            }
            if (result.verified === false) {
                const _result = {
                    verified: false,
                    result: root
                };
                if (inputSchema.name) {
                    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
                    if (inputSchema.name) {
                        delete root[inputSchema.name];
                        _result.name = inputSchema.name;
                    }
                }
                return _result;
            }
            return {
                verified: true,
                result: root
            };
        }
        if (inputSchema.primitiveSchema &&
            (VALUE_HEX_VIEW in inputData.valueBlock)) {
            const asn1 = localFromBER(inputData.valueBlock.valueHexView);
            if (asn1.offset === -1) {
                const _result = {
                    verified: false,
                    result: asn1.result
                };
                if (inputSchema.name) {
                    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING$1);
                    if (inputSchema.name) {
                        delete root[inputSchema.name];
                        _result.name = inputSchema.name;
                    }
                }
                return _result;
            }
            return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
        }
        return {
            verified: true,
            result: root
        };
    }

    /* src/components/decoders/Asn1.svelte generated by Svelte v3.48.0 */
    const file$7 = "src/components/decoders/Asn1.svelte";

    function create_fragment$7(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "svelte-23ex00");
    			add_location(div, file$7, 10, 0, 342);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = /*outputWithLinks*/ ctx[0];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*outputWithLinks*/ 1) div.innerHTML = /*outputWithLinks*/ ctx[0];		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Asn1', slots, []);
    	let { result } = $$props;
    	let outputWithLinks = "";
    	const writable_props = ['result'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Asn1> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('result' in $$props) $$invalidate(1, result = $$props.result);
    	};

    	$$self.$capture_state = () => ({ result, outputWithLinks });

    	$$self.$inject_state = $$props => {
    		if ('result' in $$props) $$invalidate(1, result = $$props.result);
    		if ('outputWithLinks' in $$props) $$invalidate(0, outputWithLinks = $$props.outputWithLinks);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*result*/ 2) {
    			{
    				$$invalidate(0, outputWithLinks = result.value.toString().replace(/OBJECT IDENTIFIER : (\d(?:\.\d+)+)/g, `OBJECT IDENTIFIER : <a href="https://oid-rep.orange-labs.fr/get/$1" target="_blank" style="font-family:monospace;">$1</a>`));
    			}
    		}
    	};

    	return [outputWithLinks, result];
    }

    class Asn1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { result: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Asn1",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*result*/ ctx[1] === undefined && !('result' in props)) {
    			console.warn("<Asn1> was created without expected prop 'result'");
    		}
    	}

    	get result() {
    		throw new Error("<Asn1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set result(value) {
    		throw new Error("<Asn1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var asn1Decoder = {
        name: "ASN.1",
        fullName: "Abstract Syntax Notation One",
        rfc: 3641,
        inputType: "bytes",
        outputType: "asn1",
        display: Asn1,
        f: (bytes) => {
            try {
                let asn1 = fromBER(bytes);
                if (asn1.result.error) {
                    return [null, null];
                }
                else {
                    return [asn1.result, null];
                }
            }
            catch (_a) {
                return [null, null];
            }
        }
    };

    class ByteStream {
        constructor(parameters = {}) {
            if ("view" in parameters) {
                this.fromUint8Array(parameters.view);
            }
            else if ("buffer" in parameters) {
                this.fromArrayBuffer(parameters.buffer);
            }
            else if ("string" in parameters) {
                this.fromString(parameters.string);
            }
            else if ("hexstring" in parameters) {
                this.fromHexString(parameters.hexstring);
            }
            else {
                if ("length" in parameters && parameters.length > 0) {
                    this.length = parameters.length;
                    if (parameters.stub) {
                        for (let i = 0; i < this._view.length; i++) {
                            this._view[i] = parameters.stub;
                        }
                    }
                }
                else {
                    this.length = 0;
                }
            }
        }
        set buffer(value) {
            this._buffer = value;
            this._view = new Uint8Array(this._buffer);
        }
        get buffer() {
            return this._buffer;
        }
        set view(value) {
            this._buffer = new ArrayBuffer(value.length);
            this._view = new Uint8Array(this._buffer);
            this._view.set(value);
        }
        get view() {
            return this._view;
        }
        get length() {
            return this.view.byteLength;
        }
        set length(value) {
            this._buffer = new ArrayBuffer(value);
            this._view = new Uint8Array(this._buffer);
        }
        clear() {
            this._buffer = new ArrayBuffer(0);
            this._view = new Uint8Array(this._buffer);
        }
        fromArrayBuffer(array) {
            this._buffer = array;
            this._view = new Uint8Array(this._buffer);
        }
        fromUint8Array(array) {
            this.fromArrayBuffer(new Uint8Array(array).buffer);
        }
        fromString(string) {
            const stringLength = string.length;
            this.length = stringLength;
            for (let i = 0; i < stringLength; i++)
                this.view[i] = string.charCodeAt(i);
        }
        toString(start = 0, length = (this.view.length - start)) {
            let result = "";
            if ((start >= this.view.length) || (start < 0)) {
                start = 0;
            }
            if ((length >= this.view.length) || (length < 0)) {
                length = this.view.length - start;
            }
            for (let i = start; i < (start + length); i++)
                result += String.fromCharCode(this.view[i]);
            return result;
        }
        fromHexString(hexString) {
            const stringLength = hexString.length;
            this.buffer = new ArrayBuffer(stringLength >> 1);
            this.view = new Uint8Array(this.buffer);
            const hexMap = new Map();
            hexMap.set("0", 0x00);
            hexMap.set("1", 0x01);
            hexMap.set("2", 0x02);
            hexMap.set("3", 0x03);
            hexMap.set("4", 0x04);
            hexMap.set("5", 0x05);
            hexMap.set("6", 0x06);
            hexMap.set("7", 0x07);
            hexMap.set("8", 0x08);
            hexMap.set("9", 0x09);
            hexMap.set("A", 0x0A);
            hexMap.set("a", 0x0A);
            hexMap.set("B", 0x0B);
            hexMap.set("b", 0x0B);
            hexMap.set("C", 0x0C);
            hexMap.set("c", 0x0C);
            hexMap.set("D", 0x0D);
            hexMap.set("d", 0x0D);
            hexMap.set("E", 0x0E);
            hexMap.set("e", 0x0E);
            hexMap.set("F", 0x0F);
            hexMap.set("f", 0x0F);
            let j = 0;
            let temp = 0x00;
            for (let i = 0; i < stringLength; i++) {
                if (!(i % 2)) {
                    temp = hexMap.get(hexString.charAt(i)) << 4;
                }
                else {
                    temp |= hexMap.get(hexString.charAt(i));
                    this.view[j] = temp;
                    j++;
                }
            }
        }
        toHexString(start = 0, length = (this.view.length - start)) {
            let result = "";
            if ((start >= this.view.length) || (start < 0)) {
                start = 0;
            }
            if ((length >= this.view.length) || (length < 0)) {
                length = this.view.length - start;
            }
            for (let i = start; i < (start + length); i++) {
                const str = this.view[i].toString(16).toUpperCase();
                result = result + ((str.length == 1) ? "0" : "") + str;
            }
            return result;
        }
        copy(start = 0, length = (this.length - start)) {
            if (!start && !this.length) {
                return new ByteStream();
            }
            if ((start < 0) || (start > (this.length - 1))) {
                throw new Error(`Wrong start position: ${start}`);
            }
            const stream = new ByteStream({
                buffer: this._buffer.slice(start, start + length)
            });
            return stream;
        }
        slice(start = 0, end = this.length) {
            if (!start && !this.length) {
                return new ByteStream();
            }
            if ((start < 0) || (start > (this.length - 1))) {
                throw new Error(`Wrong start position: ${start}`);
            }
            const stream = new ByteStream({
                buffer: this._buffer.slice(start, end),
            });
            return stream;
        }
        realloc(size) {
            const buffer = new ArrayBuffer(size);
            const view = new Uint8Array(buffer);
            if (size > this._view.length)
                view.set(this._view);
            else {
                view.set(new Uint8Array(this._buffer, 0, size));
            }
            this._buffer = buffer;
            this._view = new Uint8Array(this._buffer);
        }
        append(stream) {
            const initialSize = this.length;
            const streamViewLength = stream.length;
            const subarrayView = stream._view.subarray();
            this.realloc(initialSize + streamViewLength);
            this._view.set(subarrayView, initialSize);
        }
        insert(stream, start = 0, length = (this.length - start)) {
            if (start > (this.length - 1))
                return false;
            if (length > (this.length - start)) {
                length = this.length - start;
            }
            if (length > stream.length) {
                length = stream.length;
            }
            if (length == stream.length)
                this._view.set(stream._view, start);
            else {
                this._view.set(stream._view.subarray(0, length), start);
            }
            return true;
        }
        isEqual(stream) {
            if (this.length != stream.length)
                return false;
            for (let i = 0; i < stream.length; i++) {
                if (this.view[i] != stream.view[i])
                    return false;
            }
            return true;
        }
        isEqualView(view) {
            if (view.length != this.view.length)
                return false;
            for (let i = 0; i < view.length; i++) {
                if (this.view[i] != view[i])
                    return false;
            }
            return true;
        }
        findPattern(pattern, start_, length_, backward_) {
            const { start, length, backward } = this.prepareFindParameters(start_, length_, backward_);
            const patternLength = pattern.length;
            if (patternLength > length) {
                return (-1);
            }
            const patternArray = [];
            for (let i = 0; i < patternLength; i++)
                patternArray.push(pattern.view[i]);
            for (let i = 0; i <= (length - patternLength); i++) {
                let equal = true;
                const equalStart = (backward) ? (start - patternLength - i) : (start + i);
                for (let j = 0; j < patternLength; j++) {
                    if (this.view[j + equalStart] != patternArray[j]) {
                        equal = false;
                        break;
                    }
                }
                if (equal) {
                    return (backward) ? (start - patternLength - i) : (start + patternLength + i);
                }
            }
            return (-1);
        }
        findFirstIn(patterns, start_, length_, backward_) {
            const { start, length, backward } = this.prepareFindParameters(start_, length_, backward_);
            const result = {
                id: (-1),
                position: (backward) ? 0 : (start + length),
                length: 0
            };
            for (let i = 0; i < patterns.length; i++) {
                const position = this.findPattern(patterns[i], start, length, backward);
                if (position != (-1)) {
                    let valid = false;
                    const patternLength = patterns[i].length;
                    if (backward) {
                        if ((position - patternLength) >= (result.position - result.length))
                            valid = true;
                    }
                    else {
                        if ((position - patternLength) <= (result.position - result.length))
                            valid = true;
                    }
                    if (valid) {
                        result.position = position;
                        result.id = i;
                        result.length = patternLength;
                    }
                }
            }
            return result;
        }
        findAllIn(patterns, start_, length_) {
            let { start, length } = this.prepareFindParameters(start_, length_);
            const result = [];
            let patternFound = {
                id: (-1),
                position: start
            };
            do {
                const position = patternFound.position;
                patternFound = this.findFirstIn(patterns, patternFound.position, length);
                if (patternFound.id == (-1)) {
                    break;
                }
                length -= (patternFound.position - position);
                result.push({
                    id: patternFound.id,
                    position: patternFound.position
                });
            } while (true);
            return result;
        }
        findAllPatternIn(pattern, start_, length_) {
            const { start, length } = this.prepareFindParameters(start_, length_);
            const result = [];
            const patternLength = pattern.length;
            if (patternLength > length) {
                return (-1);
            }
            const patternArray = Array.from(pattern.view);
            for (let i = 0; i <= (length - patternLength); i++) {
                let equal = true;
                const equalStart = start + i;
                for (let j = 0; j < patternLength; j++) {
                    if (this.view[j + equalStart] != patternArray[j]) {
                        equal = false;
                        break;
                    }
                }
                if (equal) {
                    result.push(start + patternLength + i);
                    i += (patternLength - 1);
                }
            }
            return result;
        }
        findFirstNotIn(patterns, start_, length_, backward_) {
            let { start, length, backward } = this.prepareFindParameters(start_, length_, backward_);
            const result = {
                left: {
                    id: (-1),
                    position: start
                },
                right: {
                    id: (-1),
                    position: 0
                },
                value: new ByteStream()
            };
            let currentLength = length;
            while (currentLength > 0) {
                result.right = this.findFirstIn(patterns, (backward) ? (start - length + currentLength) : (start + length - currentLength), currentLength, backward);
                if (result.right.id == (-1)) {
                    length = currentLength;
                    if (backward) {
                        start -= length;
                    }
                    else {
                        start = result.left.position;
                    }
                    result.value = new ByteStream({
                        buffer: this._buffer.slice(start, start + length),
                    });
                    break;
                }
                if (result.right.position != ((backward) ? (result.left.position - patterns[result.right.id].length) : (result.left.position + patterns[result.right.id].length))) {
                    if (backward) {
                        start = result.right.position + patterns[result.right.id].length;
                        length = result.left.position - result.right.position - patterns[result.right.id].length;
                    }
                    else {
                        start = result.left.position;
                        length = result.right.position - result.left.position - patterns[result.right.id].length;
                    }
                    result.value = new ByteStream({
                        buffer: this._buffer.slice(start, start + length),
                    });
                    break;
                }
                result.left = result.right;
                currentLength -= patterns[result.right.id].length;
            }
            if (backward) {
                const temp = result.right;
                result.right = result.left;
                result.left = temp;
            }
            return result;
        }
        findAllNotIn(patterns, start_, length_) {
            let { start, length } = this.prepareFindParameters(start_, length_);
            const result = [];
            let patternFound = {
                left: {
                    id: (-1),
                    position: start
                },
                right: {
                    id: (-1),
                    position: start
                },
                value: new ByteStream()
            };
            do {
                const position = patternFound.right.position;
                patternFound = this.findFirstNotIn(patterns, patternFound.right.position, length);
                length -= (patternFound.right.position - position);
                result.push({
                    left: {
                        id: patternFound.left.id,
                        position: patternFound.left.position
                    },
                    right: {
                        id: patternFound.right.id,
                        position: patternFound.right.position
                    },
                    value: patternFound.value
                });
            } while (patternFound.right.id != (-1));
            return result;
        }
        findFirstSequence(patterns, start_, length_, backward_) {
            let { start, length, backward } = this.prepareFindParameters(start_, length_, backward_);
            const firstIn = this.skipNotPatterns(patterns, start, length, backward);
            if (firstIn == (-1)) {
                return {
                    position: (-1),
                    value: new ByteStream()
                };
            }
            const firstNotIn = this.skipPatterns(patterns, firstIn, length - ((backward) ? (start - firstIn) : (firstIn - start)), backward);
            if (backward) {
                start = firstNotIn;
                length = (firstIn - firstNotIn);
            }
            else {
                start = firstIn;
                length = (firstNotIn - firstIn);
            }
            const value = new ByteStream({
                buffer: this._buffer.slice(start, start + length),
            });
            return {
                position: firstNotIn,
                value
            };
        }
        findAllSequences(patterns, start_, length_) {
            let { start, length } = this.prepareFindParameters(start_, length_);
            const result = [];
            let patternFound = {
                position: start,
                value: new ByteStream()
            };
            do {
                const position = patternFound.position;
                patternFound = this.findFirstSequence(patterns, patternFound.position, length);
                if (patternFound.position != (-1)) {
                    length -= (patternFound.position - position);
                    result.push({
                        position: patternFound.position,
                        value: patternFound.value,
                    });
                }
            } while (patternFound.position != (-1));
            return result;
        }
        findPairedPatterns(leftPattern, rightPattern, start_, length_) {
            const result = [];
            if (leftPattern.isEqual(rightPattern))
                return result;
            const { start, length } = this.prepareFindParameters(start_, length_);
            let currentPositionLeft = 0;
            const leftPatterns = this.findAllPatternIn(leftPattern, start, length);
            if (!Array.isArray(leftPatterns) || leftPatterns.length == 0) {
                return result;
            }
            const rightPatterns = this.findAllPatternIn(rightPattern, start, length);
            if (!Array.isArray(rightPatterns) || rightPatterns.length == 0) {
                return result;
            }
            while (currentPositionLeft < leftPatterns.length) {
                if (rightPatterns.length == 0) {
                    break;
                }
                if (leftPatterns[0] == rightPatterns[0]) {
                    result.push({
                        left: leftPatterns[0],
                        right: rightPatterns[0]
                    });
                    leftPatterns.splice(0, 1);
                    rightPatterns.splice(0, 1);
                    continue;
                }
                if (leftPatterns[currentPositionLeft] > rightPatterns[0]) {
                    break;
                }
                while (leftPatterns[currentPositionLeft] < rightPatterns[0]) {
                    currentPositionLeft++;
                    if (currentPositionLeft >= leftPatterns.length) {
                        break;
                    }
                }
                result.push({
                    left: leftPatterns[currentPositionLeft - 1],
                    right: rightPatterns[0]
                });
                leftPatterns.splice(currentPositionLeft - 1, 1);
                rightPatterns.splice(0, 1);
                currentPositionLeft = 0;
            }
            result.sort((a, b) => (a.left - b.left));
            return result;
        }
        findPairedArrays(inputLeftPatterns, inputRightPatterns, start_, length_) {
            const { start, length } = this.prepareFindParameters(start_, length_);
            const result = [];
            let currentPositionLeft = 0;
            const leftPatterns = this.findAllIn(inputLeftPatterns, start, length);
            if (leftPatterns.length == 0)
                return result;
            const rightPatterns = this.findAllIn(inputRightPatterns, start, length);
            if (rightPatterns.length == 0)
                return result;
            while (currentPositionLeft < leftPatterns.length) {
                if (rightPatterns.length == 0) {
                    break;
                }
                if (leftPatterns[0].position == rightPatterns[0].position) {
                    result.push({
                        left: leftPatterns[0],
                        right: rightPatterns[0]
                    });
                    leftPatterns.splice(0, 1);
                    rightPatterns.splice(0, 1);
                    continue;
                }
                if (leftPatterns[currentPositionLeft].position > rightPatterns[0].position) {
                    break;
                }
                while (leftPatterns[currentPositionLeft].position < rightPatterns[0].position) {
                    currentPositionLeft++;
                    if (currentPositionLeft >= leftPatterns.length) {
                        break;
                    }
                }
                result.push({
                    left: leftPatterns[currentPositionLeft - 1],
                    right: rightPatterns[0]
                });
                leftPatterns.splice(currentPositionLeft - 1, 1);
                rightPatterns.splice(0, 1);
                currentPositionLeft = 0;
            }
            result.sort((a, b) => (a.left.position - b.left.position));
            return result;
        }
        replacePattern(searchPattern, replacePattern, start_, length_, findAllResult = null) {
            let result = [];
            let i;
            const output = {
                status: (-1),
                searchPatternPositions: [],
                replacePatternPositions: []
            };
            const { start, length } = this.prepareFindParameters(start_, length_);
            if (findAllResult == null) {
                result = this.findAllIn([searchPattern], start, length);
                if (result.length == 0) {
                    return output;
                }
            }
            else {
                result = findAllResult;
            }
            output.searchPatternPositions.push(...Array.from(result, element => element.position));
            const patternDifference = searchPattern.length - replacePattern.length;
            const changedBuffer = new ArrayBuffer(this.view.length - (result.length * patternDifference));
            const changedView = new Uint8Array(changedBuffer);
            changedView.set(new Uint8Array(this.buffer, 0, start));
            for (i = 0; i < result.length; i++) {
                const currentPosition = (i == 0) ? start : result[i - 1].position;
                changedView.set(new Uint8Array(this.buffer, currentPosition, result[i].position - searchPattern.length - currentPosition), currentPosition - i * patternDifference);
                changedView.set(replacePattern.view, result[i].position - searchPattern.length - i * patternDifference);
                output.replacePatternPositions.push(result[i].position - searchPattern.length - i * patternDifference);
            }
            i--;
            changedView.set(new Uint8Array(this.buffer, result[i].position, this.length - result[i].position), result[i].position - searchPattern.length + replacePattern.length - i * patternDifference);
            this.buffer = changedBuffer;
            this.view = new Uint8Array(this.buffer);
            output.status = 1;
            return output;
        }
        skipPatterns(patterns, start_, length_, backward_) {
            const { start, length, backward } = this.prepareFindParameters(start_, length_, backward_);
            let result = start;
            for (let k = 0; k < patterns.length; k++) {
                const patternLength = patterns[k].length;
                const equalStart = (backward) ? (result - patternLength) : (result);
                let equal = true;
                for (let j = 0; j < patternLength; j++) {
                    if (this.view[j + equalStart] != patterns[k].view[j]) {
                        equal = false;
                        break;
                    }
                }
                if (equal) {
                    k = (-1);
                    if (backward) {
                        result -= patternLength;
                        if (result <= 0)
                            return result;
                    }
                    else {
                        result += patternLength;
                        if (result >= (start + length))
                            return result;
                    }
                }
            }
            return result;
        }
        skipNotPatterns(patterns, start_, length_, backward_) {
            const { start, length, backward } = this.prepareFindParameters(start_, length_, backward_);
            let result = (-1);
            for (let i = 0; i < length; i++) {
                for (let k = 0; k < patterns.length; k++) {
                    const patternLength = patterns[k].length;
                    const equalStart = (backward) ? (start - i - patternLength) : (start + i);
                    let equal = true;
                    for (let j = 0; j < patternLength; j++) {
                        if (this.view[j + equalStart] != patterns[k].view[j]) {
                            equal = false;
                            break;
                        }
                    }
                    if (equal) {
                        result = (backward) ? (start - i) : (start + i);
                        break;
                    }
                }
                if (result != (-1)) {
                    break;
                }
            }
            return result;
        }
        prepareFindParameters(start = null, length = null, backward = false) {
            if (start === null) {
                start = (backward) ? this.length : 0;
            }
            if (start > this.length) {
                start = this.length;
            }
            if (backward) {
                if (length === null) {
                    length = start;
                }
                if (length > start) {
                    length = start;
                }
            }
            else {
                if (length === null) {
                    length = this.length - start;
                }
                if (length > (this.length - start)) {
                    length = this.length - start;
                }
            }
            return { start, length, backward };
        }
    }

    class SeqStream {
        constructor(parameters = {}) {
            this._stream = new ByteStream();
            this._length = 0;
            this._start = 0;
            this.backward = false;
            this.appendBlock = 0;
            this.prevLength = 0;
            this.prevStart = 0;
            if ("view" in parameters) {
                this.stream = new ByteStream({ view: parameters.view });
            }
            else if ("buffer" in parameters) {
                this.stream = new ByteStream({ buffer: parameters.buffer });
            }
            else if ("string" in parameters) {
                this.stream = new ByteStream({ string: parameters.string });
            }
            else if ("hexstring" in parameters) {
                this.stream = new ByteStream({ hexstring: parameters.hexstring });
            }
            else if ("stream" in parameters) {
                this.stream = parameters.stream.slice();
            }
            else {
                this.stream = new ByteStream();
            }
            if ("backward" in parameters && parameters.backward) {
                this.backward = parameters.backward;
                this._start = this.stream.length;
            }
            if ("length" in parameters && parameters.length > 0) {
                this._length = parameters.length;
            }
            if ("start" in parameters && parameters.start && parameters.start > 0) {
                this._start = parameters.start;
            }
            if ("appendBlock" in parameters && parameters.appendBlock && parameters.appendBlock > 0) {
                this.appendBlock = parameters.appendBlock;
            }
        }
        set stream(value) {
            this._stream = value;
            this.prevLength = this._length;
            this._length = value.length;
            this.prevStart = this._start;
            this._start = 0;
        }
        get stream() {
            return this._stream;
        }
        set length(value) {
            this.prevLength = this._length;
            this._length = value;
        }
        get length() {
            if (this.appendBlock) {
                return this.start;
            }
            return this._length;
        }
        set start(value) {
            if (value > this.stream.length)
                return;
            this.prevStart = this._start;
            this.prevLength = this._length;
            this._length -= (this.backward) ? (this._start - value) : (value - this._start);
            this._start = value;
        }
        get start() {
            return this._start;
        }
        get buffer() {
            return this._stream.buffer.slice(0, this._length);
        }
        resetPosition() {
            this._start = this.prevStart;
            this._length = this.prevLength;
        }
        findPattern(pattern, gap = null) {
            if ((gap == null) || (gap > this.length)) {
                gap = this.length;
            }
            const result = this.stream.findPattern(pattern, this.start, this.length, this.backward);
            if (result == (-1))
                return result;
            if (this.backward) {
                if (result < (this.start - pattern.length - gap)) {
                    return (-1);
                }
            }
            else {
                if (result > (this.start + pattern.length + gap)) {
                    return (-1);
                }
            }
            this.start = result;
            return result;
        }
        findFirstIn(patterns, gap = null) {
            if ((gap == null) || (gap > this.length)) {
                gap = this.length;
            }
            const result = this.stream.findFirstIn(patterns, this.start, this.length, this.backward);
            if (result.id == (-1))
                return result;
            if (this.backward) {
                if (result.position < (this.start - patterns[result.id].length - gap)) {
                    return {
                        id: (-1),
                        position: (this.backward) ? 0 : (this.start + this.length)
                    };
                }
            }
            else {
                if (result.position > (this.start + patterns[result.id].length + gap)) {
                    return {
                        id: (-1),
                        position: (this.backward) ? 0 : (this.start + this.length)
                    };
                }
            }
            this.start = result.position;
            return result;
        }
        findAllIn(patterns) {
            const start = (this.backward) ? (this.start - this.length) : this.start;
            return this.stream.findAllIn(patterns, start, this.length);
        }
        findFirstNotIn(patterns, gap = null) {
            if ((gap == null) || (gap > this._length)) {
                gap = this._length;
            }
            const result = this._stream.findFirstNotIn(patterns, this._start, this._length, this.backward);
            if ((result.left.id == (-1)) && (result.right.id == (-1))) {
                return result;
            }
            if (this.backward) {
                if (result.right.id != (-1)) {
                    if (result.right.position < (this._start - patterns[result.right.id].length - gap)) {
                        return {
                            left: {
                                id: (-1),
                                position: this._start
                            },
                            right: {
                                id: (-1),
                                position: 0
                            },
                            value: new ByteStream()
                        };
                    }
                }
            }
            else {
                if (result.left.id != (-1)) {
                    if (result.left.position > (this._start + patterns[result.left.id].length + gap)) {
                        return {
                            left: {
                                id: (-1),
                                position: this._start
                            },
                            right: {
                                id: (-1),
                                position: 0
                            },
                            value: new ByteStream()
                        };
                    }
                }
            }
            if (this.backward) {
                if (result.left.id == (-1)) {
                    this.start = 0;
                }
                else {
                    this.start = result.left.position;
                }
            }
            else {
                if (result.right.id == (-1)) {
                    this.start = (this._start + this._length);
                }
                else {
                    this.start = result.right.position;
                }
            }
            return result;
        }
        findAllNotIn(patterns) {
            const start = (this.backward) ? (this._start - this._length) : this._start;
            return this._stream.findAllNotIn(patterns, start, this._length);
        }
        findFirstSequence(patterns, length = null, gap = null) {
            if ((length == null) || (length > this._length)) {
                length = this._length;
            }
            if ((gap == null) || (gap > length)) {
                gap = length;
            }
            const result = this._stream.findFirstSequence(patterns, this._start, length, this.backward);
            if (result.value.length == 0) {
                return result;
            }
            if (this.backward) {
                if (result.position < (this._start - result.value.length - gap)) {
                    return {
                        position: (-1),
                        value: new ByteStream()
                    };
                }
            }
            else {
                if (result.position > (this._start + result.value.length + gap)) {
                    return {
                        position: (-1),
                        value: new ByteStream()
                    };
                }
            }
            this.start = result.position;
            return result;
        }
        findAllSequences(patterns) {
            const start = (this.backward) ? (this.start - this.length) : this.start;
            return this.stream.findAllSequences(patterns, start, this.length);
        }
        findPairedPatterns(leftPattern, rightPattern, gap = null) {
            if ((gap == null) || (gap > this.length)) {
                gap = this.length;
            }
            const start = (this.backward) ? (this.start - this.length) : this.start;
            const result = this.stream.findPairedPatterns(leftPattern, rightPattern, start, this.length);
            if (result.length) {
                if (this.backward) {
                    if (result[0].right < (this.start - rightPattern.length - gap)) {
                        return [];
                    }
                }
                else {
                    if (result[0].left > (this.start + leftPattern.length + gap)) {
                        return [];
                    }
                }
            }
            return result;
        }
        findPairedArrays(leftPatterns, rightPatterns, gap = null) {
            if ((gap == null) || (gap > this.length)) {
                gap = this.length;
            }
            const start = (this.backward) ? (this.start - this.length) : this.start;
            const result = this.stream.findPairedArrays(leftPatterns, rightPatterns, start, this.length);
            if (result.length) {
                if (this.backward) {
                    if (result[0].right.position < (this.start - rightPatterns[result[0].right.id].length - gap)) {
                        return [];
                    }
                }
                else {
                    if (result[0].left.position > (this.start + leftPatterns[result[0].left.id].length + gap)) {
                        return [];
                    }
                }
            }
            return result;
        }
        replacePattern(searchPattern, replacePattern) {
            const start = (this.backward) ? (this.start - this.length) : this.start;
            return this.stream.replacePattern(searchPattern, replacePattern, start, this.length);
        }
        skipPatterns(patterns) {
            const result = this.stream.skipPatterns(patterns, this.start, this.length, this.backward);
            this.start = result;
            return result;
        }
        skipNotPatterns(patterns) {
            const result = this.stream.skipNotPatterns(patterns, this.start, this.length, this.backward);
            if (result == (-1))
                return (-1);
            this.start = result;
            return result;
        }
        append(stream) {
            this.beforeAppend(stream.length);
            this._stream.view.set(stream.view, this._start);
            this._length += (stream.length * 2);
            this.start = (this._start + stream.length);
            this.prevLength -= (stream.length * 2);
        }
        appendView(view) {
            this.beforeAppend(view.length);
            this._stream.view.set(view, this._start);
            this._length += (view.length * 2);
            this.start = (this._start + view.length);
            this.prevLength -= (view.length * 2);
        }
        appendChar(char) {
            this.beforeAppend(1);
            this._stream.view[this._start] = char;
            this._length += 2;
            this.start = (this._start + 1);
            this.prevLength -= 2;
        }
        appendUint16(number) {
            this.beforeAppend(2);
            const value = new Uint16Array([number]);
            const view = new Uint8Array(value.buffer);
            this.stream.view[this._start] = view[1];
            this._stream.view[this._start + 1] = view[0];
            this._length += 4;
            this.start = this._start + 2;
            this.prevLength -= 4;
        }
        appendUint24(number) {
            this.beforeAppend(3);
            const value = new Uint32Array([number]);
            const view = new Uint8Array(value.buffer);
            this._stream.view[this._start] = view[2];
            this._stream.view[this._start + 1] = view[1];
            this._stream.view[this._start + 2] = view[0];
            this._length += 6;
            this.start = (this._start + 3);
            this.prevLength -= 6;
        }
        appendUint32(number) {
            this.beforeAppend(4);
            const value = new Uint32Array([number]);
            const view = new Uint8Array(value.buffer);
            this._stream.view[this._start] = view[3];
            this._stream.view[this._start + 1] = view[2];
            this._stream.view[this._start + 2] = view[1];
            this._stream.view[this._start + 3] = view[0];
            this._length += 8;
            this.start = (this._start + 4);
            this.prevLength -= 8;
        }
        appendInt16(number) {
            this.beforeAppend(2);
            const value = new Int16Array([number]);
            const view = new Uint8Array(value.buffer);
            this._stream.view[this._start] = view[1];
            this._stream.view[this._start + 1] = view[0];
            this._length += 4;
            this.start = (this._start + 2);
            this.prevLength -= 4;
        }
        appendInt32(number) {
            this.beforeAppend(4);
            const value = new Int32Array([number]);
            const view = new Uint8Array(value.buffer);
            this._stream.view[this._start] = view[3];
            this._stream.view[this._start + 1] = view[2];
            this._stream.view[this._start + 2] = view[1];
            this._stream.view[this._start + 3] = view[0];
            this._length += 8;
            this.start = (this._start + 4);
            this.prevLength -= 8;
        }
        getBlock(size, changeLength = true) {
            if (this._length <= 0) {
                return new Uint8Array(0);
            }
            if (this._length < size) {
                size = this._length;
            }
            let result;
            if (this.backward) {
                const view = this._stream.view.subarray(this._length - size, this._length);
                result = new Uint8Array(size);
                for (let i = 0; i < size; i++) {
                    result[size - 1 - i] = view[i];
                }
            }
            else {
                result = this._stream.view.subarray(this._start, this._start + size);
            }
            if (changeLength) {
                this.start += ((this.backward) ? ((-1) * size) : size);
            }
            return result;
        }
        getUint16(changeLength = true) {
            const block = this.getBlock(2, changeLength);
            if (block.length < 2)
                return 0;
            const value = new Uint16Array(1);
            const view = new Uint8Array(value.buffer);
            view[0] = block[1];
            view[1] = block[0];
            return value[0];
        }
        getInt16(changeLength = true) {
            const block = this.getBlock(2, changeLength);
            if (block.length < 2)
                return 0;
            const value = new Int16Array(1);
            const view = new Uint8Array(value.buffer);
            view[0] = block[1];
            view[1] = block[0];
            return value[0];
        }
        getUint24(changeLength = true) {
            const block = this.getBlock(3, changeLength);
            if (block.length < 3)
                return 0;
            const value = new Uint32Array(1);
            const view = new Uint8Array(value.buffer);
            for (let i = 3; i >= 1; i--) {
                view[3 - i] = block[i - 1];
            }
            return value[0];
        }
        getUint32(changeLength = true) {
            const block = this.getBlock(4, changeLength);
            if (block.length < 4) {
                return 0;
            }
            const value = new Uint32Array(1);
            const view = new Uint8Array(value.buffer);
            for (let i = 3; i >= 0; i--) {
                view[3 - i] = block[i];
            }
            return value[0];
        }
        getInt32(changeLength = true) {
            const block = this.getBlock(4, changeLength);
            if (block.length < 4)
                return 0;
            const value = new Int32Array(1);
            const view = new Uint8Array(value.buffer);
            for (let i = 3; i >= 0; i--) {
                view[3 - i] = block[i];
            }
            return value[0];
        }
        beforeAppend(size) {
            if ((this._start + size) > this._stream.length) {
                if (size > this.appendBlock) {
                    this.appendBlock = size + SeqStream.APPEND_BLOCK;
                }
                this._stream.realloc(this._stream.length + this.appendBlock);
            }
        }
    }
    SeqStream.APPEND_BLOCK = 1000;

    /*!
     * Copyright (c) 2014, GlobalSign
     * Copyright (c) 2015-2019, Peculiar Ventures
     * All rights reserved.
     * 
     * Author 2014-2019, Yury Strozhevsky
     * 
     * Redistribution and use in source and binary forms, with or without modification,
     * are permitted provided that the following conditions are met:
     * 
     * * Redistributions of source code must retain the above copyright notice, this
     *   list of conditions and the following disclaimer.
     * 
     * * Redistributions in binary form must reproduce the above copyright notice, this
     *   list of conditions and the following disclaimer in the documentation and/or
     *   other materials provided with the distribution.
     * 
     * * Neither the name of the {organization} nor the names of its
     *   contributors may be used to endorse or promote products derived from
     *   this software without specific prior written permission.
     * 
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     * 
     */

    const EMPTY_BUFFER = new ArrayBuffer(0);
    const EMPTY_STRING = "";

    class ArgumentError extends TypeError {
        constructor() {
            super(...arguments);
            this.name = ArgumentError.NAME;
        }
        static isType(value, type) {
            if (typeof type === "string") {
                if (type === "Array" && Array.isArray(value)) {
                    return true;
                }
                else if (type === "ArrayBuffer" && value instanceof ArrayBuffer) {
                    return true;
                }
                else if (type === "ArrayBufferView" && ArrayBuffer.isView(value)) {
                    return true;
                }
                else if (typeof value === type) {
                    return true;
                }
            }
            else if (value instanceof type) {
                return true;
            }
            return false;
        }
        static assert(value, name, ...types) {
            for (const type of types) {
                if (this.isType(value, type)) {
                    return;
                }
            }
            const typeNames = types.map(o => o instanceof Function && "name" in o ? o.name : `${o}`);
            throw new ArgumentError(`Parameter '${name}' is not of type ${typeNames.length > 1 ? `(${typeNames.join(" or ")})` : typeNames[0]}`);
        }
    }
    ArgumentError.NAME = "ArgumentError";

    class ParameterError extends TypeError {
        constructor(field, target = null, message) {
            super();
            this.name = ParameterError.NAME;
            this.field = field;
            if (target) {
                this.target = target;
            }
            if (message) {
                this.message = message;
            }
            else {
                this.message = `Absent mandatory parameter '${field}' ${target ? ` in '${target}'` : EMPTY_STRING}`;
            }
        }
        static assert(...args) {
            let target = null;
            let params;
            let fields;
            if (typeof args[0] === "string") {
                target = args[0];
                params = args[1];
                fields = args.slice(2);
            }
            else {
                params = args[0];
                fields = args.slice(1);
            }
            ArgumentError.assert(params, "parameters", "object");
            for (const field of fields) {
                const value = params[field];
                if (value === undefined || value === null) {
                    throw new ParameterError(field, target);
                }
            }
        }
        static assertEmpty(value, name, target) {
            if (value === undefined || value === null) {
                throw new ParameterError(name, target);
            }
        }
    }
    ParameterError.NAME = "ParameterError";

    class AsnError extends Error {
        static assertSchema(asn1, target) {
            if (!asn1.verified) {
                throw new Error(`Object's schema was not verified against input data for ${target}`);
            }
        }
        static assert(asn, target) {
            if (asn.offset === -1) {
                throw new AsnError(`Error during parsing of ASN.1 data. Data is not correct for '${target}'.`);
            }
        }
        constructor(message) {
            super(message);
            this.name = "AsnError";
        }
    }

    class PkiObject {
        static blockName() {
            return this.CLASS_NAME;
        }
        static fromBER(raw) {
            const asn1 = fromBER(raw);
            AsnError.assert(asn1, this.name);
            try {
                return new this({ schema: asn1.result });
            }
            catch (e) {
                throw new AsnError(`Cannot create '${this.CLASS_NAME}' from ASN.1 object`);
            }
        }
        static defaultValues(memberName) {
            throw new Error(`Invalid member name for ${this.CLASS_NAME} class: ${memberName}`);
        }
        static schema(parameters = {}) {
            throw new Error(`Method '${this.CLASS_NAME}.schema' should be overridden`);
        }
        get className() {
            return this.constructor.CLASS_NAME;
        }
        toString(encoding = "hex") {
            let schema;
            try {
                schema = this.toSchema();
            }
            catch {
                schema = this.toSchema(true);
            }
            return Convert_1.ToString(schema.toBER(), encoding);
        }
    }
    PkiObject.CLASS_NAME = "PkiObject";

    function stringPrep(inputString) {
        let isSpace = false;
        let cutResult = EMPTY_STRING;
        const result = inputString.trim();
        for (let i = 0; i < result.length; i++) {
            if (result.charCodeAt(i) === 32) {
                if (isSpace === false)
                    isSpace = true;
            }
            else {
                if (isSpace) {
                    cutResult += " ";
                    isSpace = false;
                }
                cutResult += result[i];
            }
        }
        return cutResult.toLowerCase();
    }

    const TYPE$5 = "type";
    const VALUE$6 = "value";
    class AttributeTypeAndValue extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.type = getParametersValue(parameters, TYPE$5, AttributeTypeAndValue.defaultValues(TYPE$5));
            this.value = getParametersValue(parameters, VALUE$6, AttributeTypeAndValue.defaultValues(VALUE$6));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TYPE$5:
                    return EMPTY_STRING;
                case VALUE$6:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.type || EMPTY_STRING) }),
                    new Any({ name: (names.value || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, [
                TYPE$5,
                "typeValue"
            ]);
            const asn1 = compareSchema(schema, schema, AttributeTypeAndValue.schema({
                names: {
                    type: TYPE$5,
                    value: "typeValue"
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.type = asn1.result.type.valueBlock.toString();
            this.value = asn1.result.typeValue;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    new ObjectIdentifier({ value: this.type }),
                    this.value
                ]
            }));
        }
        toJSON() {
            const _object = {
                type: this.type
            };
            if (Object.keys(this.value).length !== 0) {
                _object.value = (this.value).toJSON();
            }
            else {
                _object.value = this.value;
            }
            return _object;
        }
        isEqual(compareTo) {
            const stringBlockNames = [
                Utf8String.blockName(),
                BmpString.blockName(),
                UniversalString.blockName(),
                NumericString.blockName(),
                PrintableString.blockName(),
                TeletexString.blockName(),
                VideotexString.blockName(),
                IA5String.blockName(),
                GraphicString.blockName(),
                VisibleString.blockName(),
                GeneralString.blockName(),
                CharacterString.blockName()
            ];
            if (compareTo instanceof ArrayBuffer) {
                return BufferSourceConverter_1.isEqual(this.value.valueBeforeDecodeView, compareTo);
            }
            if (compareTo.constructor.blockName() === AttributeTypeAndValue.blockName()) {
                if (this.type !== compareTo.type)
                    return false;
                const isStringPair = [false, false];
                const thisName = this.value.constructor.blockName();
                for (const name of stringBlockNames) {
                    if (thisName === name) {
                        isStringPair[0] = true;
                    }
                    if (compareTo.value.constructor.blockName() === name) {
                        isStringPair[1] = true;
                    }
                }
                if (isStringPair[0] !== isStringPair[1]) {
                    return false;
                }
                const isString = (isStringPair[0] && isStringPair[1]);
                if (isString) {
                    const value1 = stringPrep(this.value.valueBlock.value);
                    const value2 = stringPrep(compareTo.value.valueBlock.value);
                    if (value1.localeCompare(value2) !== 0)
                        return false;
                }
                else {
                    if (!BufferSourceConverter_1.isEqual(this.value.valueBeforeDecodeView, compareTo.value.valueBeforeDecodeView))
                        return false;
                }
                return true;
            }
            return false;
        }
    }
    AttributeTypeAndValue.CLASS_NAME = "AttributeTypeAndValue";

    const TYPE_AND_VALUES = "typesAndValues";
    const VALUE_BEFORE_DECODE = "valueBeforeDecode";
    const RDN = "RDN";
    class RelativeDistinguishedNames extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.typesAndValues = getParametersValue(parameters, TYPE_AND_VALUES, RelativeDistinguishedNames.defaultValues(TYPE_AND_VALUES));
            this.valueBeforeDecode = getParametersValue(parameters, VALUE_BEFORE_DECODE, RelativeDistinguishedNames.defaultValues(VALUE_BEFORE_DECODE));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TYPE_AND_VALUES:
                    return [];
                case VALUE_BEFORE_DECODE:
                    return EMPTY_BUFFER;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case TYPE_AND_VALUES:
                    return (memberValue.length === 0);
                case VALUE_BEFORE_DECODE:
                    return (memberValue.byteLength === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.repeatedSequence || EMPTY_STRING),
                        value: new Set$1({
                            value: [
                                new Repeated({
                                    name: (names.repeatedSet || EMPTY_STRING),
                                    value: AttributeTypeAndValue.schema(names.typeAndValue || {})
                                })
                            ]
                        })
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, [
                RDN,
                TYPE_AND_VALUES
            ]);
            const asn1 = compareSchema(schema, schema, RelativeDistinguishedNames.schema({
                names: {
                    blockName: RDN,
                    repeatedSet: TYPE_AND_VALUES
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (TYPE_AND_VALUES in asn1.result) {
                this.typesAndValues = Array.from(asn1.result.typesAndValues, element => new AttributeTypeAndValue({ schema: element }));
            }
            this.valueBeforeDecode = asn1.result.RDN.valueBeforeDecodeView.slice().buffer;
        }
        toSchema() {
            if (this.valueBeforeDecode.byteLength === 0) {
                return (new Sequence({
                    value: [new Set$1({
                            value: Array.from(this.typesAndValues, o => o.toSchema())
                        })]
                }));
            }
            const asn1 = fromBER(this.valueBeforeDecode);
            AsnError.assert(asn1, "RelativeDistinguishedNames");
            if (!(asn1.result instanceof Sequence)) {
                throw new Error("ASN.1 result should be SEQUENCE");
            }
            return asn1.result;
        }
        toJSON() {
            return {
                typesAndValues: Array.from(this.typesAndValues, o => o.toJSON())
            };
        }
        isEqual(compareTo) {
            if (compareTo instanceof RelativeDistinguishedNames) {
                if (this.typesAndValues.length !== compareTo.typesAndValues.length)
                    return false;
                for (const [index, typeAndValue] of this.typesAndValues.entries()) {
                    if (typeAndValue.isEqual(compareTo.typesAndValues[index]) === false)
                        return false;
                }
                return true;
            }
            if (compareTo instanceof ArrayBuffer) {
                return isEqualBuffer(this.valueBeforeDecode, compareTo);
            }
            return false;
        }
    }
    RelativeDistinguishedNames.CLASS_NAME = "RelativeDistinguishedNames";

    const TYPE$4 = "type";
    const VALUE$5 = "value";
    function builtInStandardAttributes(parameters = {}, optional) {
        const names = getParametersValue(parameters, "names", {});
        return (new Sequence({
            optional,
            value: [
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 2,
                        tagNumber: 1
                    },
                    name: (names.country_name || EMPTY_STRING),
                    value: [
                        new Choice({
                            value: [
                                new NumericString(),
                                new PrintableString()
                            ]
                        })
                    ]
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 2,
                        tagNumber: 2
                    },
                    name: (names.administration_domain_name || EMPTY_STRING),
                    value: [
                        new Choice({
                            value: [
                                new NumericString(),
                                new PrintableString()
                            ]
                        })
                    ]
                }),
                new Primitive({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    name: (names.network_address || EMPTY_STRING),
                    isHexOnly: true
                }),
                new Primitive({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    name: (names.terminal_identifier || EMPTY_STRING),
                    isHexOnly: true
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    name: (names.private_domain_name || EMPTY_STRING),
                    value: [
                        new Choice({
                            value: [
                                new NumericString(),
                                new PrintableString()
                            ]
                        })
                    ]
                }),
                new Primitive({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 3
                    },
                    name: (names.organization_name || EMPTY_STRING),
                    isHexOnly: true
                }),
                new Primitive({
                    optional: true,
                    name: (names.numeric_user_identifier || EMPTY_STRING),
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 4
                    },
                    isHexOnly: true
                }),
                new Constructed({
                    optional: true,
                    name: (names.personal_name || EMPTY_STRING),
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 5
                    },
                    value: [
                        new Primitive({
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 0
                            },
                            isHexOnly: true
                        }),
                        new Primitive({
                            optional: true,
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 1
                            },
                            isHexOnly: true
                        }),
                        new Primitive({
                            optional: true,
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 2
                            },
                            isHexOnly: true
                        }),
                        new Primitive({
                            optional: true,
                            idBlock: {
                                tagClass: 3,
                                tagNumber: 3
                            },
                            isHexOnly: true
                        })
                    ]
                }),
                new Constructed({
                    optional: true,
                    name: (names.organizational_unit_names || EMPTY_STRING),
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 6
                    },
                    value: [
                        new Repeated({
                            value: new PrintableString()
                        })
                    ]
                })
            ]
        }));
    }
    function builtInDomainDefinedAttributes(optional) {
        return (new Sequence({
            optional,
            value: [
                new PrintableString(),
                new PrintableString()
            ]
        }));
    }
    function extensionAttributes(optional) {
        return (new Set$1({
            optional,
            value: [
                new Primitive({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    isHexOnly: true
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [new Any()]
                })
            ]
        }));
    }
    class GeneralName extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.type = getParametersValue(parameters, TYPE$4, GeneralName.defaultValues(TYPE$4));
            this.value = getParametersValue(parameters, VALUE$5, GeneralName.defaultValues(VALUE$5));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TYPE$4:
                    return 9;
                case VALUE$5:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case TYPE$4:
                    return (memberValue === GeneralName.defaultValues(memberName));
                case VALUE$5:
                    return (Object.keys(memberValue).length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Choice({
                value: [
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        name: (names.blockName || EMPTY_STRING),
                        value: [
                            new ObjectIdentifier(),
                            new Constructed({
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 0
                                },
                                value: [new Any()]
                            })
                        ]
                    }),
                    new Primitive({
                        name: (names.blockName || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        }
                    }),
                    new Primitive({
                        name: (names.blockName || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 2
                        }
                    }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 3
                        },
                        name: (names.blockName || EMPTY_STRING),
                        value: [
                            builtInStandardAttributes((names.builtInStandardAttributes || {}), false),
                            builtInDomainDefinedAttributes(true),
                            extensionAttributes(true)
                        ]
                    }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 4
                        },
                        name: (names.blockName || EMPTY_STRING),
                        value: [RelativeDistinguishedNames.schema(names.directoryName || {})]
                    }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 5
                        },
                        name: (names.blockName || EMPTY_STRING),
                        value: [
                            new Constructed({
                                optional: true,
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 0
                                },
                                value: [
                                    new Choice({
                                        value: [
                                            new TeletexString(),
                                            new PrintableString(),
                                            new UniversalString(),
                                            new Utf8String(),
                                            new BmpString()
                                        ]
                                    })
                                ]
                            }),
                            new Constructed({
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 1
                                },
                                value: [
                                    new Choice({
                                        value: [
                                            new TeletexString(),
                                            new PrintableString(),
                                            new UniversalString(),
                                            new Utf8String(),
                                            new BmpString()
                                        ]
                                    })
                                ]
                            })
                        ]
                    }),
                    new Primitive({
                        name: (names.blockName || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 6
                        }
                    }),
                    new Primitive({
                        name: (names.blockName || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 7
                        }
                    }),
                    new Primitive({
                        name: (names.blockName || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 8
                        }
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, [
                "blockName",
                "otherName",
                "rfc822Name",
                "dNSName",
                "x400Address",
                "directoryName",
                "ediPartyName",
                "uniformResourceIdentifier",
                "iPAddress",
                "registeredID"
            ]);
            const asn1 = compareSchema(schema, schema, GeneralName.schema({
                names: {
                    blockName: "blockName",
                    otherName: "otherName",
                    rfc822Name: "rfc822Name",
                    dNSName: "dNSName",
                    x400Address: "x400Address",
                    directoryName: {
                        names: {
                            blockName: "directoryName"
                        }
                    },
                    ediPartyName: "ediPartyName",
                    uniformResourceIdentifier: "uniformResourceIdentifier",
                    iPAddress: "iPAddress",
                    registeredID: "registeredID"
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.type = asn1.result.blockName.idBlock.tagNumber;
            switch (this.type) {
                case 0:
                    this.value = asn1.result.blockName;
                    break;
                case 1:
                case 2:
                case 6:
                    {
                        const value = asn1.result.blockName;
                        value.idBlock.tagClass = 1;
                        value.idBlock.tagNumber = 22;
                        const valueBER = value.toBER(false);
                        const asnValue = fromBER(valueBER);
                        AsnError.assert(asnValue, "GeneralName value");
                        this.value = asnValue.result.valueBlock.value;
                    }
                    break;
                case 3:
                    this.value = asn1.result.blockName;
                    break;
                case 4:
                    this.value = new RelativeDistinguishedNames({ schema: asn1.result.directoryName });
                    break;
                case 5:
                    this.value = asn1.result.ediPartyName;
                    break;
                case 7:
                    this.value = new OctetString({ valueHex: asn1.result.blockName.valueBlock.valueHex });
                    break;
                case 8:
                    {
                        const value = asn1.result.blockName;
                        value.idBlock.tagClass = 1;
                        value.idBlock.tagNumber = 6;
                        const valueBER = value.toBER(false);
                        const asnValue = fromBER(valueBER);
                        AsnError.assert(asnValue, "GeneralName registeredID");
                        this.value = asnValue.result.valueBlock.toString();
                    }
                    break;
            }
        }
        toSchema() {
            switch (this.type) {
                case 0:
                case 3:
                case 5:
                    return new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: this.type
                        },
                        value: [
                            this.value
                        ]
                    });
                case 1:
                case 2:
                case 6:
                    {
                        const value = new IA5String({ value: this.value });
                        value.idBlock.tagClass = 3;
                        value.idBlock.tagNumber = this.type;
                        return value;
                    }
                case 4:
                    return new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 4
                        },
                        value: [this.value.toSchema()]
                    });
                case 7:
                    {
                        const value = this.value;
                        value.idBlock.tagClass = 3;
                        value.idBlock.tagNumber = this.type;
                        return value;
                    }
                case 8:
                    {
                        const value = new ObjectIdentifier({ value: this.value });
                        value.idBlock.tagClass = 3;
                        value.idBlock.tagNumber = this.type;
                        return value;
                    }
                default:
                    return GeneralName.schema();
            }
        }
        toJSON() {
            const _object = {
                type: this.type,
                value: EMPTY_STRING
            };
            if ((typeof this.value) === "string")
                _object.value = this.value;
            else {
                try {
                    _object.value = this.value.toJSON();
                }
                catch (ex) {
                }
            }
            return _object;
        }
    }
    GeneralName.CLASS_NAME = "GeneralName";

    const ACCESS_METHOD = "accessMethod";
    const ACCESS_LOCATION = "accessLocation";
    const CLEAR_PROPS$1v = [
        ACCESS_METHOD,
        ACCESS_LOCATION,
    ];
    class AccessDescription extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.accessMethod = getParametersValue(parameters, ACCESS_METHOD, AccessDescription.defaultValues(ACCESS_METHOD));
            this.accessLocation = getParametersValue(parameters, ACCESS_LOCATION, AccessDescription.defaultValues(ACCESS_LOCATION));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ACCESS_METHOD:
                    return EMPTY_STRING;
                case ACCESS_LOCATION:
                    return new GeneralName();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.accessMethod || EMPTY_STRING) }),
                    GeneralName.schema(names.accessLocation || {})
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1v);
            const asn1 = compareSchema(schema, schema, AccessDescription.schema({
                names: {
                    accessMethod: ACCESS_METHOD,
                    accessLocation: {
                        names: {
                            blockName: ACCESS_LOCATION
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.accessMethod = asn1.result.accessMethod.valueBlock.toString();
            this.accessLocation = new GeneralName({ schema: asn1.result.accessLocation });
        }
        toSchema() {
            return (new Sequence({
                value: [
                    new ObjectIdentifier({ value: this.accessMethod }),
                    this.accessLocation.toSchema()
                ]
            }));
        }
        toJSON() {
            return {
                accessMethod: this.accessMethod,
                accessLocation: this.accessLocation.toJSON()
            };
        }
    }
    AccessDescription.CLASS_NAME = "AccessDescription";

    const SECONDS = "seconds";
    const MILLIS = "millis";
    const MICROS = "micros";
    class Accuracy extends PkiObject {
        constructor(parameters = {}) {
            super();
            if (SECONDS in parameters) {
                this.seconds = getParametersValue(parameters, SECONDS, Accuracy.defaultValues(SECONDS));
            }
            if (MILLIS in parameters) {
                this.millis = getParametersValue(parameters, MILLIS, Accuracy.defaultValues(MILLIS));
            }
            if (MICROS in parameters) {
                this.micros = getParametersValue(parameters, MICROS, Accuracy.defaultValues(MICROS));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case SECONDS:
                case MILLIS:
                case MICROS:
                    return 0;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case SECONDS:
                case MILLIS:
                case MICROS:
                    return (memberValue === Accuracy.defaultValues(memberName));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                optional: true,
                value: [
                    new Integer({
                        optional: true,
                        name: (names.seconds || EMPTY_STRING)
                    }),
                    new Primitive({
                        name: (names.millis || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        }
                    }),
                    new Primitive({
                        name: (names.micros || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        }
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, [
                SECONDS,
                MILLIS,
                MICROS,
            ]);
            const asn1 = compareSchema(schema, schema, Accuracy.schema({
                names: {
                    seconds: SECONDS,
                    millis: MILLIS,
                    micros: MICROS,
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if ("seconds" in asn1.result) {
                this.seconds = asn1.result.seconds.valueBlock.valueDec;
            }
            if ("millis" in asn1.result) {
                const intMillis = new Integer({ valueHex: asn1.result.millis.valueBlock.valueHex });
                this.millis = intMillis.valueBlock.valueDec;
            }
            if ("micros" in asn1.result) {
                const intMicros = new Integer({ valueHex: asn1.result.micros.valueBlock.valueHex });
                this.micros = intMicros.valueBlock.valueDec;
            }
        }
        toSchema() {
            const outputArray = [];
            if (this.seconds !== undefined)
                outputArray.push(new Integer({ value: this.seconds }));
            if (this.millis !== undefined) {
                const intMillis = new Integer({ value: this.millis });
                outputArray.push(new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    valueHex: intMillis.valueBlock.valueHexView
                }));
            }
            if (this.micros !== undefined) {
                const intMicros = new Integer({ value: this.micros });
                outputArray.push(new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    valueHex: intMicros.valueBlock.valueHexView
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const _object = {};
            if (this.seconds !== undefined)
                _object.seconds = this.seconds;
            if (this.millis !== undefined)
                _object.millis = this.millis;
            if (this.micros !== undefined)
                _object.micros = this.micros;
            return _object;
        }
    }
    Accuracy.CLASS_NAME = "Accuracy";

    const ALGORITHM_ID = "algorithmId";
    const ALGORITHM_PARAMS = "algorithmParams";
    const ALGORITHM$2 = "algorithm";
    const PARAMS = "params";
    const CLEAR_PROPS$1u = [
        ALGORITHM$2,
        PARAMS
    ];
    class AlgorithmIdentifier extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.algorithmId = getParametersValue(parameters, ALGORITHM_ID, AlgorithmIdentifier.defaultValues(ALGORITHM_ID));
            if (ALGORITHM_PARAMS in parameters) {
                this.algorithmParams = getParametersValue(parameters, ALGORITHM_PARAMS, AlgorithmIdentifier.defaultValues(ALGORITHM_PARAMS));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ALGORITHM_ID:
                    return EMPTY_STRING;
                case ALGORITHM_PARAMS:
                    return new Any();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case ALGORITHM_ID:
                    return (memberValue === EMPTY_STRING);
                case ALGORITHM_PARAMS:
                    return (memberValue instanceof Any);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                optional: (names.optional || false),
                value: [
                    new ObjectIdentifier({ name: (names.algorithmIdentifier || EMPTY_STRING) }),
                    new Any({ name: (names.algorithmParams || EMPTY_STRING), optional: true })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1u);
            const asn1 = compareSchema(schema, schema, AlgorithmIdentifier.schema({
                names: {
                    algorithmIdentifier: ALGORITHM$2,
                    algorithmParams: PARAMS
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.algorithmId = asn1.result.algorithm.valueBlock.toString();
            if (PARAMS in asn1.result) {
                this.algorithmParams = asn1.result.params;
            }
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new ObjectIdentifier({ value: this.algorithmId }));
            if (this.algorithmParams && !(this.algorithmParams instanceof Any)) {
                outputArray.push(this.algorithmParams);
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const object = {
                algorithmId: this.algorithmId
            };
            if (this.algorithmParams && !(this.algorithmParams instanceof Any)) {
                object.algorithmParams = this.algorithmParams.toJSON();
            }
            return object;
        }
        isEqual(algorithmIdentifier) {
            if (!(algorithmIdentifier instanceof AlgorithmIdentifier)) {
                return false;
            }
            if (this.algorithmId !== algorithmIdentifier.algorithmId) {
                return false;
            }
            if (this.algorithmParams) {
                if (algorithmIdentifier.algorithmParams) {
                    return JSON.stringify(this.algorithmParams) === JSON.stringify(algorithmIdentifier.algorithmParams);
                }
                return false;
            }
            if (algorithmIdentifier.algorithmParams) {
                return false;
            }
            return true;
        }
    }
    AlgorithmIdentifier.CLASS_NAME = "AlgorithmIdentifier";

    const ALT_NAMES = "altNames";
    const CLEAR_PROPS$1t = [
        ALT_NAMES
    ];
    class AltName extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.altNames = getParametersValue(parameters, ALT_NAMES, AltName.defaultValues(ALT_NAMES));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ALT_NAMES:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.altNames || EMPTY_STRING),
                        value: GeneralName.schema()
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1t);
            const asn1 = compareSchema(schema, schema, AltName.schema({
                names: {
                    altNames: ALT_NAMES
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (ALT_NAMES in asn1.result) {
                this.altNames = Array.from(asn1.result.altNames, element => new GeneralName({ schema: element }));
            }
        }
        toSchema() {
            return (new Sequence({
                value: Array.from(this.altNames, o => o.toSchema())
            }));
        }
        toJSON() {
            return {
                altNames: Array.from(this.altNames, o => o.toJSON())
            };
        }
    }
    AltName.CLASS_NAME = "AltName";

    const TYPE$3 = "type";
    const VALUES$1 = "values";
    const CLEAR_PROPS$1s = [
        TYPE$3,
        VALUES$1
    ];
    class Attribute extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.type = getParametersValue(parameters, TYPE$3, Attribute.defaultValues(TYPE$3));
            this.values = getParametersValue(parameters, VALUES$1, Attribute.defaultValues(VALUES$1));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TYPE$3:
                    return EMPTY_STRING;
                case VALUES$1:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case TYPE$3:
                    return (memberValue === EMPTY_STRING);
                case VALUES$1:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.type || EMPTY_STRING) }),
                    new Set$1({
                        name: (names.setName || EMPTY_STRING),
                        value: [
                            new Repeated({
                                name: (names.values || EMPTY_STRING),
                                value: new Any()
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1s);
            const asn1 = compareSchema(schema, schema, Attribute.schema({
                names: {
                    type: TYPE$3,
                    values: VALUES$1
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.type = asn1.result.type.valueBlock.toString();
            this.values = asn1.result.values;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    new ObjectIdentifier({ value: this.type }),
                    new Set$1({
                        value: this.values
                    })
                ]
            }));
        }
        toJSON() {
            return {
                type: this.type,
                values: Array.from(this.values, o => o.toJSON())
            };
        }
    }
    Attribute.CLASS_NAME = "Attribute";

    const NOT_BEFORE_TIME = "notBeforeTime";
    const NOT_AFTER_TIME = "notAfterTime";
    const CLEAR_PROPS$1r = [
        NOT_BEFORE_TIME,
        NOT_AFTER_TIME,
    ];
    class AttCertValidityPeriod extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.notBeforeTime = getParametersValue(parameters, NOT_BEFORE_TIME, AttCertValidityPeriod.defaultValues(NOT_BEFORE_TIME));
            this.notAfterTime = getParametersValue(parameters, NOT_AFTER_TIME, AttCertValidityPeriod.defaultValues(NOT_AFTER_TIME));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case NOT_BEFORE_TIME:
                case NOT_AFTER_TIME:
                    return new Date(0, 0, 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new GeneralizedTime({ name: (names.notBeforeTime || EMPTY_STRING) }),
                    new GeneralizedTime({ name: (names.notAfterTime || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1r);
            const asn1 = compareSchema(schema, schema, AttCertValidityPeriod.schema({
                names: {
                    notBeforeTime: NOT_BEFORE_TIME,
                    notAfterTime: NOT_AFTER_TIME
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.notBeforeTime = asn1.result.notBeforeTime.toDate();
            this.notAfterTime = asn1.result.notAfterTime.toDate();
        }
        toSchema() {
            return (new Sequence({
                value: [
                    new GeneralizedTime({ valueDate: this.notBeforeTime }),
                    new GeneralizedTime({ valueDate: this.notAfterTime }),
                ]
            }));
        }
        toJSON() {
            return {
                notBeforeTime: this.notBeforeTime,
                notAfterTime: this.notAfterTime
            };
        }
    }
    AttCertValidityPeriod.CLASS_NAME = "AttCertValidityPeriod";

    const NAMES = "names";
    const GENERAL_NAMES = "generalNames";
    class GeneralNames extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.names = getParametersValue(parameters, NAMES, GeneralNames.defaultValues(NAMES));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case "names":
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}, optional = false) {
            const names = getParametersValue(parameters, NAMES, {});
            return (new Sequence({
                optional,
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.generalNames || EMPTY_STRING),
                        value: GeneralName.schema()
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, [
                NAMES,
                GENERAL_NAMES
            ]);
            const asn1 = compareSchema(schema, schema, GeneralNames.schema({
                names: {
                    blockName: NAMES,
                    generalNames: GENERAL_NAMES
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.names = Array.from(asn1.result.generalNames, element => new GeneralName({ schema: element }));
        }
        toSchema() {
            return (new Sequence({
                value: Array.from(this.names, o => o.toSchema())
            }));
        }
        toJSON() {
            return {
                names: Array.from(this.names, o => o.toJSON())
            };
        }
    }
    GeneralNames.CLASS_NAME = "GeneralNames";

    const id_SubjectDirectoryAttributes = "2.5.29.9";
    const id_SubjectKeyIdentifier = "2.5.29.14";
    const id_KeyUsage = "2.5.29.15";
    const id_PrivateKeyUsagePeriod = "2.5.29.16";
    const id_SubjectAltName = "2.5.29.17";
    const id_IssuerAltName = "2.5.29.18";
    const id_BasicConstraints = "2.5.29.19";
    const id_CRLNumber = "2.5.29.20";
    const id_BaseCRLNumber = "2.5.29.27";
    const id_CRLReason = "2.5.29.21";
    const id_InvalidityDate = "2.5.29.24";
    const id_IssuingDistributionPoint = "2.5.29.28";
    const id_CertificateIssuer = "2.5.29.29";
    const id_NameConstraints = "2.5.29.30";
    const id_CRLDistributionPoints = "2.5.29.31";
    const id_FreshestCRL = "2.5.29.46";
    const id_CertificatePolicies = "2.5.29.32";
    const id_AnyPolicy = "2.5.29.32.0";
    const id_MicrosoftAppPolicies = "1.3.6.1.4.1.311.21.10";
    const id_PolicyMappings = "2.5.29.33";
    const id_AuthorityKeyIdentifier = "2.5.29.35";
    const id_PolicyConstraints = "2.5.29.36";
    const id_ExtKeyUsage = "2.5.29.37";
    const id_InhibitAnyPolicy = "2.5.29.54";
    const id_AuthorityInfoAccess = "1.3.6.1.5.5.7.1.1";
    const id_SubjectInfoAccess = "1.3.6.1.5.5.7.1.11";
    const id_SignedCertificateTimestampList = "1.3.6.1.4.1.11129.2.4.2";
    const id_MicrosoftCertTemplateV2 = "1.3.6.1.4.1.311.21.7";
    const id_MicrosoftCaVersion = "1.3.6.1.4.1.311.21.1";
    const id_QCStatements = "1.3.6.1.5.5.7.1.3";
    const id_ContentType_Data = "1.2.840.113549.1.7.1";
    const id_ContentType_SignedData = "1.2.840.113549.1.7.2";
    const id_ContentType_EnvelopedData = "1.2.840.113549.1.7.3";
    const id_ContentType_EncryptedData = "1.2.840.113549.1.7.6";
    const id_eContentType_TSTInfo = "1.2.840.113549.1.9.16.1.4";
    const id_CertBag_X509Certificate = "1.2.840.113549.1.9.22.1";
    const id_CertBag_SDSICertificate = "1.2.840.113549.1.9.22.2";
    const id_CertBag_AttributeCertificate = "1.2.840.113549.1.9.22.3";
    const id_CRLBag_X509CRL = "1.2.840.113549.1.9.23.1";
    const id_pkix = "1.3.6.1.5.5.7";
    const id_ad = `${id_pkix}.48`;
    const id_PKIX_OCSP_Basic = `${id_ad}.1.1`;

    const KEY_IDENTIFIER$1 = "keyIdentifier";
    const AUTHORITY_CERT_ISSUER = "authorityCertIssuer";
    const AUTHORITY_CERT_SERIAL_NUMBER = "authorityCertSerialNumber";
    const CLEAR_PROPS$1q = [
        KEY_IDENTIFIER$1,
        AUTHORITY_CERT_ISSUER,
        AUTHORITY_CERT_SERIAL_NUMBER,
    ];
    class AuthorityKeyIdentifier extends PkiObject {
        constructor(parameters = {}) {
            super();
            if (KEY_IDENTIFIER$1 in parameters) {
                this.keyIdentifier = getParametersValue(parameters, KEY_IDENTIFIER$1, AuthorityKeyIdentifier.defaultValues(KEY_IDENTIFIER$1));
            }
            if (AUTHORITY_CERT_ISSUER in parameters) {
                this.authorityCertIssuer = getParametersValue(parameters, AUTHORITY_CERT_ISSUER, AuthorityKeyIdentifier.defaultValues(AUTHORITY_CERT_ISSUER));
            }
            if (AUTHORITY_CERT_SERIAL_NUMBER in parameters) {
                this.authorityCertSerialNumber = getParametersValue(parameters, AUTHORITY_CERT_SERIAL_NUMBER, AuthorityKeyIdentifier.defaultValues(AUTHORITY_CERT_SERIAL_NUMBER));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case KEY_IDENTIFIER$1:
                    return new OctetString();
                case AUTHORITY_CERT_ISSUER:
                    return [];
                case AUTHORITY_CERT_SERIAL_NUMBER:
                    return new Integer();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Primitive({
                        name: (names.keyIdentifier || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        }
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [
                            new Repeated({
                                name: (names.authorityCertIssuer || EMPTY_STRING),
                                value: GeneralName.schema()
                            })
                        ]
                    }),
                    new Primitive({
                        name: (names.authorityCertSerialNumber || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 2
                        }
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1q);
            const asn1 = compareSchema(schema, schema, AuthorityKeyIdentifier.schema({
                names: {
                    keyIdentifier: KEY_IDENTIFIER$1,
                    authorityCertIssuer: AUTHORITY_CERT_ISSUER,
                    authorityCertSerialNumber: AUTHORITY_CERT_SERIAL_NUMBER
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (KEY_IDENTIFIER$1 in asn1.result)
                this.keyIdentifier = new OctetString({ valueHex: asn1.result.keyIdentifier.valueBlock.valueHex });
            if (AUTHORITY_CERT_ISSUER in asn1.result)
                this.authorityCertIssuer = Array.from(asn1.result.authorityCertIssuer, o => new GeneralName({ schema: o }));
            if (AUTHORITY_CERT_SERIAL_NUMBER in asn1.result)
                this.authorityCertSerialNumber = new Integer({ valueHex: asn1.result.authorityCertSerialNumber.valueBlock.valueHex });
        }
        toSchema() {
            const outputArray = [];
            if (this.keyIdentifier) {
                outputArray.push(new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    valueHex: this.keyIdentifier.valueBlock.valueHexView
                }));
            }
            if (this.authorityCertIssuer) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: Array.from(this.authorityCertIssuer, o => o.toSchema())
                }));
            }
            if (this.authorityCertSerialNumber) {
                outputArray.push(new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    valueHex: this.authorityCertSerialNumber.valueBlock.valueHexView
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const object = {};
            if (this.keyIdentifier) {
                object.keyIdentifier = this.keyIdentifier.toJSON();
            }
            if (this.authorityCertIssuer) {
                object.authorityCertIssuer = Array.from(this.authorityCertIssuer, o => o.toJSON());
            }
            if (this.authorityCertSerialNumber) {
                object.authorityCertSerialNumber = this.authorityCertSerialNumber.toJSON();
            }
            return object;
        }
    }
    AuthorityKeyIdentifier.CLASS_NAME = "AuthorityKeyIdentifier";

    const PATH_LENGTH_CONSTRAINT = "pathLenConstraint";
    const CA = "cA";
    class BasicConstraints extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.cA = getParametersValue(parameters, CA, false);
            if (PATH_LENGTH_CONSTRAINT in parameters) {
                this.pathLenConstraint = getParametersValue(parameters, PATH_LENGTH_CONSTRAINT, 0);
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case CA:
                    return false;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Boolean$1({
                        optional: true,
                        name: (names.cA || EMPTY_STRING)
                    }),
                    new Integer({
                        optional: true,
                        name: (names.pathLenConstraint || EMPTY_STRING)
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, [
                CA,
                PATH_LENGTH_CONSTRAINT
            ]);
            const asn1 = compareSchema(schema, schema, BasicConstraints.schema({
                names: {
                    cA: CA,
                    pathLenConstraint: PATH_LENGTH_CONSTRAINT
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (CA in asn1.result) {
                this.cA = asn1.result.cA.valueBlock.value;
            }
            if (PATH_LENGTH_CONSTRAINT in asn1.result) {
                if (asn1.result.pathLenConstraint.valueBlock.isHexOnly) {
                    this.pathLenConstraint = asn1.result.pathLenConstraint;
                }
                else {
                    this.pathLenConstraint = asn1.result.pathLenConstraint.valueBlock.valueDec;
                }
            }
        }
        toSchema() {
            const outputArray = [];
            if (this.cA !== BasicConstraints.defaultValues(CA))
                outputArray.push(new Boolean$1({ value: this.cA }));
            if (PATH_LENGTH_CONSTRAINT in this) {
                if (this.pathLenConstraint instanceof Integer) {
                    outputArray.push(this.pathLenConstraint);
                }
                else {
                    outputArray.push(new Integer({ value: this.pathLenConstraint }));
                }
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const object = {};
            if (this.cA !== BasicConstraints.defaultValues(CA)) {
                object.cA = this.cA;
            }
            if (PATH_LENGTH_CONSTRAINT in this) {
                if (this.pathLenConstraint instanceof Integer) {
                    object.pathLenConstraint = this.pathLenConstraint.toJSON();
                }
                else {
                    object.pathLenConstraint = this.pathLenConstraint;
                }
            }
            return object;
        }
    }
    BasicConstraints.CLASS_NAME = "BasicConstraints";

    const CERTIFICATE_INDEX = "certificateIndex";
    const KEY_INDEX = "keyIndex";
    class CAVersion extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.certificateIndex = getParametersValue(parameters, CERTIFICATE_INDEX, CAVersion.defaultValues(CERTIFICATE_INDEX));
            this.keyIndex = getParametersValue(parameters, KEY_INDEX, CAVersion.defaultValues(KEY_INDEX));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case CERTIFICATE_INDEX:
                case KEY_INDEX:
                    return 0;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema() {
            return (new Integer());
        }
        fromSchema(schema) {
            if (schema.constructor.blockName() !== Integer.blockName()) {
                throw new Error("Object's schema was not verified against input data for CAVersion");
            }
            let value = schema.valueBlock.valueHex.slice(0);
            const valueView = new Uint8Array(value);
            switch (true) {
                case (value.byteLength < 4):
                    {
                        const tempValue = new ArrayBuffer(4);
                        const tempValueView = new Uint8Array(tempValue);
                        tempValueView.set(valueView, 4 - value.byteLength);
                        value = tempValue.slice(0);
                    }
                    break;
                case (value.byteLength > 4):
                    {
                        const tempValue = new ArrayBuffer(4);
                        const tempValueView = new Uint8Array(tempValue);
                        tempValueView.set(valueView.slice(0, 4));
                        value = tempValue.slice(0);
                    }
                    break;
            }
            const keyIndexBuffer = value.slice(0, 2);
            const keyIndexView8 = new Uint8Array(keyIndexBuffer);
            let temp = keyIndexView8[0];
            keyIndexView8[0] = keyIndexView8[1];
            keyIndexView8[1] = temp;
            const keyIndexView16 = new Uint16Array(keyIndexBuffer);
            this.keyIndex = keyIndexView16[0];
            const certificateIndexBuffer = value.slice(2);
            const certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
            temp = certificateIndexView8[0];
            certificateIndexView8[0] = certificateIndexView8[1];
            certificateIndexView8[1] = temp;
            const certificateIndexView16 = new Uint16Array(certificateIndexBuffer);
            this.certificateIndex = certificateIndexView16[0];
        }
        toSchema() {
            const certificateIndexBuffer = new ArrayBuffer(2);
            const certificateIndexView = new Uint16Array(certificateIndexBuffer);
            certificateIndexView[0] = this.certificateIndex;
            const certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
            let temp = certificateIndexView8[0];
            certificateIndexView8[0] = certificateIndexView8[1];
            certificateIndexView8[1] = temp;
            const keyIndexBuffer = new ArrayBuffer(2);
            const keyIndexView = new Uint16Array(keyIndexBuffer);
            keyIndexView[0] = this.keyIndex;
            const keyIndexView8 = new Uint8Array(keyIndexBuffer);
            temp = keyIndexView8[0];
            keyIndexView8[0] = keyIndexView8[1];
            keyIndexView8[1] = temp;
            return (new Integer({
                valueHex: utilConcatBuf(keyIndexBuffer, certificateIndexBuffer)
            }));
        }
        toJSON() {
            return {
                certificateIndex: this.certificateIndex,
                keyIndex: this.keyIndex
            };
        }
    }
    CAVersion.CLASS_NAME = "CAVersion";

    const POLICY_QUALIFIER_ID = "policyQualifierId";
    const QUALIFIER = "qualifier";
    const CLEAR_PROPS$1p = [
        POLICY_QUALIFIER_ID,
        QUALIFIER
    ];
    class PolicyQualifierInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.policyQualifierId = getParametersValue(parameters, POLICY_QUALIFIER_ID, PolicyQualifierInfo.defaultValues(POLICY_QUALIFIER_ID));
            this.qualifier = getParametersValue(parameters, QUALIFIER, PolicyQualifierInfo.defaultValues(QUALIFIER));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case POLICY_QUALIFIER_ID:
                    return EMPTY_STRING;
                case QUALIFIER:
                    return new Any();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.policyQualifierId || EMPTY_STRING) }),
                    new Any({ name: (names.qualifier || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1p);
            const asn1 = compareSchema(schema, schema, PolicyQualifierInfo.schema({
                names: {
                    policyQualifierId: POLICY_QUALIFIER_ID,
                    qualifier: QUALIFIER
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.policyQualifierId = asn1.result.policyQualifierId.valueBlock.toString();
            this.qualifier = asn1.result.qualifier;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    new ObjectIdentifier({ value: this.policyQualifierId }),
                    this.qualifier
                ]
            }));
        }
        toJSON() {
            return {
                policyQualifierId: this.policyQualifierId,
                qualifier: this.qualifier.toJSON()
            };
        }
    }
    PolicyQualifierInfo.CLASS_NAME = "PolicyQualifierInfo";

    const POLICY_IDENTIFIER = "policyIdentifier";
    const POLICY_QUALIFIERS = "policyQualifiers";
    const CLEAR_PROPS$1o = [
        POLICY_IDENTIFIER,
        POLICY_QUALIFIERS
    ];
    class PolicyInformation extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.policyIdentifier = getParametersValue(parameters, POLICY_IDENTIFIER, PolicyInformation.defaultValues(POLICY_IDENTIFIER));
            if (POLICY_QUALIFIERS in parameters) {
                this.policyQualifiers = getParametersValue(parameters, POLICY_QUALIFIERS, PolicyInformation.defaultValues(POLICY_QUALIFIERS));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case POLICY_IDENTIFIER:
                    return EMPTY_STRING;
                case POLICY_QUALIFIERS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.policyIdentifier || EMPTY_STRING) }),
                    new Sequence({
                        optional: true,
                        value: [
                            new Repeated({
                                name: (names.policyQualifiers || EMPTY_STRING),
                                value: PolicyQualifierInfo.schema()
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1o);
            const asn1 = compareSchema(schema, schema, PolicyInformation.schema({
                names: {
                    policyIdentifier: POLICY_IDENTIFIER,
                    policyQualifiers: POLICY_QUALIFIERS
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.policyIdentifier = asn1.result.policyIdentifier.valueBlock.toString();
            if (POLICY_QUALIFIERS in asn1.result) {
                this.policyQualifiers = Array.from(asn1.result.policyQualifiers, element => new PolicyQualifierInfo({ schema: element }));
            }
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new ObjectIdentifier({ value: this.policyIdentifier }));
            if (this.policyQualifiers) {
                outputArray.push(new Sequence({
                    value: Array.from(this.policyQualifiers, o => o.toSchema())
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                policyIdentifier: this.policyIdentifier
            };
            if (this.policyQualifiers)
                res.policyQualifiers = Array.from(this.policyQualifiers, o => o.toJSON());
            return res;
        }
    }
    PolicyInformation.CLASS_NAME = "PolicyInformation";

    const CERTIFICATE_POLICIES = "certificatePolicies";
    const CLEAR_PROPS$1n = [
        CERTIFICATE_POLICIES,
    ];
    class CertificatePolicies extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.certificatePolicies = getParametersValue(parameters, CERTIFICATE_POLICIES, CertificatePolicies.defaultValues(CERTIFICATE_POLICIES));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case CERTIFICATE_POLICIES:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.certificatePolicies || EMPTY_STRING),
                        value: PolicyInformation.schema()
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1n);
            const asn1 = compareSchema(schema, schema, CertificatePolicies.schema({
                names: {
                    certificatePolicies: CERTIFICATE_POLICIES
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.certificatePolicies = Array.from(asn1.result.certificatePolicies, element => new PolicyInformation({ schema: element }));
        }
        toSchema() {
            return (new Sequence({
                value: Array.from(this.certificatePolicies, o => o.toSchema())
            }));
        }
        toJSON() {
            return {
                certificatePolicies: Array.from(this.certificatePolicies, o => o.toJSON())
            };
        }
    }
    CertificatePolicies.CLASS_NAME = "CertificatePolicies";

    const TEMPLATE_ID = "templateID";
    const TEMPLATE_MAJOR_VERSION = "templateMajorVersion";
    const TEMPLATE_MINOR_VERSION = "templateMinorVersion";
    const CLEAR_PROPS$1m = [
        TEMPLATE_ID,
        TEMPLATE_MAJOR_VERSION,
        TEMPLATE_MINOR_VERSION
    ];
    class CertificateTemplate extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.templateID = getParametersValue(parameters, TEMPLATE_ID, CertificateTemplate.defaultValues(TEMPLATE_ID));
            if (TEMPLATE_MAJOR_VERSION in parameters) {
                this.templateMajorVersion = getParametersValue(parameters, TEMPLATE_MAJOR_VERSION, CertificateTemplate.defaultValues(TEMPLATE_MAJOR_VERSION));
            }
            if (TEMPLATE_MINOR_VERSION in parameters) {
                this.templateMinorVersion = getParametersValue(parameters, TEMPLATE_MINOR_VERSION, CertificateTemplate.defaultValues(TEMPLATE_MINOR_VERSION));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TEMPLATE_ID:
                    return EMPTY_STRING;
                case TEMPLATE_MAJOR_VERSION:
                case TEMPLATE_MINOR_VERSION:
                    return 0;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.templateID || EMPTY_STRING) }),
                    new Integer({
                        name: (names.templateMajorVersion || EMPTY_STRING),
                        optional: true
                    }),
                    new Integer({
                        name: (names.templateMinorVersion || EMPTY_STRING),
                        optional: true
                    }),
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1m);
            const asn1 = compareSchema(schema, schema, CertificateTemplate.schema({
                names: {
                    templateID: TEMPLATE_ID,
                    templateMajorVersion: TEMPLATE_MAJOR_VERSION,
                    templateMinorVersion: TEMPLATE_MINOR_VERSION
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.templateID = asn1.result.templateID.valueBlock.toString();
            if (TEMPLATE_MAJOR_VERSION in asn1.result) {
                this.templateMajorVersion = asn1.result.templateMajorVersion.valueBlock.valueDec;
            }
            if (TEMPLATE_MINOR_VERSION in asn1.result) {
                this.templateMinorVersion = asn1.result.templateMinorVersion.valueBlock.valueDec;
            }
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new ObjectIdentifier({ value: this.templateID }));
            if (TEMPLATE_MAJOR_VERSION in this) {
                outputArray.push(new Integer({ value: this.templateMajorVersion }));
            }
            if (TEMPLATE_MINOR_VERSION in this) {
                outputArray.push(new Integer({ value: this.templateMinorVersion }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                templateID: this.templateID
            };
            if (TEMPLATE_MAJOR_VERSION in this)
                res.templateMajorVersion = this.templateMajorVersion;
            if (TEMPLATE_MINOR_VERSION in this)
                res.templateMinorVersion = this.templateMinorVersion;
            return res;
        }
    }

    const DISTRIBUTION_POINT$1 = "distributionPoint";
    const DISTRIBUTION_POINT_NAMES$1 = "distributionPointNames";
    const REASONS = "reasons";
    const CRL_ISSUER = "cRLIssuer";
    const CRL_ISSUER_NAMES = "cRLIssuerNames";
    const CLEAR_PROPS$1l = [
        DISTRIBUTION_POINT$1,
        DISTRIBUTION_POINT_NAMES$1,
        REASONS,
        CRL_ISSUER,
        CRL_ISSUER_NAMES,
    ];
    class DistributionPoint extends PkiObject {
        constructor(parameters = {}) {
            super();
            if (DISTRIBUTION_POINT$1 in parameters) {
                this.distributionPoint = getParametersValue(parameters, DISTRIBUTION_POINT$1, DistributionPoint.defaultValues(DISTRIBUTION_POINT$1));
            }
            if (REASONS in parameters) {
                this.reasons = getParametersValue(parameters, REASONS, DistributionPoint.defaultValues(REASONS));
            }
            if (CRL_ISSUER in parameters) {
                this.cRLIssuer = getParametersValue(parameters, CRL_ISSUER, DistributionPoint.defaultValues(CRL_ISSUER));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case DISTRIBUTION_POINT$1:
                    return [];
                case REASONS:
                    return new BitString();
                case CRL_ISSUER:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [
                            new Choice({
                                value: [
                                    new Constructed({
                                        name: (names.distributionPoint || EMPTY_STRING),
                                        optional: true,
                                        idBlock: {
                                            tagClass: 3,
                                            tagNumber: 0
                                        },
                                        value: [
                                            new Repeated({
                                                name: (names.distributionPointNames || EMPTY_STRING),
                                                value: GeneralName.schema()
                                            })
                                        ]
                                    }),
                                    new Constructed({
                                        name: (names.distributionPoint || EMPTY_STRING),
                                        optional: true,
                                        idBlock: {
                                            tagClass: 3,
                                            tagNumber: 1
                                        },
                                        value: RelativeDistinguishedNames.schema().valueBlock.value
                                    })
                                ]
                            })
                        ]
                    }),
                    new Primitive({
                        name: (names.reasons || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        }
                    }),
                    new Constructed({
                        name: (names.cRLIssuer || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 2
                        },
                        value: [
                            new Repeated({
                                name: (names.cRLIssuerNames || EMPTY_STRING),
                                value: GeneralName.schema()
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1l);
            const asn1 = compareSchema(schema, schema, DistributionPoint.schema({
                names: {
                    distributionPoint: DISTRIBUTION_POINT$1,
                    distributionPointNames: DISTRIBUTION_POINT_NAMES$1,
                    reasons: REASONS,
                    cRLIssuer: CRL_ISSUER,
                    cRLIssuerNames: CRL_ISSUER_NAMES
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (DISTRIBUTION_POINT$1 in asn1.result) {
                if (asn1.result.distributionPoint.idBlock.tagNumber === 0) {
                    this.distributionPoint = Array.from(asn1.result.distributionPointNames, element => new GeneralName({ schema: element }));
                }
                if (asn1.result.distributionPoint.idBlock.tagNumber === 1) {
                    this.distributionPoint = new RelativeDistinguishedNames({
                        schema: new Sequence({
                            value: asn1.result.distributionPoint.valueBlock.value
                        })
                    });
                }
            }
            if (REASONS in asn1.result) {
                this.reasons = new BitString({ valueHex: asn1.result.reasons.valueBlock.valueHex });
            }
            if (CRL_ISSUER in asn1.result) {
                this.cRLIssuer = Array.from(asn1.result.cRLIssuerNames, element => new GeneralName({ schema: element }));
            }
        }
        toSchema() {
            const outputArray = [];
            if (this.distributionPoint) {
                let internalValue;
                if (this.distributionPoint instanceof Array) {
                    internalValue = new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: Array.from(this.distributionPoint, o => o.toSchema())
                    });
                }
                else {
                    internalValue = new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [this.distributionPoint.toSchema()]
                    });
                }
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [internalValue]
                }));
            }
            if (this.reasons) {
                outputArray.push(new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    valueHex: this.reasons.valueBlock.valueHexView
                }));
            }
            if (this.cRLIssuer) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    value: Array.from(this.cRLIssuer, o => o.toSchema())
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const object = {};
            if (this.distributionPoint) {
                if (this.distributionPoint instanceof Array) {
                    object.distributionPoint = Array.from(this.distributionPoint, o => o.toJSON());
                }
                else {
                    object.distributionPoint = this.distributionPoint.toJSON();
                }
            }
            if (this.reasons) {
                object.reasons = this.reasons.toJSON();
            }
            if (this.cRLIssuer) {
                object.cRLIssuer = Array.from(this.cRLIssuer, o => o.toJSON());
            }
            return object;
        }
    }
    DistributionPoint.CLASS_NAME = "DistributionPoint";

    const DISTRIBUTION_POINTS = "distributionPoints";
    const CLEAR_PROPS$1k = [
        DISTRIBUTION_POINTS
    ];
    class CRLDistributionPoints extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.distributionPoints = getParametersValue(parameters, DISTRIBUTION_POINTS, CRLDistributionPoints.defaultValues(DISTRIBUTION_POINTS));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case DISTRIBUTION_POINTS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.distributionPoints || EMPTY_STRING),
                        value: DistributionPoint.schema()
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1k);
            const asn1 = compareSchema(schema, schema, CRLDistributionPoints.schema({
                names: {
                    distributionPoints: DISTRIBUTION_POINTS
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.distributionPoints = Array.from(asn1.result.distributionPoints, element => new DistributionPoint({ schema: element }));
        }
        toSchema() {
            return (new Sequence({
                value: Array.from(this.distributionPoints, o => o.toSchema())
            }));
        }
        toJSON() {
            return {
                distributionPoints: Array.from(this.distributionPoints, o => o.toJSON())
            };
        }
    }
    CRLDistributionPoints.CLASS_NAME = "CRLDistributionPoints";

    const KEY_PURPOSES = "keyPurposes";
    const CLEAR_PROPS$1j = [
        KEY_PURPOSES,
    ];
    class ExtKeyUsage extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.keyPurposes = getParametersValue(parameters, KEY_PURPOSES, ExtKeyUsage.defaultValues(KEY_PURPOSES));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case KEY_PURPOSES:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.keyPurposes || EMPTY_STRING),
                        value: new ObjectIdentifier()
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1j);
            const asn1 = compareSchema(schema, schema, ExtKeyUsage.schema({
                names: {
                    keyPurposes: KEY_PURPOSES
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.keyPurposes = Array.from(asn1.result.keyPurposes, (element) => element.valueBlock.toString());
        }
        toSchema() {
            return (new Sequence({
                value: Array.from(this.keyPurposes, element => new ObjectIdentifier({ value: element }))
            }));
        }
        toJSON() {
            return {
                keyPurposes: Array.from(this.keyPurposes)
            };
        }
    }
    ExtKeyUsage.CLASS_NAME = "ExtKeyUsage";

    const ACCESS_DESCRIPTIONS = "accessDescriptions";
    class InfoAccess extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.accessDescriptions = getParametersValue(parameters, ACCESS_DESCRIPTIONS, InfoAccess.defaultValues(ACCESS_DESCRIPTIONS));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ACCESS_DESCRIPTIONS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.accessDescriptions || EMPTY_STRING),
                        value: AccessDescription.schema()
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, [
                ACCESS_DESCRIPTIONS
            ]);
            const asn1 = compareSchema(schema, schema, InfoAccess.schema({
                names: {
                    accessDescriptions: ACCESS_DESCRIPTIONS
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.accessDescriptions = Array.from(asn1.result.accessDescriptions, element => new AccessDescription({ schema: element }));
        }
        toSchema() {
            return (new Sequence({
                value: Array.from(this.accessDescriptions, o => o.toSchema())
            }));
        }
        toJSON() {
            return {
                accessDescriptions: Array.from(this.accessDescriptions, o => o.toJSON())
            };
        }
    }
    InfoAccess.CLASS_NAME = "InfoAccess";

    const DISTRIBUTION_POINT = "distributionPoint";
    const DISTRIBUTION_POINT_NAMES = "distributionPointNames";
    const ONLY_CONTAINS_USER_CERTS = "onlyContainsUserCerts";
    const ONLY_CONTAINS_CA_CERTS = "onlyContainsCACerts";
    const ONLY_SOME_REASON = "onlySomeReasons";
    const INDIRECT_CRL = "indirectCRL";
    const ONLY_CONTAINS_ATTRIBUTE_CERTS = "onlyContainsAttributeCerts";
    const CLEAR_PROPS$1i = [
        DISTRIBUTION_POINT,
        DISTRIBUTION_POINT_NAMES,
        ONLY_CONTAINS_USER_CERTS,
        ONLY_CONTAINS_CA_CERTS,
        ONLY_SOME_REASON,
        INDIRECT_CRL,
        ONLY_CONTAINS_ATTRIBUTE_CERTS,
    ];
    class IssuingDistributionPoint extends PkiObject {
        constructor(parameters = {}) {
            super();
            if (DISTRIBUTION_POINT in parameters) {
                this.distributionPoint = getParametersValue(parameters, DISTRIBUTION_POINT, IssuingDistributionPoint.defaultValues(DISTRIBUTION_POINT));
            }
            this.onlyContainsUserCerts = getParametersValue(parameters, ONLY_CONTAINS_USER_CERTS, IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_USER_CERTS));
            this.onlyContainsCACerts = getParametersValue(parameters, ONLY_CONTAINS_CA_CERTS, IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_CA_CERTS));
            if (ONLY_SOME_REASON in parameters) {
                this.onlySomeReasons = getParametersValue(parameters, ONLY_SOME_REASON, IssuingDistributionPoint.defaultValues(ONLY_SOME_REASON));
            }
            this.indirectCRL = getParametersValue(parameters, INDIRECT_CRL, IssuingDistributionPoint.defaultValues(INDIRECT_CRL));
            this.onlyContainsAttributeCerts = getParametersValue(parameters, ONLY_CONTAINS_ATTRIBUTE_CERTS, IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_ATTRIBUTE_CERTS));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case DISTRIBUTION_POINT:
                    return [];
                case ONLY_CONTAINS_USER_CERTS:
                    return false;
                case ONLY_CONTAINS_CA_CERTS:
                    return false;
                case ONLY_SOME_REASON:
                    return 0;
                case INDIRECT_CRL:
                    return false;
                case ONLY_CONTAINS_ATTRIBUTE_CERTS:
                    return false;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [
                            new Choice({
                                value: [
                                    new Constructed({
                                        name: (names.distributionPoint || EMPTY_STRING),
                                        idBlock: {
                                            tagClass: 3,
                                            tagNumber: 0
                                        },
                                        value: [
                                            new Repeated({
                                                name: (names.distributionPointNames || EMPTY_STRING),
                                                value: GeneralName.schema()
                                            })
                                        ]
                                    }),
                                    new Constructed({
                                        name: (names.distributionPoint || EMPTY_STRING),
                                        idBlock: {
                                            tagClass: 3,
                                            tagNumber: 1
                                        },
                                        value: RelativeDistinguishedNames.schema().valueBlock.value
                                    })
                                ]
                            })
                        ]
                    }),
                    new Primitive({
                        name: (names.onlyContainsUserCerts || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        }
                    }),
                    new Primitive({
                        name: (names.onlyContainsCACerts || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 2
                        }
                    }),
                    new Primitive({
                        name: (names.onlySomeReasons || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 3
                        }
                    }),
                    new Primitive({
                        name: (names.indirectCRL || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 4
                        }
                    }),
                    new Primitive({
                        name: (names.onlyContainsAttributeCerts || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 5
                        }
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1i);
            const asn1 = compareSchema(schema, schema, IssuingDistributionPoint.schema({
                names: {
                    distributionPoint: DISTRIBUTION_POINT,
                    distributionPointNames: DISTRIBUTION_POINT_NAMES,
                    onlyContainsUserCerts: ONLY_CONTAINS_USER_CERTS,
                    onlyContainsCACerts: ONLY_CONTAINS_CA_CERTS,
                    onlySomeReasons: ONLY_SOME_REASON,
                    indirectCRL: INDIRECT_CRL,
                    onlyContainsAttributeCerts: ONLY_CONTAINS_ATTRIBUTE_CERTS
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (DISTRIBUTION_POINT in asn1.result) {
                switch (true) {
                    case (asn1.result.distributionPoint.idBlock.tagNumber === 0):
                        this.distributionPoint = Array.from(asn1.result.distributionPointNames, element => new GeneralName({ schema: element }));
                        break;
                    case (asn1.result.distributionPoint.idBlock.tagNumber === 1):
                        {
                            this.distributionPoint = new RelativeDistinguishedNames({
                                schema: new Sequence({
                                    value: asn1.result.distributionPoint.valueBlock.value
                                })
                            });
                        }
                        break;
                    default:
                        throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}");
                }
            }
            if (ONLY_CONTAINS_USER_CERTS in asn1.result) {
                const view = new Uint8Array(asn1.result.onlyContainsUserCerts.valueBlock.valueHex);
                this.onlyContainsUserCerts = (view[0] !== 0x00);
            }
            if (ONLY_CONTAINS_CA_CERTS in asn1.result) {
                const view = new Uint8Array(asn1.result.onlyContainsCACerts.valueBlock.valueHex);
                this.onlyContainsCACerts = (view[0] !== 0x00);
            }
            if (ONLY_SOME_REASON in asn1.result) {
                const view = new Uint8Array(asn1.result.onlySomeReasons.valueBlock.valueHex);
                this.onlySomeReasons = view[0];
            }
            if (INDIRECT_CRL in asn1.result) {
                const view = new Uint8Array(asn1.result.indirectCRL.valueBlock.valueHex);
                this.indirectCRL = (view[0] !== 0x00);
            }
            if (ONLY_CONTAINS_ATTRIBUTE_CERTS in asn1.result) {
                const view = new Uint8Array(asn1.result.onlyContainsAttributeCerts.valueBlock.valueHex);
                this.onlyContainsAttributeCerts = (view[0] !== 0x00);
            }
        }
        toSchema() {
            const outputArray = [];
            if (this.distributionPoint) {
                let value;
                if (this.distributionPoint instanceof Array) {
                    value = new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: Array.from(this.distributionPoint, o => o.toSchema())
                    });
                }
                else {
                    value = this.distributionPoint.toSchema();
                    value.idBlock.tagClass = 3;
                    value.idBlock.tagNumber = 1;
                }
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [value]
                }));
            }
            if (this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_USER_CERTS)) {
                outputArray.push(new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    valueHex: (new Uint8Array([0xFF])).buffer
                }));
            }
            if (this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_CA_CERTS)) {
                outputArray.push(new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    valueHex: (new Uint8Array([0xFF])).buffer
                }));
            }
            if (this.onlySomeReasons !== undefined) {
                const buffer = new ArrayBuffer(1);
                const view = new Uint8Array(buffer);
                view[0] = this.onlySomeReasons;
                outputArray.push(new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 3
                    },
                    valueHex: buffer
                }));
            }
            if (this.indirectCRL !== IssuingDistributionPoint.defaultValues(INDIRECT_CRL)) {
                outputArray.push(new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 4
                    },
                    valueHex: (new Uint8Array([0xFF])).buffer
                }));
            }
            if (this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_ATTRIBUTE_CERTS)) {
                outputArray.push(new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 5
                    },
                    valueHex: (new Uint8Array([0xFF])).buffer
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const obj = {};
            if (this.distributionPoint) {
                if (this.distributionPoint instanceof Array) {
                    obj.distributionPoint = Array.from(this.distributionPoint, o => o.toJSON());
                }
                else {
                    obj.distributionPoint = this.distributionPoint.toJSON();
                }
            }
            if (this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_USER_CERTS)) {
                obj.onlyContainsUserCerts = this.onlyContainsUserCerts;
            }
            if (this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_CA_CERTS)) {
                obj.onlyContainsCACerts = this.onlyContainsCACerts;
            }
            if (ONLY_SOME_REASON in this) {
                obj.onlySomeReasons = this.onlySomeReasons;
            }
            if (this.indirectCRL !== IssuingDistributionPoint.defaultValues(INDIRECT_CRL)) {
                obj.indirectCRL = this.indirectCRL;
            }
            if (this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_ATTRIBUTE_CERTS)) {
                obj.onlyContainsAttributeCerts = this.onlyContainsAttributeCerts;
            }
            return obj;
        }
    }
    IssuingDistributionPoint.CLASS_NAME = "IssuingDistributionPoint";

    const BASE = "base";
    const MINIMUM = "minimum";
    const MAXIMUM = "maximum";
    const CLEAR_PROPS$1h = [
        BASE,
        MINIMUM,
        MAXIMUM
    ];
    class GeneralSubtree extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.base = getParametersValue(parameters, BASE, GeneralSubtree.defaultValues(BASE));
            this.minimum = getParametersValue(parameters, MINIMUM, GeneralSubtree.defaultValues(MINIMUM));
            if (MAXIMUM in parameters) {
                this.maximum = getParametersValue(parameters, MAXIMUM, GeneralSubtree.defaultValues(MAXIMUM));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case BASE:
                    return new GeneralName();
                case MINIMUM:
                    return 0;
                case MAXIMUM:
                    return 0;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    GeneralName.schema(names.base || {}),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [new Integer({ name: (names.minimum || EMPTY_STRING) })]
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [new Integer({ name: (names.maximum || EMPTY_STRING) })]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1h);
            const asn1 = compareSchema(schema, schema, GeneralSubtree.schema({
                names: {
                    base: {
                        names: {
                            blockName: BASE
                        }
                    },
                    minimum: MINIMUM,
                    maximum: MAXIMUM
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.base = new GeneralName({ schema: asn1.result.base });
            if (MINIMUM in asn1.result) {
                if (asn1.result.minimum.valueBlock.isHexOnly)
                    this.minimum = asn1.result.minimum;
                else
                    this.minimum = asn1.result.minimum.valueBlock.valueDec;
            }
            if (MAXIMUM in asn1.result) {
                if (asn1.result.maximum.valueBlock.isHexOnly)
                    this.maximum = asn1.result.maximum;
                else
                    this.maximum = asn1.result.maximum.valueBlock.valueDec;
            }
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(this.base.toSchema());
            if (this.minimum !== 0) {
                let valueMinimum = 0;
                if (this.minimum instanceof Integer) {
                    valueMinimum = this.minimum;
                }
                else {
                    valueMinimum = new Integer({ value: this.minimum });
                }
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [valueMinimum]
                }));
            }
            if (MAXIMUM in this) {
                let valueMaximum = 0;
                if (this.maximum instanceof Integer) {
                    valueMaximum = this.maximum;
                }
                else {
                    valueMaximum = new Integer({ value: this.maximum });
                }
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [valueMaximum]
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                base: this.base.toJSON()
            };
            if (this.minimum !== 0) {
                if (typeof this.minimum === "number") {
                    res.minimum = this.minimum;
                }
                else {
                    res.minimum = this.minimum.toJSON();
                }
            }
            if (this.maximum !== undefined) {
                if (typeof this.maximum === "number") {
                    res.maximum = this.maximum;
                }
                else {
                    res.maximum = this.maximum.toJSON();
                }
            }
            return res;
        }
    }
    GeneralSubtree.CLASS_NAME = "GeneralSubtree";

    const PERMITTED_SUBTREES = "permittedSubtrees";
    const EXCLUDED_SUBTREES = "excludedSubtrees";
    const CLEAR_PROPS$1g = [
        PERMITTED_SUBTREES,
        EXCLUDED_SUBTREES
    ];
    class NameConstraints extends PkiObject {
        constructor(parameters = {}) {
            super();
            if (PERMITTED_SUBTREES in parameters) {
                this.permittedSubtrees = getParametersValue(parameters, PERMITTED_SUBTREES, NameConstraints.defaultValues(PERMITTED_SUBTREES));
            }
            if (EXCLUDED_SUBTREES in parameters) {
                this.excludedSubtrees = getParametersValue(parameters, EXCLUDED_SUBTREES, NameConstraints.defaultValues(EXCLUDED_SUBTREES));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case PERMITTED_SUBTREES:
                case EXCLUDED_SUBTREES:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [
                            new Repeated({
                                name: (names.permittedSubtrees || EMPTY_STRING),
                                value: GeneralSubtree.schema()
                            })
                        ]
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [
                            new Repeated({
                                name: (names.excludedSubtrees || EMPTY_STRING),
                                value: GeneralSubtree.schema()
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1g);
            const asn1 = compareSchema(schema, schema, NameConstraints.schema({
                names: {
                    permittedSubtrees: PERMITTED_SUBTREES,
                    excludedSubtrees: EXCLUDED_SUBTREES
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (PERMITTED_SUBTREES in asn1.result)
                this.permittedSubtrees = Array.from(asn1.result.permittedSubtrees, element => new GeneralSubtree({ schema: element }));
            if (EXCLUDED_SUBTREES in asn1.result)
                this.excludedSubtrees = Array.from(asn1.result.excludedSubtrees, element => new GeneralSubtree({ schema: element }));
        }
        toSchema() {
            const outputArray = [];
            if (this.permittedSubtrees) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: Array.from(this.permittedSubtrees, o => o.toSchema())
                }));
            }
            if (this.excludedSubtrees) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: Array.from(this.excludedSubtrees, o => o.toSchema())
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const object = {};
            if (this.permittedSubtrees) {
                object.permittedSubtrees = Array.from(this.permittedSubtrees, o => o.toJSON());
            }
            if (this.excludedSubtrees) {
                object.excludedSubtrees = Array.from(this.excludedSubtrees, o => o.toJSON());
            }
            return object;
        }
    }
    NameConstraints.CLASS_NAME = "NameConstraints";

    const REQUIRE_EXPLICIT_POLICY = "requireExplicitPolicy";
    const INHIBIT_POLICY_MAPPING = "inhibitPolicyMapping";
    const CLEAR_PROPS$1f = [
        REQUIRE_EXPLICIT_POLICY,
        INHIBIT_POLICY_MAPPING,
    ];
    class PolicyConstraints extends PkiObject {
        constructor(parameters = {}) {
            super();
            if (REQUIRE_EXPLICIT_POLICY in parameters) {
                this.requireExplicitPolicy = getParametersValue(parameters, REQUIRE_EXPLICIT_POLICY, PolicyConstraints.defaultValues(REQUIRE_EXPLICIT_POLICY));
            }
            if (INHIBIT_POLICY_MAPPING in parameters) {
                this.inhibitPolicyMapping = getParametersValue(parameters, INHIBIT_POLICY_MAPPING, PolicyConstraints.defaultValues(INHIBIT_POLICY_MAPPING));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case REQUIRE_EXPLICIT_POLICY:
                    return 0;
                case INHIBIT_POLICY_MAPPING:
                    return 0;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Primitive({
                        name: (names.requireExplicitPolicy || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        }
                    }),
                    new Primitive({
                        name: (names.inhibitPolicyMapping || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        }
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1f);
            const asn1 = compareSchema(schema, schema, PolicyConstraints.schema({
                names: {
                    requireExplicitPolicy: REQUIRE_EXPLICIT_POLICY,
                    inhibitPolicyMapping: INHIBIT_POLICY_MAPPING
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (REQUIRE_EXPLICIT_POLICY in asn1.result) {
                const field1 = asn1.result.requireExplicitPolicy;
                field1.idBlock.tagClass = 1;
                field1.idBlock.tagNumber = 2;
                const ber1 = field1.toBER(false);
                const int1 = fromBER(ber1);
                AsnError.assert(int1, "Integer");
                this.requireExplicitPolicy = int1.result.valueBlock.valueDec;
            }
            if (INHIBIT_POLICY_MAPPING in asn1.result) {
                const field2 = asn1.result.inhibitPolicyMapping;
                field2.idBlock.tagClass = 1;
                field2.idBlock.tagNumber = 2;
                const ber2 = field2.toBER(false);
                const int2 = fromBER(ber2);
                AsnError.assert(int2, "Integer");
                this.inhibitPolicyMapping = int2.result.valueBlock.valueDec;
            }
        }
        toSchema() {
            const outputArray = [];
            if (REQUIRE_EXPLICIT_POLICY in this) {
                const int1 = new Integer({ value: this.requireExplicitPolicy });
                int1.idBlock.tagClass = 3;
                int1.idBlock.tagNumber = 0;
                outputArray.push(int1);
            }
            if (INHIBIT_POLICY_MAPPING in this) {
                const int2 = new Integer({ value: this.inhibitPolicyMapping });
                int2.idBlock.tagClass = 3;
                int2.idBlock.tagNumber = 1;
                outputArray.push(int2);
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {};
            if (REQUIRE_EXPLICIT_POLICY in this) {
                res.requireExplicitPolicy = this.requireExplicitPolicy;
            }
            if (INHIBIT_POLICY_MAPPING in this) {
                res.inhibitPolicyMapping = this.inhibitPolicyMapping;
            }
            return res;
        }
    }
    PolicyConstraints.CLASS_NAME = "PolicyConstraints";

    const ISSUER_DOMAIN_POLICY = "issuerDomainPolicy";
    const SUBJECT_DOMAIN_POLICY = "subjectDomainPolicy";
    const CLEAR_PROPS$1e = [
        ISSUER_DOMAIN_POLICY,
        SUBJECT_DOMAIN_POLICY
    ];
    class PolicyMapping extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.issuerDomainPolicy = getParametersValue(parameters, ISSUER_DOMAIN_POLICY, PolicyMapping.defaultValues(ISSUER_DOMAIN_POLICY));
            this.subjectDomainPolicy = getParametersValue(parameters, SUBJECT_DOMAIN_POLICY, PolicyMapping.defaultValues(SUBJECT_DOMAIN_POLICY));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ISSUER_DOMAIN_POLICY:
                    return EMPTY_STRING;
                case SUBJECT_DOMAIN_POLICY:
                    return EMPTY_STRING;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.issuerDomainPolicy || EMPTY_STRING) }),
                    new ObjectIdentifier({ name: (names.subjectDomainPolicy || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1e);
            const asn1 = compareSchema(schema, schema, PolicyMapping.schema({
                names: {
                    issuerDomainPolicy: ISSUER_DOMAIN_POLICY,
                    subjectDomainPolicy: SUBJECT_DOMAIN_POLICY
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.issuerDomainPolicy = asn1.result.issuerDomainPolicy.valueBlock.toString();
            this.subjectDomainPolicy = asn1.result.subjectDomainPolicy.valueBlock.toString();
        }
        toSchema() {
            return (new Sequence({
                value: [
                    new ObjectIdentifier({ value: this.issuerDomainPolicy }),
                    new ObjectIdentifier({ value: this.subjectDomainPolicy })
                ]
            }));
        }
        toJSON() {
            return {
                issuerDomainPolicy: this.issuerDomainPolicy,
                subjectDomainPolicy: this.subjectDomainPolicy
            };
        }
    }
    PolicyMapping.CLASS_NAME = "PolicyMapping";

    const MAPPINGS = "mappings";
    const CLEAR_PROPS$1d = [
        MAPPINGS,
    ];
    class PolicyMappings extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.mappings = getParametersValue(parameters, MAPPINGS, PolicyMappings.defaultValues(MAPPINGS));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case MAPPINGS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.mappings || EMPTY_STRING),
                        value: PolicyMapping.schema()
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1d);
            const asn1 = compareSchema(schema, schema, PolicyMappings.schema({
                names: {
                    mappings: MAPPINGS
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.mappings = Array.from(asn1.result.mappings, element => new PolicyMapping({ schema: element }));
        }
        toSchema() {
            return (new Sequence({
                value: Array.from(this.mappings, o => o.toSchema())
            }));
        }
        toJSON() {
            return {
                mappings: Array.from(this.mappings, o => o.toJSON())
            };
        }
    }
    PolicyMappings.CLASS_NAME = "PolicyMappings";

    const NOT_BEFORE$1 = "notBefore";
    const NOT_AFTER$1 = "notAfter";
    const CLEAR_PROPS$1c = [
        NOT_BEFORE$1,
        NOT_AFTER$1
    ];
    class PrivateKeyUsagePeriod extends PkiObject {
        constructor(parameters = {}) {
            super();
            if (NOT_BEFORE$1 in parameters) {
                this.notBefore = getParametersValue(parameters, NOT_BEFORE$1, PrivateKeyUsagePeriod.defaultValues(NOT_BEFORE$1));
            }
            if (NOT_AFTER$1 in parameters) {
                this.notAfter = getParametersValue(parameters, NOT_AFTER$1, PrivateKeyUsagePeriod.defaultValues(NOT_AFTER$1));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case NOT_BEFORE$1:
                    return new Date();
                case NOT_AFTER$1:
                    return new Date();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Primitive({
                        name: (names.notBefore || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        }
                    }),
                    new Primitive({
                        name: (names.notAfter || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        }
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1c);
            const asn1 = compareSchema(schema, schema, PrivateKeyUsagePeriod.schema({
                names: {
                    notBefore: NOT_BEFORE$1,
                    notAfter: NOT_AFTER$1
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (NOT_BEFORE$1 in asn1.result) {
                const localNotBefore = new GeneralizedTime();
                localNotBefore.fromBuffer(asn1.result.notBefore.valueBlock.valueHex);
                this.notBefore = localNotBefore.toDate();
            }
            if (NOT_AFTER$1 in asn1.result) {
                const localNotAfter = new GeneralizedTime({ valueHex: asn1.result.notAfter.valueBlock.valueHex });
                localNotAfter.fromBuffer(asn1.result.notAfter.valueBlock.valueHex);
                this.notAfter = localNotAfter.toDate();
            }
        }
        toSchema() {
            const outputArray = [];
            if (NOT_BEFORE$1 in this) {
                outputArray.push(new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    valueHex: (new GeneralizedTime({ valueDate: this.notBefore })).valueBlock.valueHexView
                }));
            }
            if (NOT_AFTER$1 in this) {
                outputArray.push(new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    valueHex: (new GeneralizedTime({ valueDate: this.notAfter })).valueBlock.valueHexView
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {};
            if (this.notBefore) {
                res.notBefore = this.notBefore;
            }
            if (this.notAfter) {
                res.notAfter = this.notAfter;
            }
            return res;
        }
    }
    PrivateKeyUsagePeriod.CLASS_NAME = "PrivateKeyUsagePeriod";

    const ID = "id";
    const TYPE$2 = "type";
    const VALUES = "values";
    const QC_STATEMENT_CLEAR_PROPS = [
        ID,
        TYPE$2
    ];
    const QC_STATEMENTS_CLEAR_PROPS = [
        VALUES
    ];
    class QCStatement extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.id = getParametersValue(parameters, ID, QCStatement.defaultValues(ID));
            if (TYPE$2 in parameters) {
                this.type = getParametersValue(parameters, TYPE$2, QCStatement.defaultValues(TYPE$2));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ID:
                    return EMPTY_STRING;
                case TYPE$2:
                    return new Null();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case ID:
                    return (memberValue === EMPTY_STRING);
                case TYPE$2:
                    return (memberValue instanceof Null);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.id || EMPTY_STRING) }),
                    new Any({
                        name: (names.type || EMPTY_STRING),
                        optional: true
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, QC_STATEMENT_CLEAR_PROPS);
            const asn1 = compareSchema(schema, schema, QCStatement.schema({
                names: {
                    id: ID,
                    type: TYPE$2
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.id = asn1.result.id.valueBlock.toString();
            if (TYPE$2 in asn1.result)
                this.type = asn1.result.type;
        }
        toSchema() {
            const value = [
                new ObjectIdentifier({ value: this.id })
            ];
            if (TYPE$2 in this)
                value.push(this.type);
            return (new Sequence({
                value,
            }));
        }
        toJSON() {
            const object = {
                id: this.id
            };
            if (this.type) {
                object.type = this.type.toJSON();
            }
            return object;
        }
    }
    QCStatement.CLASS_NAME = "QCStatement";
    class QCStatements extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.values = getParametersValue(parameters, VALUES, QCStatements.defaultValues(VALUES));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VALUES:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VALUES:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.values || EMPTY_STRING),
                        value: QCStatement.schema(names.value || {})
                    }),
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, QC_STATEMENTS_CLEAR_PROPS);
            const asn1 = compareSchema(schema, schema, QCStatements.schema({
                names: {
                    values: VALUES
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.values = Array.from(asn1.result.values, element => new QCStatement({ schema: element }));
        }
        toSchema() {
            return (new Sequence({
                value: Array.from(this.values, o => o.toSchema())
            }));
        }
        toJSON() {
            return {
                values: Array.from(this.values, o => o.toJSON())
            };
        }
    }
    QCStatements.CLASS_NAME = "QCStatements";

    var _a;
    class ECNamedCurves {
        static register(name, id, size) {
            this.namedCurves[name.toLowerCase()] = this.namedCurves[id] = { name, id, size };
        }
        static find(nameOrId) {
            return this.namedCurves[nameOrId.toLowerCase()] || null;
        }
    }
    _a = ECNamedCurves;
    ECNamedCurves.namedCurves = {};
    (() => {
        _a.register("P-256", "1.2.840.10045.3.1.7", 32);
        _a.register("P-384", "1.3.132.0.34", 48);
        _a.register("P-521", "1.3.132.0.35", 66);
        _a.register("brainpoolP256r1", "1.3.36.3.3.2.8.1.1.7", 32);
        _a.register("brainpoolP384r1", "1.3.36.3.3.2.8.1.1.11", 48);
        _a.register("brainpoolP512r1", "1.3.36.3.3.2.8.1.1.13", 64);
    })();

    const X = "x";
    const Y = "y";
    const NAMED_CURVE$1 = "namedCurve";
    class ECPublicKey extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.x = getParametersValue(parameters, X, ECPublicKey.defaultValues(X));
            this.y = getParametersValue(parameters, Y, ECPublicKey.defaultValues(Y));
            this.namedCurve = getParametersValue(parameters, NAMED_CURVE$1, ECPublicKey.defaultValues(NAMED_CURVE$1));
            if (parameters.json) {
                this.fromJSON(parameters.json);
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case X:
                case Y:
                    return EMPTY_BUFFER;
                case NAMED_CURVE$1:
                    return EMPTY_STRING;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case X:
                case Y:
                    return memberValue instanceof ArrayBuffer &&
                        (isEqualBuffer(memberValue, ECPublicKey.defaultValues(memberName)));
                case NAMED_CURVE$1:
                    return typeof memberValue === "string" &&
                        memberValue === ECPublicKey.defaultValues(memberName);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema() {
            return new RawData();
        }
        fromSchema(schema1) {
            const view = BufferSourceConverter_1.toUint8Array(schema1);
            if (view[0] !== 0x04) {
                throw new Error("Object's schema was not verified against input data for ECPublicKey");
            }
            const namedCurve = ECNamedCurves.find(this.namedCurve);
            if (!namedCurve) {
                throw new Error(`Incorrect curve OID: ${this.namedCurve}`);
            }
            const coordinateLength = namedCurve.size;
            if (view.byteLength !== (coordinateLength * 2 + 1)) {
                throw new Error("Object's schema was not verified against input data for ECPublicKey");
            }
            this.namedCurve = namedCurve.name;
            this.x = view.slice(1, coordinateLength + 1).buffer;
            this.y = view.slice(1 + coordinateLength, coordinateLength * 2 + 1).buffer;
        }
        toSchema() {
            return new RawData({
                data: utilConcatBuf((new Uint8Array([0x04])).buffer, this.x, this.y)
            });
        }
        toJSON() {
            const namedCurve = ECNamedCurves.find(this.namedCurve);
            return {
                crv: namedCurve ? namedCurve.name : this.namedCurve,
                x: toBase64(arrayBufferToString(this.x), true, true, false),
                y: toBase64(arrayBufferToString(this.y), true, true, false)
            };
        }
        fromJSON(json) {
            ParameterError.assert("json", json, "crv", "x", "y");
            let coordinateLength = 0;
            const namedCurve = ECNamedCurves.find(json.crv);
            if (namedCurve) {
                this.namedCurve = namedCurve.id;
                coordinateLength = namedCurve.size;
            }
            const xConvertBuffer = stringToArrayBuffer(fromBase64(json.x, true));
            if (xConvertBuffer.byteLength < coordinateLength) {
                this.x = new ArrayBuffer(coordinateLength);
                const view = new Uint8Array(this.x);
                const convertBufferView = new Uint8Array(xConvertBuffer);
                view.set(convertBufferView, 1);
            }
            else {
                this.x = xConvertBuffer.slice(0, coordinateLength);
            }
            const yConvertBuffer = stringToArrayBuffer(fromBase64(json.y, true));
            if (yConvertBuffer.byteLength < coordinateLength) {
                this.y = new ArrayBuffer(coordinateLength);
                const view = new Uint8Array(this.y);
                const convertBufferView = new Uint8Array(yConvertBuffer);
                view.set(convertBufferView, 1);
            }
            else {
                this.y = yConvertBuffer.slice(0, coordinateLength);
            }
        }
    }
    ECPublicKey.CLASS_NAME = "ECPublicKey";

    const MODULUS$1 = "modulus";
    const PUBLIC_EXPONENT$1 = "publicExponent";
    const CLEAR_PROPS$1b = [MODULUS$1, PUBLIC_EXPONENT$1];
    class RSAPublicKey extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.modulus = getParametersValue(parameters, MODULUS$1, RSAPublicKey.defaultValues(MODULUS$1));
            this.publicExponent = getParametersValue(parameters, PUBLIC_EXPONENT$1, RSAPublicKey.defaultValues(PUBLIC_EXPONENT$1));
            if (parameters.json) {
                this.fromJSON(parameters.json);
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case MODULUS$1:
                    return new Integer();
                case PUBLIC_EXPONENT$1:
                    return new Integer();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.modulus || EMPTY_STRING) }),
                    new Integer({ name: (names.publicExponent || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1b);
            const asn1 = compareSchema(schema, schema, RSAPublicKey.schema({
                names: {
                    modulus: MODULUS$1,
                    publicExponent: PUBLIC_EXPONENT$1
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.modulus = asn1.result.modulus.convertFromDER(256);
            this.publicExponent = asn1.result.publicExponent;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    this.modulus.convertToDER(),
                    this.publicExponent
                ]
            }));
        }
        toJSON() {
            return {
                n: Convert_1.ToBase64Url(this.modulus.valueBlock.valueHexView),
                e: Convert_1.ToBase64Url(this.publicExponent.valueBlock.valueHexView),
            };
        }
        fromJSON(json) {
            ParameterError.assert("json", json, "n", "e");
            const array = stringToArrayBuffer(fromBase64(json.n, true));
            this.modulus = new Integer({ valueHex: array.slice(0, Math.pow(2, nearestPowerOf2(array.byteLength))) });
            this.publicExponent = new Integer({ valueHex: stringToArrayBuffer(fromBase64(json.e, true)).slice(0, 3) });
        }
    }
    RSAPublicKey.CLASS_NAME = "RSAPublicKey";

    const ALGORITHM$1 = "algorithm";
    const SUBJECT_PUBLIC_KEY = "subjectPublicKey";
    const CLEAR_PROPS$1a = [ALGORITHM$1, SUBJECT_PUBLIC_KEY];
    class PublicKeyInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.algorithm = getParametersValue(parameters, ALGORITHM$1, PublicKeyInfo.defaultValues(ALGORITHM$1));
            this.subjectPublicKey = getParametersValue(parameters, SUBJECT_PUBLIC_KEY, PublicKeyInfo.defaultValues(SUBJECT_PUBLIC_KEY));
            const parsedKey = getParametersValue(parameters, "parsedKey", null);
            if (parsedKey) {
                this.parsedKey = parsedKey;
            }
            if (parameters.json) {
                this.fromJSON(parameters.json);
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        get parsedKey() {
            if (this._parsedKey === undefined) {
                switch (this.algorithm.algorithmId) {
                    case "1.2.840.10045.2.1":
                        if ("algorithmParams" in this.algorithm) {
                            if (this.algorithm.algorithmParams.constructor.blockName() === ObjectIdentifier.blockName()) {
                                try {
                                    this._parsedKey = new ECPublicKey({
                                        namedCurve: this.algorithm.algorithmParams.valueBlock.toString(),
                                        schema: this.subjectPublicKey.valueBlock.valueHexView
                                    });
                                }
                                catch (ex) {
                                }
                            }
                        }
                        break;
                    case "1.2.840.113549.1.1.1":
                        {
                            const publicKeyASN1 = fromBER(this.subjectPublicKey.valueBlock.valueHexView);
                            if (publicKeyASN1.offset !== -1) {
                                try {
                                    this._parsedKey = new RSAPublicKey({ schema: publicKeyASN1.result });
                                }
                                catch (ex) {
                                }
                            }
                        }
                        break;
                }
                this._parsedKey || (this._parsedKey = null);
            }
            return this._parsedKey || undefined;
        }
        set parsedKey(value) {
            this._parsedKey = value;
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ALGORITHM$1:
                    return new AlgorithmIdentifier();
                case SUBJECT_PUBLIC_KEY:
                    return new BitString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    AlgorithmIdentifier.schema(names.algorithm || {}),
                    new BitString({ name: (names.subjectPublicKey || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1a);
            const asn1 = compareSchema(schema, schema, PublicKeyInfo.schema({
                names: {
                    algorithm: {
                        names: {
                            blockName: ALGORITHM$1
                        }
                    },
                    subjectPublicKey: SUBJECT_PUBLIC_KEY
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.algorithm = new AlgorithmIdentifier({ schema: asn1.result.algorithm });
            this.subjectPublicKey = asn1.result.subjectPublicKey;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    this.algorithm.toSchema(),
                    this.subjectPublicKey
                ]
            }));
        }
        toJSON() {
            if (!this.parsedKey) {
                return {
                    algorithm: this.algorithm.toJSON(),
                    subjectPublicKey: this.subjectPublicKey.toJSON(),
                };
            }
            const jwk = {};
            switch (this.algorithm.algorithmId) {
                case "1.2.840.10045.2.1":
                    jwk.kty = "EC";
                    break;
                case "1.2.840.113549.1.1.1":
                    jwk.kty = "RSA";
                    break;
            }
            const publicKeyJWK = this.parsedKey.toJSON();
            Object.assign(jwk, publicKeyJWK);
            return jwk;
        }
        fromJSON(json) {
            if ("kty" in json) {
                switch (json.kty.toUpperCase()) {
                    case "EC":
                        this.parsedKey = new ECPublicKey({ json });
                        this.algorithm = new AlgorithmIdentifier({
                            algorithmId: "1.2.840.10045.2.1",
                            algorithmParams: new ObjectIdentifier({ value: this.parsedKey.namedCurve })
                        });
                        break;
                    case "RSA":
                        this.parsedKey = new RSAPublicKey({ json });
                        this.algorithm = new AlgorithmIdentifier({
                            algorithmId: "1.2.840.113549.1.1.1",
                            algorithmParams: new Null()
                        });
                        break;
                    default:
                        throw new Error(`Invalid value for "kty" parameter: ${json.kty}`);
                }
                this.subjectPublicKey = new BitString({ valueHex: this.parsedKey.toSchema().toBER(false) });
            }
        }
        async importKey(publicKey, crypto = getCrypto(true)) {
            try {
                if (!publicKey) {
                    throw new Error("Need to provide publicKey input parameter");
                }
                const exportedKey = await crypto.exportKey("spki", publicKey);
                const asn1 = fromBER(exportedKey);
                try {
                    this.fromSchema(asn1.result);
                }
                catch (exception) {
                    throw new Error("Error during initializing object from schema");
                }
            }
            catch (e) {
                const message = e instanceof Error ? e.message : `${e}`;
                throw new Error(`Error during exporting public key: ${message}`);
            }
        }
    }
    PublicKeyInfo.CLASS_NAME = "PublicKeyInfo";

    const VERSION$l = "version";
    const PRIVATE_KEY$1 = "privateKey";
    const NAMED_CURVE = "namedCurve";
    const PUBLIC_KEY$1 = "publicKey";
    const CLEAR_PROPS$19 = [
        VERSION$l,
        PRIVATE_KEY$1,
        NAMED_CURVE,
        PUBLIC_KEY$1
    ];
    class ECPrivateKey extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$l, ECPrivateKey.defaultValues(VERSION$l));
            this.privateKey = getParametersValue(parameters, PRIVATE_KEY$1, ECPrivateKey.defaultValues(PRIVATE_KEY$1));
            if (NAMED_CURVE in parameters) {
                this.namedCurve = getParametersValue(parameters, NAMED_CURVE, ECPrivateKey.defaultValues(NAMED_CURVE));
            }
            if (PUBLIC_KEY$1 in parameters) {
                this.publicKey = getParametersValue(parameters, PUBLIC_KEY$1, ECPrivateKey.defaultValues(PUBLIC_KEY$1));
            }
            if (parameters.json) {
                this.fromJSON(parameters.json);
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$l:
                    return 1;
                case PRIVATE_KEY$1:
                    return new OctetString();
                case NAMED_CURVE:
                    return EMPTY_STRING;
                case PUBLIC_KEY$1:
                    return new ECPublicKey();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VERSION$l:
                    return (memberValue === ECPrivateKey.defaultValues(memberName));
                case PRIVATE_KEY$1:
                    return (memberValue.isEqual(ECPrivateKey.defaultValues(memberName)));
                case NAMED_CURVE:
                    return (memberValue === EMPTY_STRING);
                case PUBLIC_KEY$1:
                    return ((ECPublicKey.compareWithDefault(NAMED_CURVE, memberValue.namedCurve)) &&
                        (ECPublicKey.compareWithDefault("x", memberValue.x)) &&
                        (ECPublicKey.compareWithDefault("y", memberValue.y)));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.version || EMPTY_STRING) }),
                    new OctetString({ name: (names.privateKey || EMPTY_STRING) }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [
                            new ObjectIdentifier({ name: (names.namedCurve || EMPTY_STRING) })
                        ]
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [
                            new BitString({ name: (names.publicKey || EMPTY_STRING) })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$19);
            const asn1 = compareSchema(schema, schema, ECPrivateKey.schema({
                names: {
                    version: VERSION$l,
                    privateKey: PRIVATE_KEY$1,
                    namedCurve: NAMED_CURVE,
                    publicKey: PUBLIC_KEY$1
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result.version.valueBlock.valueDec;
            this.privateKey = asn1.result.privateKey;
            if (NAMED_CURVE in asn1.result) {
                this.namedCurve = asn1.result.namedCurve.valueBlock.toString();
            }
            if (PUBLIC_KEY$1 in asn1.result) {
                const publicKeyData = { schema: asn1.result.publicKey.valueBlock.valueHex };
                if (NAMED_CURVE in this) {
                    publicKeyData.namedCurve = this.namedCurve;
                }
                this.publicKey = new ECPublicKey(publicKeyData);
            }
        }
        toSchema() {
            const outputArray = [
                new Integer({ value: this.version }),
                this.privateKey
            ];
            if (this.namedCurve) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new ObjectIdentifier({ value: this.namedCurve })
                    ]
                }));
            }
            if (this.publicKey) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [
                        new BitString({ valueHex: this.publicKey.toSchema().toBER(false) })
                    ]
                }));
            }
            return new Sequence({
                value: outputArray
            });
        }
        toJSON() {
            if (!this.namedCurve || ECPrivateKey.compareWithDefault(NAMED_CURVE, this.namedCurve)) {
                throw new Error("Not enough information for making JSON: absent \"namedCurve\" value");
            }
            const curve = ECNamedCurves.find(this.namedCurve);
            const privateKeyJSON = {
                crv: curve ? curve.name : this.namedCurve,
                d: Convert_1.ToBase64Url(this.privateKey.valueBlock.valueHexView),
            };
            if (this.publicKey) {
                const publicKeyJSON = this.publicKey.toJSON();
                privateKeyJSON.x = publicKeyJSON.x;
                privateKeyJSON.y = publicKeyJSON.y;
            }
            return privateKeyJSON;
        }
        fromJSON(json) {
            ParameterError.assert("json", json, "crv", "d");
            let coordinateLength = 0;
            const curve = ECNamedCurves.find(json.crv);
            if (curve) {
                this.namedCurve = curve.id;
                coordinateLength = curve.size;
            }
            const convertBuffer = Convert_1.FromBase64Url(json.d);
            if (convertBuffer.byteLength < coordinateLength) {
                const buffer = new ArrayBuffer(coordinateLength);
                const view = new Uint8Array(buffer);
                const convertBufferView = new Uint8Array(convertBuffer);
                view.set(convertBufferView, 1);
                this.privateKey = new OctetString({ valueHex: buffer });
            }
            else {
                this.privateKey = new OctetString({ valueHex: convertBuffer.slice(0, coordinateLength) });
            }
            if (json.x && json.y) {
                this.publicKey = new ECPublicKey({ json });
            }
        }
    }
    ECPrivateKey.CLASS_NAME = "ECPrivateKey";

    const PRIME = "prime";
    const EXPONENT = "exponent";
    const COEFFICIENT$1 = "coefficient";
    const CLEAR_PROPS$18 = [
        PRIME,
        EXPONENT,
        COEFFICIENT$1,
    ];
    class OtherPrimeInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.prime = getParametersValue(parameters, PRIME, OtherPrimeInfo.defaultValues(PRIME));
            this.exponent = getParametersValue(parameters, EXPONENT, OtherPrimeInfo.defaultValues(EXPONENT));
            this.coefficient = getParametersValue(parameters, COEFFICIENT$1, OtherPrimeInfo.defaultValues(COEFFICIENT$1));
            if (parameters.json) {
                this.fromJSON(parameters.json);
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case PRIME:
                    return new Integer();
                case EXPONENT:
                    return new Integer();
                case COEFFICIENT$1:
                    return new Integer();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.prime || EMPTY_STRING) }),
                    new Integer({ name: (names.exponent || EMPTY_STRING) }),
                    new Integer({ name: (names.coefficient || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$18);
            const asn1 = compareSchema(schema, schema, OtherPrimeInfo.schema({
                names: {
                    prime: PRIME,
                    exponent: EXPONENT,
                    coefficient: COEFFICIENT$1
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.prime = asn1.result.prime.convertFromDER();
            this.exponent = asn1.result.exponent.convertFromDER();
            this.coefficient = asn1.result.coefficient.convertFromDER();
        }
        toSchema() {
            return (new Sequence({
                value: [
                    this.prime.convertToDER(),
                    this.exponent.convertToDER(),
                    this.coefficient.convertToDER()
                ]
            }));
        }
        toJSON() {
            return {
                r: Convert_1.ToBase64Url(this.prime.valueBlock.valueHexView),
                d: Convert_1.ToBase64Url(this.exponent.valueBlock.valueHexView),
                t: Convert_1.ToBase64Url(this.coefficient.valueBlock.valueHexView),
            };
        }
        fromJSON(json) {
            ParameterError.assert("json", json, "r", "d", "r");
            this.prime = new Integer({ valueHex: Convert_1.FromBase64Url(json.r) });
            this.exponent = new Integer({ valueHex: Convert_1.FromBase64Url(json.d) });
            this.coefficient = new Integer({ valueHex: Convert_1.FromBase64Url(json.t) });
        }
    }
    OtherPrimeInfo.CLASS_NAME = "OtherPrimeInfo";

    const VERSION$k = "version";
    const MODULUS = "modulus";
    const PUBLIC_EXPONENT = "publicExponent";
    const PRIVATE_EXPONENT = "privateExponent";
    const PRIME1 = "prime1";
    const PRIME2 = "prime2";
    const EXPONENT1 = "exponent1";
    const EXPONENT2 = "exponent2";
    const COEFFICIENT = "coefficient";
    const OTHER_PRIME_INFOS = "otherPrimeInfos";
    const CLEAR_PROPS$17 = [
        VERSION$k,
        MODULUS,
        PUBLIC_EXPONENT,
        PRIVATE_EXPONENT,
        PRIME1,
        PRIME2,
        EXPONENT1,
        EXPONENT2,
        COEFFICIENT,
        OTHER_PRIME_INFOS
    ];
    class RSAPrivateKey extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$k, RSAPrivateKey.defaultValues(VERSION$k));
            this.modulus = getParametersValue(parameters, MODULUS, RSAPrivateKey.defaultValues(MODULUS));
            this.publicExponent = getParametersValue(parameters, PUBLIC_EXPONENT, RSAPrivateKey.defaultValues(PUBLIC_EXPONENT));
            this.privateExponent = getParametersValue(parameters, PRIVATE_EXPONENT, RSAPrivateKey.defaultValues(PRIVATE_EXPONENT));
            this.prime1 = getParametersValue(parameters, PRIME1, RSAPrivateKey.defaultValues(PRIME1));
            this.prime2 = getParametersValue(parameters, PRIME2, RSAPrivateKey.defaultValues(PRIME2));
            this.exponent1 = getParametersValue(parameters, EXPONENT1, RSAPrivateKey.defaultValues(EXPONENT1));
            this.exponent2 = getParametersValue(parameters, EXPONENT2, RSAPrivateKey.defaultValues(EXPONENT2));
            this.coefficient = getParametersValue(parameters, COEFFICIENT, RSAPrivateKey.defaultValues(COEFFICIENT));
            if (OTHER_PRIME_INFOS in parameters) {
                this.otherPrimeInfos = getParametersValue(parameters, OTHER_PRIME_INFOS, RSAPrivateKey.defaultValues(OTHER_PRIME_INFOS));
            }
            if (parameters.json) {
                this.fromJSON(parameters.json);
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$k:
                    return 0;
                case MODULUS:
                    return new Integer();
                case PUBLIC_EXPONENT:
                    return new Integer();
                case PRIVATE_EXPONENT:
                    return new Integer();
                case PRIME1:
                    return new Integer();
                case PRIME2:
                    return new Integer();
                case EXPONENT1:
                    return new Integer();
                case EXPONENT2:
                    return new Integer();
                case COEFFICIENT:
                    return new Integer();
                case OTHER_PRIME_INFOS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.version || EMPTY_STRING) }),
                    new Integer({ name: (names.modulus || EMPTY_STRING) }),
                    new Integer({ name: (names.publicExponent || EMPTY_STRING) }),
                    new Integer({ name: (names.privateExponent || EMPTY_STRING) }),
                    new Integer({ name: (names.prime1 || EMPTY_STRING) }),
                    new Integer({ name: (names.prime2 || EMPTY_STRING) }),
                    new Integer({ name: (names.exponent1 || EMPTY_STRING) }),
                    new Integer({ name: (names.exponent2 || EMPTY_STRING) }),
                    new Integer({ name: (names.coefficient || EMPTY_STRING) }),
                    new Sequence({
                        optional: true,
                        value: [
                            new Repeated({
                                name: (names.otherPrimeInfosName || EMPTY_STRING),
                                value: OtherPrimeInfo.schema(names.otherPrimeInfo || {})
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$17);
            const asn1 = compareSchema(schema, schema, RSAPrivateKey.schema({
                names: {
                    version: VERSION$k,
                    modulus: MODULUS,
                    publicExponent: PUBLIC_EXPONENT,
                    privateExponent: PRIVATE_EXPONENT,
                    prime1: PRIME1,
                    prime2: PRIME2,
                    exponent1: EXPONENT1,
                    exponent2: EXPONENT2,
                    coefficient: COEFFICIENT,
                    otherPrimeInfo: {
                        names: {
                            blockName: OTHER_PRIME_INFOS
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result.version.valueBlock.valueDec;
            this.modulus = asn1.result.modulus.convertFromDER(256);
            this.publicExponent = asn1.result.publicExponent;
            this.privateExponent = asn1.result.privateExponent.convertFromDER(256);
            this.prime1 = asn1.result.prime1.convertFromDER(128);
            this.prime2 = asn1.result.prime2.convertFromDER(128);
            this.exponent1 = asn1.result.exponent1.convertFromDER(128);
            this.exponent2 = asn1.result.exponent2.convertFromDER(128);
            this.coefficient = asn1.result.coefficient.convertFromDER(128);
            if (OTHER_PRIME_INFOS in asn1.result)
                this.otherPrimeInfos = Array.from(asn1.result.otherPrimeInfos, element => new OtherPrimeInfo({ schema: element }));
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new Integer({ value: this.version }));
            outputArray.push(this.modulus.convertToDER());
            outputArray.push(this.publicExponent);
            outputArray.push(this.privateExponent.convertToDER());
            outputArray.push(this.prime1.convertToDER());
            outputArray.push(this.prime2.convertToDER());
            outputArray.push(this.exponent1.convertToDER());
            outputArray.push(this.exponent2.convertToDER());
            outputArray.push(this.coefficient.convertToDER());
            if (this.otherPrimeInfos) {
                outputArray.push(new Sequence({
                    value: Array.from(this.otherPrimeInfos, o => o.toSchema())
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const jwk = {
                n: Convert_1.ToBase64Url(this.modulus.valueBlock.valueHexView),
                e: Convert_1.ToBase64Url(this.publicExponent.valueBlock.valueHexView),
                d: Convert_1.ToBase64Url(this.privateExponent.valueBlock.valueHexView),
                p: Convert_1.ToBase64Url(this.prime1.valueBlock.valueHexView),
                q: Convert_1.ToBase64Url(this.prime2.valueBlock.valueHexView),
                dp: Convert_1.ToBase64Url(this.exponent1.valueBlock.valueHexView),
                dq: Convert_1.ToBase64Url(this.exponent2.valueBlock.valueHexView),
                qi: Convert_1.ToBase64Url(this.coefficient.valueBlock.valueHexView),
            };
            if (this.otherPrimeInfos) {
                jwk.oth = Array.from(this.otherPrimeInfos, o => o.toJSON());
            }
            return jwk;
        }
        fromJSON(json) {
            ParameterError.assert("json", json, "n", "e", "d", "p", "q", "dp", "dq", "qi");
            this.modulus = new Integer({ valueHex: Convert_1.FromBase64Url(json.n) });
            this.publicExponent = new Integer({ valueHex: Convert_1.FromBase64Url(json.e) });
            this.privateExponent = new Integer({ valueHex: Convert_1.FromBase64Url(json.d) });
            this.prime1 = new Integer({ valueHex: Convert_1.FromBase64Url(json.p) });
            this.prime2 = new Integer({ valueHex: Convert_1.FromBase64Url(json.q) });
            this.exponent1 = new Integer({ valueHex: Convert_1.FromBase64Url(json.dp) });
            this.exponent2 = new Integer({ valueHex: Convert_1.FromBase64Url(json.dq) });
            this.coefficient = new Integer({ valueHex: Convert_1.FromBase64Url(json.qi) });
            if (json.oth) {
                this.otherPrimeInfos = Array.from(json.oth, (element) => new OtherPrimeInfo({ json: element }));
            }
        }
    }
    RSAPrivateKey.CLASS_NAME = "RSAPrivateKey";

    const VERSION$j = "version";
    const PRIVATE_KEY_ALGORITHM = "privateKeyAlgorithm";
    const PRIVATE_KEY = "privateKey";
    const ATTRIBUTES$5 = "attributes";
    const PARSED_KEY = "parsedKey";
    const CLEAR_PROPS$16 = [
        VERSION$j,
        PRIVATE_KEY_ALGORITHM,
        PRIVATE_KEY,
        ATTRIBUTES$5
    ];
    class PrivateKeyInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$j, PrivateKeyInfo.defaultValues(VERSION$j));
            this.privateKeyAlgorithm = getParametersValue(parameters, PRIVATE_KEY_ALGORITHM, PrivateKeyInfo.defaultValues(PRIVATE_KEY_ALGORITHM));
            this.privateKey = getParametersValue(parameters, PRIVATE_KEY, PrivateKeyInfo.defaultValues(PRIVATE_KEY));
            if (ATTRIBUTES$5 in parameters) {
                this.attributes = getParametersValue(parameters, ATTRIBUTES$5, PrivateKeyInfo.defaultValues(ATTRIBUTES$5));
            }
            if (PARSED_KEY in parameters) {
                this.parsedKey = getParametersValue(parameters, PARSED_KEY, PrivateKeyInfo.defaultValues(PARSED_KEY));
            }
            if (parameters.json) {
                this.fromJSON(parameters.json);
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$j:
                    return 0;
                case PRIVATE_KEY_ALGORITHM:
                    return new AlgorithmIdentifier();
                case PRIVATE_KEY:
                    return new OctetString();
                case ATTRIBUTES$5:
                    return [];
                case PARSED_KEY:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.version || EMPTY_STRING) }),
                    AlgorithmIdentifier.schema(names.privateKeyAlgorithm || {}),
                    new OctetString({ name: (names.privateKey || EMPTY_STRING) }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [
                            new Repeated({
                                name: (names.attributes || EMPTY_STRING),
                                value: Attribute.schema()
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$16);
            const asn1 = compareSchema(schema, schema, PrivateKeyInfo.schema({
                names: {
                    version: VERSION$j,
                    privateKeyAlgorithm: {
                        names: {
                            blockName: PRIVATE_KEY_ALGORITHM
                        }
                    },
                    privateKey: PRIVATE_KEY,
                    attributes: ATTRIBUTES$5
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result.version.valueBlock.valueDec;
            this.privateKeyAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.privateKeyAlgorithm });
            this.privateKey = asn1.result.privateKey;
            if (ATTRIBUTES$5 in asn1.result)
                this.attributes = Array.from(asn1.result.attributes, element => new Attribute({ schema: element }));
            switch (this.privateKeyAlgorithm.algorithmId) {
                case "1.2.840.113549.1.1.1":
                    {
                        const privateKeyASN1 = fromBER(this.privateKey.valueBlock.valueHexView);
                        if (privateKeyASN1.offset !== -1)
                            this.parsedKey = new RSAPrivateKey({ schema: privateKeyASN1.result });
                    }
                    break;
                case "1.2.840.10045.2.1":
                    if ("algorithmParams" in this.privateKeyAlgorithm) {
                        if (this.privateKeyAlgorithm.algorithmParams instanceof ObjectIdentifier) {
                            const privateKeyASN1 = fromBER(this.privateKey.valueBlock.valueHexView);
                            if (privateKeyASN1.offset !== -1) {
                                this.parsedKey = new ECPrivateKey({
                                    namedCurve: this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),
                                    schema: privateKeyASN1.result
                                });
                            }
                        }
                    }
                    break;
            }
        }
        toSchema() {
            const outputArray = [
                new Integer({ value: this.version }),
                this.privateKeyAlgorithm.toSchema(),
                this.privateKey
            ];
            if (this.attributes) {
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: Array.from(this.attributes, o => o.toSchema())
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            if (!this.parsedKey) {
                const object = {
                    version: this.version,
                    privateKeyAlgorithm: this.privateKeyAlgorithm.toJSON(),
                    privateKey: this.privateKey.toJSON(),
                };
                if (this.attributes) {
                    object.attributes = Array.from(this.attributes, o => o.toJSON());
                }
                return object;
            }
            const jwk = {};
            switch (this.privateKeyAlgorithm.algorithmId) {
                case "1.2.840.10045.2.1":
                    jwk.kty = "EC";
                    break;
                case "1.2.840.113549.1.1.1":
                    jwk.kty = "RSA";
                    break;
            }
            const publicKeyJWK = this.parsedKey.toJSON();
            Object.assign(jwk, publicKeyJWK);
            return jwk;
        }
        fromJSON(json) {
            if ("kty" in json) {
                switch (json.kty.toUpperCase()) {
                    case "EC":
                        this.parsedKey = new ECPrivateKey({ json });
                        this.privateKeyAlgorithm = new AlgorithmIdentifier({
                            algorithmId: "1.2.840.10045.2.1",
                            algorithmParams: new ObjectIdentifier({ value: this.parsedKey.namedCurve })
                        });
                        break;
                    case "RSA":
                        this.parsedKey = new RSAPrivateKey({ json });
                        this.privateKeyAlgorithm = new AlgorithmIdentifier({
                            algorithmId: "1.2.840.113549.1.1.1",
                            algorithmParams: new Null()
                        });
                        break;
                    default:
                        throw new Error(`Invalid value for "kty" parameter: ${json.kty}`);
                }
                this.privateKey = new OctetString({ valueHex: this.parsedKey.toSchema().toBER(false) });
            }
        }
    }
    PrivateKeyInfo.CLASS_NAME = "PrivateKeyInfo";

    const CONTENT_TYPE$1 = "contentType";
    const CONTENT_ENCRYPTION_ALGORITHM = "contentEncryptionAlgorithm";
    const ENCRYPTED_CONTENT = "encryptedContent";
    const CLEAR_PROPS$15 = [
        CONTENT_TYPE$1,
        CONTENT_ENCRYPTION_ALGORITHM,
        ENCRYPTED_CONTENT,
    ];
    class EncryptedContentInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.contentType = getParametersValue(parameters, CONTENT_TYPE$1, EncryptedContentInfo.defaultValues(CONTENT_TYPE$1));
            this.contentEncryptionAlgorithm = getParametersValue(parameters, CONTENT_ENCRYPTION_ALGORITHM, EncryptedContentInfo.defaultValues(CONTENT_ENCRYPTION_ALGORITHM));
            if (ENCRYPTED_CONTENT in parameters && parameters.encryptedContent) {
                this.encryptedContent = parameters.encryptedContent;
                if ((this.encryptedContent.idBlock.tagClass === 1) &&
                    (this.encryptedContent.idBlock.tagNumber === 4)) {
                    if (this.encryptedContent.idBlock.isConstructed === false) {
                        const constrString = new OctetString({
                            idBlock: { isConstructed: true },
                            isConstructed: true
                        });
                        let offset = 0;
                        const valueHex = this.encryptedContent.valueBlock.valueHexView.slice().buffer;
                        let length = valueHex.byteLength;
                        const pieceSize = 1024;
                        while (length > 0) {
                            const pieceView = new Uint8Array(valueHex, offset, ((offset + pieceSize) > valueHex.byteLength) ? (valueHex.byteLength - offset) : pieceSize);
                            const _array = new ArrayBuffer(pieceView.length);
                            const _view = new Uint8Array(_array);
                            for (let i = 0; i < _view.length; i++)
                                _view[i] = pieceView[i];
                            constrString.valueBlock.value.push(new OctetString({ valueHex: _array }));
                            length -= pieceView.length;
                            offset += pieceView.length;
                        }
                        this.encryptedContent = constrString;
                    }
                }
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case CONTENT_TYPE$1:
                    return EMPTY_STRING;
                case CONTENT_ENCRYPTION_ALGORITHM:
                    return new AlgorithmIdentifier();
                case ENCRYPTED_CONTENT:
                    return new OctetString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case CONTENT_TYPE$1:
                    return (memberValue === EMPTY_STRING);
                case CONTENT_ENCRYPTION_ALGORITHM:
                    return ((memberValue.algorithmId === EMPTY_STRING) && (("algorithmParams" in memberValue) === false));
                case ENCRYPTED_CONTENT:
                    return (memberValue.isEqual(EncryptedContentInfo.defaultValues(ENCRYPTED_CONTENT)));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.contentType || EMPTY_STRING) }),
                    AlgorithmIdentifier.schema(names.contentEncryptionAlgorithm || {}),
                    new Choice({
                        value: [
                            new Constructed({
                                name: (names.encryptedContent || EMPTY_STRING),
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 0
                                },
                                value: [
                                    new Repeated({
                                        value: new OctetString()
                                    })
                                ]
                            }),
                            new Primitive({
                                name: (names.encryptedContent || EMPTY_STRING),
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 0
                                }
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$15);
            const asn1 = compareSchema(schema, schema, EncryptedContentInfo.schema({
                names: {
                    contentType: CONTENT_TYPE$1,
                    contentEncryptionAlgorithm: {
                        names: {
                            blockName: CONTENT_ENCRYPTION_ALGORITHM
                        }
                    },
                    encryptedContent: ENCRYPTED_CONTENT
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.contentType = asn1.result.contentType.valueBlock.toString();
            this.contentEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.contentEncryptionAlgorithm });
            if (ENCRYPTED_CONTENT in asn1.result) {
                this.encryptedContent = asn1.result.encryptedContent;
                this.encryptedContent.idBlock.tagClass = 1;
                this.encryptedContent.idBlock.tagNumber = 4;
            }
        }
        toSchema() {
            const sequenceLengthBlock = {
                isIndefiniteForm: false
            };
            const outputArray = [];
            outputArray.push(new ObjectIdentifier({ value: this.contentType }));
            outputArray.push(this.contentEncryptionAlgorithm.toSchema());
            if (this.encryptedContent) {
                sequenceLengthBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;
                const encryptedValue = this.encryptedContent;
                encryptedValue.idBlock.tagClass = 3;
                encryptedValue.idBlock.tagNumber = 0;
                encryptedValue.lenBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;
                outputArray.push(encryptedValue);
            }
            return (new Sequence({
                lenBlock: sequenceLengthBlock,
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                contentType: this.contentType,
                contentEncryptionAlgorithm: this.contentEncryptionAlgorithm.toJSON()
            };
            if (this.encryptedContent) {
                res.encryptedContent = this.encryptedContent.toJSON();
            }
            return res;
        }
        getEncryptedContent() {
            if (!this.encryptedContent) {
                throw new Error("Parameter 'encryptedContent' is undefined");
            }
            return OctetString.prototype.getValue.call(this.encryptedContent);
        }
    }
    EncryptedContentInfo.CLASS_NAME = "EncryptedContentInfo";

    const HASH_ALGORITHM$4 = "hashAlgorithm";
    const MASK_GEN_ALGORITHM$1 = "maskGenAlgorithm";
    const SALT_LENGTH = "saltLength";
    const TRAILER_FIELD = "trailerField";
    const CLEAR_PROPS$14 = [
        HASH_ALGORITHM$4,
        MASK_GEN_ALGORITHM$1,
        SALT_LENGTH,
        TRAILER_FIELD
    ];
    class RSASSAPSSParams extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM$4, RSASSAPSSParams.defaultValues(HASH_ALGORITHM$4));
            this.maskGenAlgorithm = getParametersValue(parameters, MASK_GEN_ALGORITHM$1, RSASSAPSSParams.defaultValues(MASK_GEN_ALGORITHM$1));
            this.saltLength = getParametersValue(parameters, SALT_LENGTH, RSASSAPSSParams.defaultValues(SALT_LENGTH));
            this.trailerField = getParametersValue(parameters, TRAILER_FIELD, RSASSAPSSParams.defaultValues(TRAILER_FIELD));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case HASH_ALGORITHM$4:
                    return new AlgorithmIdentifier({
                        algorithmId: "1.3.14.3.2.26",
                        algorithmParams: new Null()
                    });
                case MASK_GEN_ALGORITHM$1:
                    return new AlgorithmIdentifier({
                        algorithmId: "1.2.840.113549.1.1.8",
                        algorithmParams: (new AlgorithmIdentifier({
                            algorithmId: "1.3.14.3.2.26",
                            algorithmParams: new Null()
                        })).toSchema()
                    });
                case SALT_LENGTH:
                    return 20;
                case TRAILER_FIELD:
                    return 1;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        optional: true,
                        value: [AlgorithmIdentifier.schema(names.hashAlgorithm || {})]
                    }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        optional: true,
                        value: [AlgorithmIdentifier.schema(names.maskGenAlgorithm || {})]
                    }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 2
                        },
                        optional: true,
                        value: [new Integer({ name: (names.saltLength || EMPTY_STRING) })]
                    }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 3
                        },
                        optional: true,
                        value: [new Integer({ name: (names.trailerField || EMPTY_STRING) })]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$14);
            const asn1 = compareSchema(schema, schema, RSASSAPSSParams.schema({
                names: {
                    hashAlgorithm: {
                        names: {
                            blockName: HASH_ALGORITHM$4
                        }
                    },
                    maskGenAlgorithm: {
                        names: {
                            blockName: MASK_GEN_ALGORITHM$1
                        }
                    },
                    saltLength: SALT_LENGTH,
                    trailerField: TRAILER_FIELD
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (HASH_ALGORITHM$4 in asn1.result)
                this.hashAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.hashAlgorithm });
            if (MASK_GEN_ALGORITHM$1 in asn1.result)
                this.maskGenAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.maskGenAlgorithm });
            if (SALT_LENGTH in asn1.result)
                this.saltLength = asn1.result.saltLength.valueBlock.valueDec;
            if (TRAILER_FIELD in asn1.result)
                this.trailerField = asn1.result.trailerField.valueBlock.valueDec;
        }
        toSchema() {
            const outputArray = [];
            if (!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues(HASH_ALGORITHM$4))) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [this.hashAlgorithm.toSchema()]
                }));
            }
            if (!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues(MASK_GEN_ALGORITHM$1))) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [this.maskGenAlgorithm.toSchema()]
                }));
            }
            if (this.saltLength !== RSASSAPSSParams.defaultValues(SALT_LENGTH)) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    value: [new Integer({ value: this.saltLength })]
                }));
            }
            if (this.trailerField !== RSASSAPSSParams.defaultValues(TRAILER_FIELD)) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 3
                    },
                    value: [new Integer({ value: this.trailerField })]
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {};
            if (!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues(HASH_ALGORITHM$4))) {
                res.hashAlgorithm = this.hashAlgorithm.toJSON();
            }
            if (!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues(MASK_GEN_ALGORITHM$1))) {
                res.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();
            }
            if (this.saltLength !== RSASSAPSSParams.defaultValues(SALT_LENGTH)) {
                res.saltLength = this.saltLength;
            }
            if (this.trailerField !== RSASSAPSSParams.defaultValues(TRAILER_FIELD)) {
                res.trailerField = this.trailerField;
            }
            return res;
        }
    }
    RSASSAPSSParams.CLASS_NAME = "RSASSAPSSParams";

    const SALT = "salt";
    const ITERATION_COUNT = "iterationCount";
    const KEY_LENGTH = "keyLength";
    const PRF = "prf";
    const CLEAR_PROPS$13 = [
        SALT,
        ITERATION_COUNT,
        KEY_LENGTH,
        PRF
    ];
    class PBKDF2Params extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.salt = getParametersValue(parameters, SALT, PBKDF2Params.defaultValues(SALT));
            this.iterationCount = getParametersValue(parameters, ITERATION_COUNT, PBKDF2Params.defaultValues(ITERATION_COUNT));
            if (KEY_LENGTH in parameters) {
                this.keyLength = getParametersValue(parameters, KEY_LENGTH, PBKDF2Params.defaultValues(KEY_LENGTH));
            }
            if (PRF in parameters) {
                this.prf = getParametersValue(parameters, PRF, PBKDF2Params.defaultValues(PRF));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case SALT:
                    return {};
                case ITERATION_COUNT:
                    return (-1);
                case KEY_LENGTH:
                    return 0;
                case PRF:
                    return new AlgorithmIdentifier({
                        algorithmId: "1.3.14.3.2.26",
                        algorithmParams: new Null()
                    });
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Choice({
                        value: [
                            new OctetString({ name: (names.saltPrimitive || EMPTY_STRING) }),
                            AlgorithmIdentifier.schema(names.saltConstructed || {})
                        ]
                    }),
                    new Integer({ name: (names.iterationCount || EMPTY_STRING) }),
                    new Integer({
                        name: (names.keyLength || EMPTY_STRING),
                        optional: true
                    }),
                    AlgorithmIdentifier.schema(names.prf || {
                        names: {
                            optional: true
                        }
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$13);
            const asn1 = compareSchema(schema, schema, PBKDF2Params.schema({
                names: {
                    saltPrimitive: SALT,
                    saltConstructed: {
                        names: {
                            blockName: SALT
                        }
                    },
                    iterationCount: ITERATION_COUNT,
                    keyLength: KEY_LENGTH,
                    prf: {
                        names: {
                            blockName: PRF,
                            optional: true
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.salt = asn1.result.salt;
            this.iterationCount = asn1.result.iterationCount.valueBlock.valueDec;
            if (KEY_LENGTH in asn1.result)
                this.keyLength = asn1.result.keyLength.valueBlock.valueDec;
            if (PRF in asn1.result)
                this.prf = new AlgorithmIdentifier({ schema: asn1.result.prf });
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(this.salt);
            outputArray.push(new Integer({ value: this.iterationCount }));
            if (KEY_LENGTH in this) {
                if (PBKDF2Params.defaultValues(KEY_LENGTH) !== this.keyLength)
                    outputArray.push(new Integer({ value: this.keyLength }));
            }
            if (this.prf) {
                if (PBKDF2Params.defaultValues(PRF).isEqual(this.prf) === false)
                    outputArray.push(this.prf.toSchema());
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                salt: this.salt.toJSON(),
                iterationCount: this.iterationCount
            };
            if (KEY_LENGTH in this) {
                if (PBKDF2Params.defaultValues(KEY_LENGTH) !== this.keyLength)
                    res.keyLength = this.keyLength;
            }
            if (this.prf) {
                if (PBKDF2Params.defaultValues(PRF).isEqual(this.prf) === false)
                    res.prf = this.prf.toJSON();
            }
            return res;
        }
    }
    PBKDF2Params.CLASS_NAME = "PBKDF2Params";

    const KEY_DERIVATION_FUNC = "keyDerivationFunc";
    const ENCRYPTION_SCHEME = "encryptionScheme";
    const CLEAR_PROPS$12 = [
        KEY_DERIVATION_FUNC,
        ENCRYPTION_SCHEME
    ];
    class PBES2Params extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.keyDerivationFunc = getParametersValue(parameters, KEY_DERIVATION_FUNC, PBES2Params.defaultValues(KEY_DERIVATION_FUNC));
            this.encryptionScheme = getParametersValue(parameters, ENCRYPTION_SCHEME, PBES2Params.defaultValues(ENCRYPTION_SCHEME));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case KEY_DERIVATION_FUNC:
                    return new AlgorithmIdentifier();
                case ENCRYPTION_SCHEME:
                    return new AlgorithmIdentifier();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    AlgorithmIdentifier.schema(names.keyDerivationFunc || {}),
                    AlgorithmIdentifier.schema(names.encryptionScheme || {})
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$12);
            const asn1 = compareSchema(schema, schema, PBES2Params.schema({
                names: {
                    keyDerivationFunc: {
                        names: {
                            blockName: KEY_DERIVATION_FUNC
                        }
                    },
                    encryptionScheme: {
                        names: {
                            blockName: ENCRYPTION_SCHEME
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.keyDerivationFunc = new AlgorithmIdentifier({ schema: asn1.result.keyDerivationFunc });
            this.encryptionScheme = new AlgorithmIdentifier({ schema: asn1.result.encryptionScheme });
        }
        toSchema() {
            return (new Sequence({
                value: [
                    this.keyDerivationFunc.toSchema(),
                    this.encryptionScheme.toSchema()
                ]
            }));
        }
        toJSON() {
            return {
                keyDerivationFunc: this.keyDerivationFunc.toJSON(),
                encryptionScheme: this.encryptionScheme.toJSON()
            };
        }
    }
    PBES2Params.CLASS_NAME = "PBES2Params";

    class AbstractCryptoEngine {
        constructor(parameters) {
            this.crypto = parameters.crypto;
            this.subtle = "webkitSubtle" in parameters.crypto
                ? parameters.crypto.webkitSubtle
                : parameters.crypto.subtle;
            this.name = getParametersValue(parameters, "name", EMPTY_STRING);
        }
        async encrypt(...args) {
            return this.subtle.encrypt(...args);
        }
        async decrypt(...args) {
            return this.subtle.decrypt(...args);
        }
        sign(...args) {
            return this.subtle.sign(...args);
        }
        async verify(...args) {
            return this.subtle.verify(...args);
        }
        async digest(...args) {
            return this.subtle.digest(...args);
        }
        async generateKey(...args) {
            return this.subtle.generateKey(...args);
        }
        async deriveKey(...args) {
            return this.subtle.deriveKey(...args);
        }
        async deriveBits(...args) {
            return this.subtle.deriveBits(...args);
        }
        async wrapKey(...args) {
            return this.subtle.wrapKey(...args);
        }
        async unwrapKey(...args) {
            return this.subtle.unwrapKey(...args);
        }
        exportKey(...args) {
            return this.subtle.exportKey(...args);
        }
        importKey(...args) {
            return this.subtle.importKey(...args);
        }
        getRandomValues(array) {
            return this.crypto.getRandomValues(array);
        }
    }

    async function makePKCS12B2Key(cryptoEngine, hashAlgorithm, keyLength, password, salt, iterationCount) {
        let u;
        let v;
        const result = [];
        switch (hashAlgorithm.toUpperCase()) {
            case "SHA-1":
                u = 20;
                v = 64;
                break;
            case "SHA-256":
                u = 32;
                v = 64;
                break;
            case "SHA-384":
                u = 48;
                v = 128;
                break;
            case "SHA-512":
                u = 64;
                v = 128;
                break;
            default:
                throw new Error("Unsupported hashing algorithm");
        }
        const passwordViewInitial = new Uint8Array(password);
        const passwordTransformed = new ArrayBuffer((password.byteLength * 2) + 2);
        const passwordTransformedView = new Uint8Array(passwordTransformed);
        for (let i = 0; i < passwordViewInitial.length; i++) {
            passwordTransformedView[i * 2] = 0x00;
            passwordTransformedView[i * 2 + 1] = passwordViewInitial[i];
        }
        passwordTransformedView[passwordTransformedView.length - 2] = 0x00;
        passwordTransformedView[passwordTransformedView.length - 1] = 0x00;
        password = passwordTransformed.slice(0);
        const D = new ArrayBuffer(v);
        const dView = new Uint8Array(D);
        for (let i = 0; i < D.byteLength; i++)
            dView[i] = 3;
        const saltLength = salt.byteLength;
        const sLen = v * Math.ceil(saltLength / v);
        const S = new ArrayBuffer(sLen);
        const sView = new Uint8Array(S);
        const saltView = new Uint8Array(salt);
        for (let i = 0; i < sLen; i++)
            sView[i] = saltView[i % saltLength];
        const passwordLength = password.byteLength;
        const pLen = v * Math.ceil(passwordLength / v);
        const P = new ArrayBuffer(pLen);
        const pView = new Uint8Array(P);
        const passwordView = new Uint8Array(password);
        for (let i = 0; i < pLen; i++)
            pView[i] = passwordView[i % passwordLength];
        const sPlusPLength = S.byteLength + P.byteLength;
        let I = new ArrayBuffer(sPlusPLength);
        let iView = new Uint8Array(I);
        iView.set(sView);
        iView.set(pView, sView.length);
        const c = Math.ceil((keyLength >> 3) / u);
        let internalSequence = Promise.resolve(I);
        for (let i = 0; i <= c; i++) {
            internalSequence = internalSequence.then(_I => {
                const dAndI = new ArrayBuffer(D.byteLength + _I.byteLength);
                const dAndIView = new Uint8Array(dAndI);
                dAndIView.set(dView);
                dAndIView.set(iView, dView.length);
                return dAndI;
            });
            for (let j = 0; j < iterationCount; j++)
                internalSequence = internalSequence.then(roundBuffer => cryptoEngine.digest({ name: hashAlgorithm }, new Uint8Array(roundBuffer)));
            internalSequence = internalSequence.then(roundBuffer => {
                const B = new ArrayBuffer(v);
                const bView = new Uint8Array(B);
                for (let j = 0; j < B.byteLength; j++)
                    bView[j] = roundBuffer[j % roundBuffer.byteLength];
                const k = Math.ceil(saltLength / v) + Math.ceil(passwordLength / v);
                const iRound = [];
                let sliceStart = 0;
                let sliceLength = v;
                for (let j = 0; j < k; j++) {
                    const chunk = Array.from(new Uint8Array(I.slice(sliceStart, sliceStart + sliceLength)));
                    sliceStart += v;
                    if ((sliceStart + v) > I.byteLength)
                        sliceLength = I.byteLength - sliceStart;
                    let x = 0x1ff;
                    for (let l = (B.byteLength - 1); l >= 0; l--) {
                        x >>= 8;
                        x += bView[l] + chunk[l];
                        chunk[l] = (x & 0xff);
                    }
                    iRound.push(...chunk);
                }
                I = new ArrayBuffer(iRound.length);
                iView = new Uint8Array(I);
                iView.set(iRound);
                result.push(...(new Uint8Array(roundBuffer)));
                return I;
            });
        }
        internalSequence = internalSequence.then(() => {
            const resultBuffer = new ArrayBuffer(keyLength >> 3);
            const resultView = new Uint8Array(resultBuffer);
            resultView.set((new Uint8Array(result)).slice(0, keyLength >> 3));
            return resultBuffer;
        });
        return internalSequence;
    }
    function prepareAlgorithm(data) {
        const res = typeof data === "string"
            ? { name: data }
            : data;
        if ("hash" in res) {
            return {
                ...res,
                hash: prepareAlgorithm(res.hash)
            };
        }
        return res;
    }
    class CryptoEngine extends AbstractCryptoEngine {
        async importKey(format, keyData, algorithm, extractable, keyUsages) {
            var _a, _b, _c, _d, _e, _f;
            let jwk = {};
            const alg = prepareAlgorithm(algorithm);
            switch (format.toLowerCase()) {
                case "raw":
                    return this.subtle.importKey("raw", keyData, algorithm, extractable, keyUsages);
                case "spki":
                    {
                        const asn1 = fromBER(BufferSourceConverter_1.toArrayBuffer(keyData));
                        AsnError.assert(asn1, "keyData");
                        const publicKeyInfo = new PublicKeyInfo();
                        try {
                            publicKeyInfo.fromSchema(asn1.result);
                        }
                        catch {
                            throw new ArgumentError("Incorrect keyData");
                        }
                        switch (alg.name.toUpperCase()) {
                            case "RSA-PSS":
                                {
                                    if (!alg.hash) {
                                        throw new ParameterError("hash", "algorithm.hash", "Incorrect hash algorithm: Hash algorithm is missed");
                                    }
                                    switch (alg.hash.name.toUpperCase()) {
                                        case "SHA-1":
                                            jwk.alg = "PS1";
                                            break;
                                        case "SHA-256":
                                            jwk.alg = "PS256";
                                            break;
                                        case "SHA-384":
                                            jwk.alg = "PS384";
                                            break;
                                        case "SHA-512":
                                            jwk.alg = "PS512";
                                            break;
                                        default:
                                            throw new Error(`Incorrect hash algorithm: ${alg.hash.name.toUpperCase()}`);
                                    }
                                }
                            case "RSASSA-PKCS1-V1_5":
                                {
                                    keyUsages = ["verify"];
                                    jwk.kty = "RSA";
                                    jwk.ext = extractable;
                                    jwk.key_ops = keyUsages;
                                    if (publicKeyInfo.algorithm.algorithmId !== "1.2.840.113549.1.1.1")
                                        throw new Error(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
                                    if (!jwk.alg) {
                                        if (!alg.hash) {
                                            throw new ParameterError("hash", "algorithm.hash", "Incorrect hash algorithm: Hash algorithm is missed");
                                        }
                                        switch (alg.hash.name.toUpperCase()) {
                                            case "SHA-1":
                                                jwk.alg = "RS1";
                                                break;
                                            case "SHA-256":
                                                jwk.alg = "RS256";
                                                break;
                                            case "SHA-384":
                                                jwk.alg = "RS384";
                                                break;
                                            case "SHA-512":
                                                jwk.alg = "RS512";
                                                break;
                                            default:
                                                throw new Error(`Incorrect hash algorithm: ${alg.hash.name.toUpperCase()}`);
                                        }
                                    }
                                    const publicKeyJSON = publicKeyInfo.toJSON();
                                    Object.assign(jwk, publicKeyJSON);
                                }
                                break;
                            case "ECDSA":
                                keyUsages = ["verify"];
                            case "ECDH":
                                {
                                    jwk = {
                                        kty: "EC",
                                        ext: extractable,
                                        key_ops: keyUsages
                                    };
                                    if (publicKeyInfo.algorithm.algorithmId !== "1.2.840.10045.2.1") {
                                        throw new Error(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
                                    }
                                    const publicKeyJSON = publicKeyInfo.toJSON();
                                    Object.assign(jwk, publicKeyJSON);
                                }
                                break;
                            case "RSA-OAEP":
                                {
                                    jwk.kty = "RSA";
                                    jwk.ext = extractable;
                                    jwk.key_ops = keyUsages;
                                    if (this.name.toLowerCase() === "safari")
                                        jwk.alg = "RSA-OAEP";
                                    else {
                                        if (!alg.hash) {
                                            throw new ParameterError("hash", "algorithm.hash", "Incorrect hash algorithm: Hash algorithm is missed");
                                        }
                                        switch (alg.hash.name.toUpperCase()) {
                                            case "SHA-1":
                                                jwk.alg = "RSA-OAEP";
                                                break;
                                            case "SHA-256":
                                                jwk.alg = "RSA-OAEP-256";
                                                break;
                                            case "SHA-384":
                                                jwk.alg = "RSA-OAEP-384";
                                                break;
                                            case "SHA-512":
                                                jwk.alg = "RSA-OAEP-512";
                                                break;
                                            default:
                                                throw new Error(`Incorrect hash algorithm: ${alg.hash.name.toUpperCase()}`);
                                        }
                                    }
                                    const publicKeyJSON = publicKeyInfo.toJSON();
                                    Object.assign(jwk, publicKeyJSON);
                                }
                                break;
                            case "RSAES-PKCS1-V1_5":
                                {
                                    jwk.kty = "RSA";
                                    jwk.ext = extractable;
                                    jwk.key_ops = keyUsages;
                                    jwk.alg = "PS1";
                                    const publicKeyJSON = publicKeyInfo.toJSON();
                                    Object.assign(jwk, publicKeyJSON);
                                }
                                break;
                            default:
                                throw new Error(`Incorrect algorithm name: ${alg.name.toUpperCase()}`);
                        }
                    }
                    break;
                case "pkcs8":
                    {
                        const privateKeyInfo = new PrivateKeyInfo();
                        const asn1 = fromBER(BufferSourceConverter_1.toArrayBuffer(keyData));
                        AsnError.assert(asn1, "keyData");
                        try {
                            privateKeyInfo.fromSchema(asn1.result);
                        }
                        catch (ex) {
                            throw new Error("Incorrect keyData");
                        }
                        if (!privateKeyInfo.parsedKey)
                            throw new Error("Incorrect keyData");
                        switch (alg.name.toUpperCase()) {
                            case "RSA-PSS":
                                {
                                    switch ((_a = alg.hash) === null || _a === void 0 ? void 0 : _a.name.toUpperCase()) {
                                        case "SHA-1":
                                            jwk.alg = "PS1";
                                            break;
                                        case "SHA-256":
                                            jwk.alg = "PS256";
                                            break;
                                        case "SHA-384":
                                            jwk.alg = "PS384";
                                            break;
                                        case "SHA-512":
                                            jwk.alg = "PS512";
                                            break;
                                        default:
                                            throw new Error(`Incorrect hash algorithm: ${(_b = alg.hash) === null || _b === void 0 ? void 0 : _b.name.toUpperCase()}`);
                                    }
                                }
                            case "RSASSA-PKCS1-V1_5":
                                {
                                    keyUsages = ["sign"];
                                    jwk.kty = "RSA";
                                    jwk.ext = extractable;
                                    jwk.key_ops = keyUsages;
                                    if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.113549.1.1.1")
                                        throw new Error(`Incorrect private key algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
                                    if (("alg" in jwk) === false) {
                                        switch ((_c = alg.hash) === null || _c === void 0 ? void 0 : _c.name.toUpperCase()) {
                                            case "SHA-1":
                                                jwk.alg = "RS1";
                                                break;
                                            case "SHA-256":
                                                jwk.alg = "RS256";
                                                break;
                                            case "SHA-384":
                                                jwk.alg = "RS384";
                                                break;
                                            case "SHA-512":
                                                jwk.alg = "RS512";
                                                break;
                                            default:
                                                throw new Error(`Incorrect hash algorithm: ${(_d = alg.hash) === null || _d === void 0 ? void 0 : _d.name.toUpperCase()}`);
                                        }
                                    }
                                    const privateKeyJSON = privateKeyInfo.toJSON();
                                    Object.assign(jwk, privateKeyJSON);
                                }
                                break;
                            case "ECDSA":
                                keyUsages = ["sign"];
                            case "ECDH":
                                {
                                    jwk = {
                                        kty: "EC",
                                        ext: extractable,
                                        key_ops: keyUsages
                                    };
                                    if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.10045.2.1")
                                        throw new Error(`Incorrect algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
                                    const privateKeyJSON = privateKeyInfo.toJSON();
                                    Object.assign(jwk, privateKeyJSON);
                                }
                                break;
                            case "RSA-OAEP":
                                {
                                    jwk.kty = "RSA";
                                    jwk.ext = extractable;
                                    jwk.key_ops = keyUsages;
                                    if (this.name.toLowerCase() === "safari")
                                        jwk.alg = "RSA-OAEP";
                                    else {
                                        switch ((_e = alg.hash) === null || _e === void 0 ? void 0 : _e.name.toUpperCase()) {
                                            case "SHA-1":
                                                jwk.alg = "RSA-OAEP";
                                                break;
                                            case "SHA-256":
                                                jwk.alg = "RSA-OAEP-256";
                                                break;
                                            case "SHA-384":
                                                jwk.alg = "RSA-OAEP-384";
                                                break;
                                            case "SHA-512":
                                                jwk.alg = "RSA-OAEP-512";
                                                break;
                                            default:
                                                throw new Error(`Incorrect hash algorithm: ${(_f = alg.hash) === null || _f === void 0 ? void 0 : _f.name.toUpperCase()}`);
                                        }
                                    }
                                    const privateKeyJSON = privateKeyInfo.toJSON();
                                    Object.assign(jwk, privateKeyJSON);
                                }
                                break;
                            case "RSAES-PKCS1-V1_5":
                                {
                                    keyUsages = ["decrypt"];
                                    jwk.kty = "RSA";
                                    jwk.ext = extractable;
                                    jwk.key_ops = keyUsages;
                                    jwk.alg = "PS1";
                                    const privateKeyJSON = privateKeyInfo.toJSON();
                                    Object.assign(jwk, privateKeyJSON);
                                }
                                break;
                            default:
                                throw new Error(`Incorrect algorithm name: ${alg.name.toUpperCase()}`);
                        }
                    }
                    break;
                case "jwk":
                    jwk = keyData;
                    break;
                default:
                    throw new Error(`Incorrect format: ${format}`);
            }
            if (this.name.toLowerCase() === "safari") {
                try {
                    return this.subtle.importKey("jwk", stringToArrayBuffer(JSON.stringify(jwk)), algorithm, extractable, keyUsages);
                }
                catch {
                    return this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages);
                }
            }
            return this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages);
        }
        async exportKey(format, key) {
            let jwk = await this.subtle.exportKey("jwk", key);
            if (this.name.toLowerCase() === "safari") {
                if (jwk instanceof ArrayBuffer) {
                    jwk = JSON.parse(arrayBufferToString(jwk));
                }
            }
            switch (format.toLowerCase()) {
                case "raw":
                    return this.subtle.exportKey("raw", key);
                case "spki": {
                    const publicKeyInfo = new PublicKeyInfo();
                    try {
                        publicKeyInfo.fromJSON(jwk);
                    }
                    catch (ex) {
                        throw new Error("Incorrect key data");
                    }
                    return publicKeyInfo.toSchema().toBER(false);
                }
                case "pkcs8": {
                    const privateKeyInfo = new PrivateKeyInfo();
                    try {
                        privateKeyInfo.fromJSON(jwk);
                    }
                    catch (ex) {
                        throw new Error("Incorrect key data");
                    }
                    return privateKeyInfo.toSchema().toBER(false);
                }
                case "jwk":
                    return jwk;
                default:
                    throw new Error(`Incorrect format: ${format}`);
            }
        }
        async convert(inputFormat, outputFormat, keyData, algorithm, extractable, keyUsages) {
            if (inputFormat.toLowerCase() === outputFormat.toLowerCase()) {
                return keyData;
            }
            const key = await this.importKey(inputFormat, keyData, algorithm, extractable, keyUsages);
            return this.exportKey(outputFormat, key);
        }
        getAlgorithmByOID(oid, safety = false, target) {
            switch (oid) {
                case "1.2.840.113549.1.1.1":
                    return {
                        name: "RSAES-PKCS1-v1_5"
                    };
                case "1.2.840.113549.1.1.5":
                    return {
                        name: "RSASSA-PKCS1-v1_5",
                        hash: {
                            name: "SHA-1"
                        }
                    };
                case "1.2.840.113549.1.1.11":
                    return {
                        name: "RSASSA-PKCS1-v1_5",
                        hash: {
                            name: "SHA-256"
                        }
                    };
                case "1.2.840.113549.1.1.12":
                    return {
                        name: "RSASSA-PKCS1-v1_5",
                        hash: {
                            name: "SHA-384"
                        }
                    };
                case "1.2.840.113549.1.1.13":
                    return {
                        name: "RSASSA-PKCS1-v1_5",
                        hash: {
                            name: "SHA-512"
                        }
                    };
                case "1.2.840.113549.1.1.10":
                    return {
                        name: "RSA-PSS"
                    };
                case "1.2.840.113549.1.1.7":
                    return {
                        name: "RSA-OAEP"
                    };
                case "1.2.840.10045.2.1":
                case "1.2.840.10045.4.1":
                    return {
                        name: "ECDSA",
                        hash: {
                            name: "SHA-1"
                        }
                    };
                case "1.2.840.10045.4.3.2":
                    return {
                        name: "ECDSA",
                        hash: {
                            name: "SHA-256"
                        }
                    };
                case "1.2.840.10045.4.3.3":
                    return {
                        name: "ECDSA",
                        hash: {
                            name: "SHA-384"
                        }
                    };
                case "1.2.840.10045.4.3.4":
                    return {
                        name: "ECDSA",
                        hash: {
                            name: "SHA-512"
                        }
                    };
                case "1.3.133.16.840.63.0.2":
                    return {
                        name: "ECDH",
                        kdf: "SHA-1"
                    };
                case "1.3.132.1.11.1":
                    return {
                        name: "ECDH",
                        kdf: "SHA-256"
                    };
                case "1.3.132.1.11.2":
                    return {
                        name: "ECDH",
                        kdf: "SHA-384"
                    };
                case "1.3.132.1.11.3":
                    return {
                        name: "ECDH",
                        kdf: "SHA-512"
                    };
                case "2.16.840.1.101.3.4.1.2":
                    return {
                        name: "AES-CBC",
                        length: 128
                    };
                case "2.16.840.1.101.3.4.1.22":
                    return {
                        name: "AES-CBC",
                        length: 192
                    };
                case "2.16.840.1.101.3.4.1.42":
                    return {
                        name: "AES-CBC",
                        length: 256
                    };
                case "2.16.840.1.101.3.4.1.6":
                    return {
                        name: "AES-GCM",
                        length: 128
                    };
                case "2.16.840.1.101.3.4.1.26":
                    return {
                        name: "AES-GCM",
                        length: 192
                    };
                case "2.16.840.1.101.3.4.1.46":
                    return {
                        name: "AES-GCM",
                        length: 256
                    };
                case "2.16.840.1.101.3.4.1.4":
                    return {
                        name: "AES-CFB",
                        length: 128
                    };
                case "2.16.840.1.101.3.4.1.24":
                    return {
                        name: "AES-CFB",
                        length: 192
                    };
                case "2.16.840.1.101.3.4.1.44":
                    return {
                        name: "AES-CFB",
                        length: 256
                    };
                case "2.16.840.1.101.3.4.1.5":
                    return {
                        name: "AES-KW",
                        length: 128
                    };
                case "2.16.840.1.101.3.4.1.25":
                    return {
                        name: "AES-KW",
                        length: 192
                    };
                case "2.16.840.1.101.3.4.1.45":
                    return {
                        name: "AES-KW",
                        length: 256
                    };
                case "1.2.840.113549.2.7":
                    return {
                        name: "HMAC",
                        hash: {
                            name: "SHA-1"
                        }
                    };
                case "1.2.840.113549.2.9":
                    return {
                        name: "HMAC",
                        hash: {
                            name: "SHA-256"
                        }
                    };
                case "1.2.840.113549.2.10":
                    return {
                        name: "HMAC",
                        hash: {
                            name: "SHA-384"
                        }
                    };
                case "1.2.840.113549.2.11":
                    return {
                        name: "HMAC",
                        hash: {
                            name: "SHA-512"
                        }
                    };
                case "1.2.840.113549.1.9.16.3.5":
                    return {
                        name: "DH"
                    };
                case "1.3.14.3.2.26":
                    return {
                        name: "SHA-1"
                    };
                case "2.16.840.1.101.3.4.2.1":
                    return {
                        name: "SHA-256"
                    };
                case "2.16.840.1.101.3.4.2.2":
                    return {
                        name: "SHA-384"
                    };
                case "2.16.840.1.101.3.4.2.3":
                    return {
                        name: "SHA-512"
                    };
                case "1.2.840.113549.1.5.12":
                    return {
                        name: "PBKDF2"
                    };
                case "1.2.840.10045.3.1.7":
                    return {
                        name: "P-256"
                    };
                case "1.3.132.0.34":
                    return {
                        name: "P-384"
                    };
                case "1.3.132.0.35":
                    return {
                        name: "P-521"
                    };
            }
            if (safety) {
                throw new Error(`Unsupported algorithm identifier ${target ? `for ${target} ` : EMPTY_STRING}: ${oid}`);
            }
            return {};
        }
        getOIDByAlgorithm(algorithm, safety = false, target) {
            let result = EMPTY_STRING;
            switch (algorithm.name.toUpperCase()) {
                case "RSAES-PKCS1-V1_5":
                    result = "1.2.840.113549.1.1.1";
                    break;
                case "RSASSA-PKCS1-V1_5":
                    switch (algorithm.hash.name.toUpperCase()) {
                        case "SHA-1":
                            result = "1.2.840.113549.1.1.5";
                            break;
                        case "SHA-256":
                            result = "1.2.840.113549.1.1.11";
                            break;
                        case "SHA-384":
                            result = "1.2.840.113549.1.1.12";
                            break;
                        case "SHA-512":
                            result = "1.2.840.113549.1.1.13";
                            break;
                    }
                    break;
                case "RSA-PSS":
                    result = "1.2.840.113549.1.1.10";
                    break;
                case "RSA-OAEP":
                    result = "1.2.840.113549.1.1.7";
                    break;
                case "ECDSA":
                    switch (algorithm.hash.name.toUpperCase()) {
                        case "SHA-1":
                            result = "1.2.840.10045.4.1";
                            break;
                        case "SHA-256":
                            result = "1.2.840.10045.4.3.2";
                            break;
                        case "SHA-384":
                            result = "1.2.840.10045.4.3.3";
                            break;
                        case "SHA-512":
                            result = "1.2.840.10045.4.3.4";
                            break;
                    }
                    break;
                case "ECDH":
                    switch (algorithm.kdf.toUpperCase()) {
                        case "SHA-1":
                            result = "1.3.133.16.840.63.0.2";
                            break;
                        case "SHA-256":
                            result = "1.3.132.1.11.1";
                            break;
                        case "SHA-384":
                            result = "1.3.132.1.11.2";
                            break;
                        case "SHA-512":
                            result = "1.3.132.1.11.3";
                            break;
                    }
                    break;
                case "AES-CTR":
                    break;
                case "AES-CBC":
                    switch (algorithm.length) {
                        case 128:
                            result = "2.16.840.1.101.3.4.1.2";
                            break;
                        case 192:
                            result = "2.16.840.1.101.3.4.1.22";
                            break;
                        case 256:
                            result = "2.16.840.1.101.3.4.1.42";
                            break;
                    }
                    break;
                case "AES-CMAC":
                    break;
                case "AES-GCM":
                    switch (algorithm.length) {
                        case 128:
                            result = "2.16.840.1.101.3.4.1.6";
                            break;
                        case 192:
                            result = "2.16.840.1.101.3.4.1.26";
                            break;
                        case 256:
                            result = "2.16.840.1.101.3.4.1.46";
                            break;
                    }
                    break;
                case "AES-CFB":
                    switch (algorithm.length) {
                        case 128:
                            result = "2.16.840.1.101.3.4.1.4";
                            break;
                        case 192:
                            result = "2.16.840.1.101.3.4.1.24";
                            break;
                        case 256:
                            result = "2.16.840.1.101.3.4.1.44";
                            break;
                    }
                    break;
                case "AES-KW":
                    switch (algorithm.length) {
                        case 128:
                            result = "2.16.840.1.101.3.4.1.5";
                            break;
                        case 192:
                            result = "2.16.840.1.101.3.4.1.25";
                            break;
                        case 256:
                            result = "2.16.840.1.101.3.4.1.45";
                            break;
                    }
                    break;
                case "HMAC":
                    switch (algorithm.hash.name.toUpperCase()) {
                        case "SHA-1":
                            result = "1.2.840.113549.2.7";
                            break;
                        case "SHA-256":
                            result = "1.2.840.113549.2.9";
                            break;
                        case "SHA-384":
                            result = "1.2.840.113549.2.10";
                            break;
                        case "SHA-512":
                            result = "1.2.840.113549.2.11";
                            break;
                    }
                    break;
                case "DH":
                    result = "1.2.840.113549.1.9.16.3.5";
                    break;
                case "SHA-1":
                    result = "1.3.14.3.2.26";
                    break;
                case "SHA-256":
                    result = "2.16.840.1.101.3.4.2.1";
                    break;
                case "SHA-384":
                    result = "2.16.840.1.101.3.4.2.2";
                    break;
                case "SHA-512":
                    result = "2.16.840.1.101.3.4.2.3";
                    break;
                case "CONCAT":
                    break;
                case "HKDF":
                    break;
                case "PBKDF2":
                    result = "1.2.840.113549.1.5.12";
                    break;
                case "P-256":
                    result = "1.2.840.10045.3.1.7";
                    break;
                case "P-384":
                    result = "1.3.132.0.34";
                    break;
                case "P-521":
                    result = "1.3.132.0.35";
                    break;
            }
            if (!result && safety) {
                throw new Error(`Unsupported algorithm ${target ? `for ${target} ` : EMPTY_STRING}: ${algorithm.name}`);
            }
            return result;
        }
        getAlgorithmParameters(algorithmName, operation) {
            let result = {
                algorithm: {},
                usages: []
            };
            switch (algorithmName.toUpperCase()) {
                case "RSAES-PKCS1-V1_5":
                case "RSASSA-PKCS1-V1_5":
                    switch (operation.toLowerCase()) {
                        case "generatekey":
                            result = {
                                algorithm: {
                                    name: "RSASSA-PKCS1-v1_5",
                                    modulusLength: 2048,
                                    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                                    hash: {
                                        name: "SHA-256"
                                    }
                                },
                                usages: ["sign", "verify"]
                            };
                            break;
                        case "verify":
                        case "sign":
                        case "importkey":
                            result = {
                                algorithm: {
                                    name: "RSASSA-PKCS1-v1_5",
                                    hash: {
                                        name: "SHA-256"
                                    }
                                },
                                usages: ["verify"]
                            };
                            break;
                        case "exportkey":
                        default:
                            return {
                                algorithm: {
                                    name: "RSASSA-PKCS1-v1_5"
                                },
                                usages: []
                            };
                    }
                    break;
                case "RSA-PSS":
                    switch (operation.toLowerCase()) {
                        case "sign":
                        case "verify":
                            result = {
                                algorithm: {
                                    name: "RSA-PSS",
                                    hash: {
                                        name: "SHA-1"
                                    },
                                    saltLength: 20
                                },
                                usages: ["sign", "verify"]
                            };
                            break;
                        case "generatekey":
                            result = {
                                algorithm: {
                                    name: "RSA-PSS",
                                    modulusLength: 2048,
                                    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                                    hash: {
                                        name: "SHA-1"
                                    }
                                },
                                usages: ["sign", "verify"]
                            };
                            break;
                        case "importkey":
                            result = {
                                algorithm: {
                                    name: "RSA-PSS",
                                    hash: {
                                        name: "SHA-1"
                                    }
                                },
                                usages: ["verify"]
                            };
                            break;
                        case "exportkey":
                        default:
                            return {
                                algorithm: {
                                    name: "RSA-PSS"
                                },
                                usages: []
                            };
                    }
                    break;
                case "RSA-OAEP":
                    switch (operation.toLowerCase()) {
                        case "encrypt":
                        case "decrypt":
                            result = {
                                algorithm: {
                                    name: "RSA-OAEP"
                                },
                                usages: ["encrypt", "decrypt"]
                            };
                            break;
                        case "generatekey":
                            result = {
                                algorithm: {
                                    name: "RSA-OAEP",
                                    modulusLength: 2048,
                                    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                                    hash: {
                                        name: "SHA-256"
                                    }
                                },
                                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                            };
                            break;
                        case "importkey":
                            result = {
                                algorithm: {
                                    name: "RSA-OAEP",
                                    hash: {
                                        name: "SHA-256"
                                    }
                                },
                                usages: ["encrypt"]
                            };
                            break;
                        case "exportkey":
                        default:
                            return {
                                algorithm: {
                                    name: "RSA-OAEP"
                                },
                                usages: []
                            };
                    }
                    break;
                case "ECDSA":
                    switch (operation.toLowerCase()) {
                        case "generatekey":
                            result = {
                                algorithm: {
                                    name: "ECDSA",
                                    namedCurve: "P-256"
                                },
                                usages: ["sign", "verify"]
                            };
                            break;
                        case "importkey":
                            result = {
                                algorithm: {
                                    name: "ECDSA",
                                    namedCurve: "P-256"
                                },
                                usages: ["verify"]
                            };
                            break;
                        case "verify":
                        case "sign":
                            result = {
                                algorithm: {
                                    name: "ECDSA",
                                    hash: {
                                        name: "SHA-256"
                                    }
                                },
                                usages: ["sign"]
                            };
                            break;
                        default:
                            return {
                                algorithm: {
                                    name: "ECDSA"
                                },
                                usages: []
                            };
                    }
                    break;
                case "ECDH":
                    switch (operation.toLowerCase()) {
                        case "exportkey":
                        case "importkey":
                        case "generatekey":
                            result = {
                                algorithm: {
                                    name: "ECDH",
                                    namedCurve: "P-256"
                                },
                                usages: ["deriveKey", "deriveBits"]
                            };
                            break;
                        case "derivekey":
                        case "derivebits":
                            result = {
                                algorithm: {
                                    name: "ECDH",
                                    namedCurve: "P-256",
                                    public: []
                                },
                                usages: ["encrypt", "decrypt"]
                            };
                            break;
                        default:
                            return {
                                algorithm: {
                                    name: "ECDH"
                                },
                                usages: []
                            };
                    }
                    break;
                case "AES-CTR":
                    switch (operation.toLowerCase()) {
                        case "importkey":
                        case "exportkey":
                        case "generatekey":
                            result = {
                                algorithm: {
                                    name: "AES-CTR",
                                    length: 256
                                },
                                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                            };
                            break;
                        case "decrypt":
                        case "encrypt":
                            result = {
                                algorithm: {
                                    name: "AES-CTR",
                                    counter: new Uint8Array(16),
                                    length: 10
                                },
                                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                            };
                            break;
                        default:
                            return {
                                algorithm: {
                                    name: "AES-CTR"
                                },
                                usages: []
                            };
                    }
                    break;
                case "AES-CBC":
                    switch (operation.toLowerCase()) {
                        case "importkey":
                        case "exportkey":
                        case "generatekey":
                            result = {
                                algorithm: {
                                    name: "AES-CBC",
                                    length: 256
                                },
                                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                            };
                            break;
                        case "decrypt":
                        case "encrypt":
                            result = {
                                algorithm: {
                                    name: "AES-CBC",
                                    iv: this.getRandomValues(new Uint8Array(16))
                                },
                                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                            };
                            break;
                        default:
                            return {
                                algorithm: {
                                    name: "AES-CBC"
                                },
                                usages: []
                            };
                    }
                    break;
                case "AES-GCM":
                    switch (operation.toLowerCase()) {
                        case "importkey":
                        case "exportkey":
                        case "generatekey":
                            result = {
                                algorithm: {
                                    name: "AES-GCM",
                                    length: 256
                                },
                                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                            };
                            break;
                        case "decrypt":
                        case "encrypt":
                            result = {
                                algorithm: {
                                    name: "AES-GCM",
                                    iv: this.getRandomValues(new Uint8Array(16))
                                },
                                usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                            };
                            break;
                        default:
                            return {
                                algorithm: {
                                    name: "AES-GCM"
                                },
                                usages: []
                            };
                    }
                    break;
                case "AES-KW":
                    switch (operation.toLowerCase()) {
                        case "importkey":
                        case "exportkey":
                        case "generatekey":
                        case "wrapkey":
                        case "unwrapkey":
                            result = {
                                algorithm: {
                                    name: "AES-KW",
                                    length: 256
                                },
                                usages: ["wrapKey", "unwrapKey"]
                            };
                            break;
                        default:
                            return {
                                algorithm: {
                                    name: "AES-KW"
                                },
                                usages: []
                            };
                    }
                    break;
                case "HMAC":
                    switch (operation.toLowerCase()) {
                        case "sign":
                        case "verify":
                            result = {
                                algorithm: {
                                    name: "HMAC"
                                },
                                usages: ["sign", "verify"]
                            };
                            break;
                        case "importkey":
                        case "exportkey":
                        case "generatekey":
                            result = {
                                algorithm: {
                                    name: "HMAC",
                                    length: 32,
                                    hash: {
                                        name: "SHA-256"
                                    }
                                },
                                usages: ["sign", "verify"]
                            };
                            break;
                        default:
                            return {
                                algorithm: {
                                    name: "HMAC"
                                },
                                usages: []
                            };
                    }
                    break;
                case "HKDF":
                    switch (operation.toLowerCase()) {
                        case "derivekey":
                            result = {
                                algorithm: {
                                    name: "HKDF",
                                    hash: "SHA-256",
                                    salt: new Uint8Array([]),
                                    info: new Uint8Array([])
                                },
                                usages: ["encrypt", "decrypt"]
                            };
                            break;
                        default:
                            return {
                                algorithm: {
                                    name: "HKDF"
                                },
                                usages: []
                            };
                    }
                    break;
                case "PBKDF2":
                    switch (operation.toLowerCase()) {
                        case "derivekey":
                            result = {
                                algorithm: {
                                    name: "PBKDF2",
                                    hash: { name: "SHA-256" },
                                    salt: new Uint8Array([]),
                                    iterations: 10000
                                },
                                usages: ["encrypt", "decrypt"]
                            };
                            break;
                        default:
                            return {
                                algorithm: {
                                    name: "PBKDF2"
                                },
                                usages: []
                            };
                    }
                    break;
            }
            return result;
        }
        getHashAlgorithm(signatureAlgorithm) {
            let result = EMPTY_STRING;
            switch (signatureAlgorithm.algorithmId) {
                case "1.2.840.10045.4.1":
                case "1.2.840.113549.1.1.5":
                    result = "SHA-1";
                    break;
                case "1.2.840.10045.4.3.2":
                case "1.2.840.113549.1.1.11":
                    result = "SHA-256";
                    break;
                case "1.2.840.10045.4.3.3":
                case "1.2.840.113549.1.1.12":
                    result = "SHA-384";
                    break;
                case "1.2.840.10045.4.3.4":
                case "1.2.840.113549.1.1.13":
                    result = "SHA-512";
                    break;
                case "1.2.840.113549.1.1.10":
                    {
                        try {
                            const params = new RSASSAPSSParams({ schema: signatureAlgorithm.algorithmParams });
                            if (params.hashAlgorithm) {
                                const algorithm = this.getAlgorithmByOID(params.hashAlgorithm.algorithmId);
                                if ("name" in algorithm) {
                                    result = algorithm.name;
                                }
                                else {
                                    return EMPTY_STRING;
                                }
                            }
                            else
                                result = "SHA-1";
                        }
                        catch {
                        }
                    }
                    break;
            }
            return result;
        }
        async encryptEncryptedContentInfo(parameters) {
            ParameterError.assert(parameters, "password", "contentEncryptionAlgorithm", "hmacHashAlgorithm", "iterationCount", "contentToEncrypt", "contentToEncrypt", "contentType");
            const contentEncryptionOID = this.getOIDByAlgorithm(parameters.contentEncryptionAlgorithm, true, "contentEncryptionAlgorithm");
            const pbkdf2OID = this.getOIDByAlgorithm({
                name: "PBKDF2"
            }, true, "PBKDF2");
            const hmacOID = this.getOIDByAlgorithm({
                name: "HMAC",
                hash: {
                    name: parameters.hmacHashAlgorithm
                }
            }, true, "hmacHashAlgorithm");
            const ivBuffer = new ArrayBuffer(16);
            const ivView = new Uint8Array(ivBuffer);
            this.getRandomValues(ivView);
            const saltBuffer = new ArrayBuffer(64);
            const saltView = new Uint8Array(saltBuffer);
            this.getRandomValues(saltView);
            const contentView = new Uint8Array(parameters.contentToEncrypt);
            const pbkdf2Params = new PBKDF2Params({
                salt: new OctetString({ valueHex: saltBuffer }),
                iterationCount: parameters.iterationCount,
                prf: new AlgorithmIdentifier({
                    algorithmId: hmacOID,
                    algorithmParams: new Null()
                })
            });
            const passwordView = new Uint8Array(parameters.password);
            const pbkdfKey = await this.importKey("raw", passwordView, "PBKDF2", false, ["deriveKey"]);
            const derivedKey = await this.deriveKey({
                name: "PBKDF2",
                hash: {
                    name: parameters.hmacHashAlgorithm
                },
                salt: saltView,
                iterations: parameters.iterationCount
            }, pbkdfKey, parameters.contentEncryptionAlgorithm, false, ["encrypt"]);
            const encryptedData = await this.encrypt({
                name: parameters.contentEncryptionAlgorithm.name,
                iv: ivView
            }, derivedKey, contentView);
            const pbes2Parameters = new PBES2Params({
                keyDerivationFunc: new AlgorithmIdentifier({
                    algorithmId: pbkdf2OID,
                    algorithmParams: pbkdf2Params.toSchema()
                }),
                encryptionScheme: new AlgorithmIdentifier({
                    algorithmId: contentEncryptionOID,
                    algorithmParams: new OctetString({ valueHex: ivBuffer })
                })
            });
            return new EncryptedContentInfo({
                contentType: parameters.contentType,
                contentEncryptionAlgorithm: new AlgorithmIdentifier({
                    algorithmId: "1.2.840.113549.1.5.13",
                    algorithmParams: pbes2Parameters.toSchema()
                }),
                encryptedContent: new OctetString({ valueHex: encryptedData })
            });
        }
        async decryptEncryptedContentInfo(parameters) {
            ParameterError.assert(parameters, "password", "encryptedContentInfo");
            if (parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId !== "1.2.840.113549.1.5.13")
                throw new Error(`Unknown "contentEncryptionAlgorithm": ${parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
            let pbes2Parameters;
            try {
                pbes2Parameters = new PBES2Params({ schema: parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams });
            }
            catch (ex) {
                throw new Error("Incorrectly encoded \"pbes2Parameters\"");
            }
            let pbkdf2Params;
            try {
                pbkdf2Params = new PBKDF2Params({ schema: pbes2Parameters.keyDerivationFunc.algorithmParams });
            }
            catch (ex) {
                throw new Error("Incorrectly encoded \"pbkdf2Params\"");
            }
            const contentEncryptionAlgorithm = this.getAlgorithmByOID(pbes2Parameters.encryptionScheme.algorithmId, true);
            const ivBuffer = pbes2Parameters.encryptionScheme.algorithmParams.valueBlock.valueHex;
            const ivView = new Uint8Array(ivBuffer);
            const saltBuffer = pbkdf2Params.salt.valueBlock.valueHex;
            const saltView = new Uint8Array(saltBuffer);
            const iterationCount = pbkdf2Params.iterationCount;
            let hmacHashAlgorithm = "SHA-1";
            if (pbkdf2Params.prf) {
                const algorithm = this.getAlgorithmByOID(pbkdf2Params.prf.algorithmId, true);
                hmacHashAlgorithm = algorithm.hash.name;
            }
            const pbkdfKey = await this.importKey("raw", parameters.password, "PBKDF2", false, ["deriveKey"]);
            const result = await this.deriveKey({
                name: "PBKDF2",
                hash: {
                    name: hmacHashAlgorithm
                },
                salt: saltView,
                iterations: iterationCount
            }, pbkdfKey, contentEncryptionAlgorithm, false, ["decrypt"]);
            const dataBuffer = parameters.encryptedContentInfo.getEncryptedContent();
            return this.decrypt({
                name: contentEncryptionAlgorithm.name,
                iv: ivView
            }, result, dataBuffer);
        }
        async stampDataWithPassword(parameters) {
            if ((parameters instanceof Object) === false)
                throw new Error("Parameters must have type \"Object\"");
            ParameterError.assert(parameters, "password", "hashAlgorithm", "iterationCount", "salt", "contentToStamp");
            let length;
            switch (parameters.hashAlgorithm.toLowerCase()) {
                case "sha-1":
                    length = 160;
                    break;
                case "sha-256":
                    length = 256;
                    break;
                case "sha-384":
                    length = 384;
                    break;
                case "sha-512":
                    length = 512;
                    break;
                default:
                    throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${parameters.hashAlgorithm}`);
            }
            const hmacAlgorithm = {
                name: "HMAC",
                length,
                hash: {
                    name: parameters.hashAlgorithm
                }
            };
            const pkcsKey = await makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount);
            const hmacKey = await this.importKey("raw", new Uint8Array(pkcsKey), hmacAlgorithm, false, ["sign"]);
            return this.sign(hmacAlgorithm, hmacKey, new Uint8Array(parameters.contentToStamp));
        }
        async verifyDataStampedWithPassword(parameters) {
            ParameterError.assert(parameters, "password", "hashAlgorithm", "salt", "iterationCount", "contentToVerify", "signatureToVerify");
            let length = 0;
            switch (parameters.hashAlgorithm.toLowerCase()) {
                case "sha-1":
                    length = 160;
                    break;
                case "sha-256":
                    length = 256;
                    break;
                case "sha-384":
                    length = 384;
                    break;
                case "sha-512":
                    length = 512;
                    break;
                default:
                    throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${parameters.hashAlgorithm}`);
            }
            const hmacAlgorithm = {
                name: "HMAC",
                length,
                hash: {
                    name: parameters.hashAlgorithm
                }
            };
            const pkcsKey = await makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount);
            const hmacKey = await this.importKey("raw", new Uint8Array(pkcsKey), hmacAlgorithm, false, ["verify"]);
            return this.verify(hmacAlgorithm, hmacKey, new Uint8Array(parameters.signatureToVerify), new Uint8Array(parameters.contentToVerify));
        }
        async getSignatureParameters(privateKey, hashAlgorithm = "SHA-1") {
            this.getOIDByAlgorithm({ name: hashAlgorithm }, true, "hashAlgorithm");
            const signatureAlgorithm = new AlgorithmIdentifier();
            const parameters = this.getAlgorithmParameters(privateKey.algorithm.name, "sign");
            if (!Object.keys(parameters.algorithm).length) {
                throw new Error("Parameter 'algorithm' is empty");
            }
            const algorithm = parameters.algorithm;
            algorithm.hash.name = hashAlgorithm;
            switch (privateKey.algorithm.name.toUpperCase()) {
                case "RSASSA-PKCS1-V1_5":
                case "ECDSA":
                    signatureAlgorithm.algorithmId = this.getOIDByAlgorithm(algorithm, true);
                    break;
                case "RSA-PSS":
                    {
                        switch (hashAlgorithm.toUpperCase()) {
                            case "SHA-256":
                                algorithm.saltLength = 32;
                                break;
                            case "SHA-384":
                                algorithm.saltLength = 48;
                                break;
                            case "SHA-512":
                                algorithm.saltLength = 64;
                                break;
                        }
                        const paramsObject = {};
                        if (hashAlgorithm.toUpperCase() !== "SHA-1") {
                            const hashAlgorithmOID = this.getOIDByAlgorithm({ name: hashAlgorithm }, true, "hashAlgorithm");
                            paramsObject.hashAlgorithm = new AlgorithmIdentifier({
                                algorithmId: hashAlgorithmOID,
                                algorithmParams: new Null()
                            });
                            paramsObject.maskGenAlgorithm = new AlgorithmIdentifier({
                                algorithmId: "1.2.840.113549.1.1.8",
                                algorithmParams: paramsObject.hashAlgorithm.toSchema()
                            });
                        }
                        if (algorithm.saltLength !== 20)
                            paramsObject.saltLength = algorithm.saltLength;
                        const pssParameters = new RSASSAPSSParams(paramsObject);
                        signatureAlgorithm.algorithmId = "1.2.840.113549.1.1.10";
                        signatureAlgorithm.algorithmParams = pssParameters.toSchema();
                    }
                    break;
                default:
                    throw new Error(`Unsupported signature algorithm: ${privateKey.algorithm.name}`);
            }
            return {
                signatureAlgorithm,
                parameters
            };
        }
        async signWithPrivateKey(data, privateKey, parameters) {
            const signature = await this.sign(parameters.algorithm, privateKey, data);
            if (parameters.algorithm.name === "ECDSA") {
                return createCMSECDSASignature(signature);
            }
            return signature;
        }
        fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm) {
            const parameters = {};
            const shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
            if (shaAlgorithm === EMPTY_STRING)
                throw new Error(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
            let algorithmId;
            if (signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10")
                algorithmId = signatureAlgorithm.algorithmId;
            else
                algorithmId = publicKeyInfo.algorithm.algorithmId;
            const algorithmObject = this.getAlgorithmByOID(algorithmId, true);
            parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importKey");
            if ("hash" in parameters.algorithm.algorithm)
                parameters.algorithm.algorithm.hash.name = shaAlgorithm;
            if (algorithmObject.name === "ECDSA") {
                const publicKeyAlgorithm = publicKeyInfo.algorithm;
                if (!publicKeyAlgorithm.algorithmParams) {
                    throw new Error("Algorithm parameters for ECDSA public key are missed");
                }
                const publicKeyAlgorithmParams = publicKeyAlgorithm.algorithmParams;
                if ("idBlock" in publicKeyAlgorithm.algorithmParams) {
                    if (!((publicKeyAlgorithmParams.idBlock.tagClass === 1) && (publicKeyAlgorithmParams.idBlock.tagNumber === 6))) {
                        throw new Error("Incorrect type for ECDSA public key parameters");
                    }
                }
                const curveObject = this.getAlgorithmByOID(publicKeyAlgorithmParams.valueBlock.toString(), true);
                parameters.algorithm.algorithm.namedCurve = curveObject.name;
            }
            return parameters;
        }
        async getPublicKey(publicKeyInfo, signatureAlgorithm, parameters) {
            if (!parameters) {
                parameters = this.fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm);
            }
            const publicKeyInfoBuffer = publicKeyInfo.toSchema().toBER(false);
            return this.importKey("spki", publicKeyInfoBuffer, parameters.algorithm.algorithm, true, parameters.algorithm.usages);
        }
        async verifyWithPublicKey(data, signature, publicKeyInfo, signatureAlgorithm, shaAlgorithm) {
            let publicKey;
            if (!shaAlgorithm) {
                shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
                if (!shaAlgorithm)
                    throw new Error(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
                publicKey = await this.getPublicKey(publicKeyInfo, signatureAlgorithm);
            }
            else {
                const parameters = {};
                let algorithmId;
                if (signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10")
                    algorithmId = signatureAlgorithm.algorithmId;
                else
                    algorithmId = publicKeyInfo.algorithm.algorithmId;
                const algorithmObject = this.getAlgorithmByOID(algorithmId, true);
                parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importKey");
                if ("hash" in parameters.algorithm.algorithm)
                    parameters.algorithm.algorithm.hash.name = shaAlgorithm;
                if (algorithmObject.name === "ECDSA") {
                    let algorithmParamsChecked = false;
                    if (("algorithmParams" in publicKeyInfo.algorithm) === true) {
                        if ("idBlock" in publicKeyInfo.algorithm.algorithmParams) {
                            if ((publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1) && (publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6))
                                algorithmParamsChecked = true;
                        }
                    }
                    if (algorithmParamsChecked === false) {
                        throw new Error("Incorrect type for ECDSA public key parameters");
                    }
                    const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString(), true);
                    parameters.algorithm.algorithm.namedCurve = curveObject.name;
                }
                publicKey = await this.getPublicKey(publicKeyInfo, null, parameters);
            }
            const algorithm = this.getAlgorithmParameters(publicKey.algorithm.name, "verify");
            if ("hash" in algorithm.algorithm)
                algorithm.algorithm.hash.name = shaAlgorithm;
            let signatureValue = signature.valueBlock.valueHexView;
            if (publicKey.algorithm.name === "ECDSA") {
                const namedCurve = ECNamedCurves.find(publicKey.algorithm.namedCurve);
                if (!namedCurve) {
                    throw new Error("Unsupported named curve in use");
                }
                const asn1 = fromBER(signatureValue);
                AsnError.assert(asn1, "Signature value");
                signatureValue = createECDSASignatureFromCMS(asn1.result, namedCurve.size);
            }
            if (publicKey.algorithm.name === "RSA-PSS") {
                const pssParameters = new RSASSAPSSParams({ schema: signatureAlgorithm.algorithmParams });
                if ("saltLength" in pssParameters)
                    algorithm.algorithm.saltLength = pssParameters.saltLength;
                else
                    algorithm.algorithm.saltLength = 20;
                let hashAlgo = "SHA-1";
                if ("hashAlgorithm" in pssParameters) {
                    const hashAlgorithm = this.getAlgorithmByOID(pssParameters.hashAlgorithm.algorithmId, true);
                    hashAlgo = hashAlgorithm.name;
                }
                algorithm.algorithm.hash.name = hashAlgo;
            }
            return this.verify(algorithm.algorithm, publicKey, signatureValue, data);
        }
    }

    let engine = {
        name: "none",
        crypto: null,
    };
    function isCryptoEngine(engine) {
        return engine
            && typeof engine === "object"
            && "crypto" in engine
            ? true
            : false;
    }
    function setEngine(name, ...args) {
        let crypto = null;
        if (args.length === 1) {
            crypto = args[0];
        }
        else {
            const cryptoArg = args[0];
            const subtleArg = args[1];
            if (isCryptoEngine(subtleArg)) {
                crypto = subtleArg;
            }
            if (isCryptoEngine(cryptoArg)) {
                crypto = cryptoArg;
            }
            if ("subtle" in cryptoArg && "getRandomValues" in cryptoArg) {
                crypto = new CryptoEngine({
                    crypto: cryptoArg,
                });
            }
        }
        if ((typeof process !== "undefined") && ("pid" in process) && (typeof global !== "undefined") && (typeof window === "undefined")) {
            if (typeof global[process.pid] === "undefined") {
                global[process.pid] = {};
            }
            else {
                if (typeof global[process.pid] !== "object") {
                    throw new Error(`Name global.${process.pid} already exists and it is not an object`);
                }
            }
            if (typeof global[process.pid].pkijs === "undefined") {
                global[process.pid].pkijs = {};
            }
            else {
                if (typeof global[process.pid].pkijs !== "object") {
                    throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);
                }
            }
            global[process.pid].pkijs.engine = {
                name: name,
                crypto,
            };
        }
        else {
            if (engine.name !== name) {
                engine = {
                    name: name,
                    crypto,
                };
            }
        }
    }
    function getEngine() {
        if ((typeof process !== "undefined") && ("pid" in process) && (typeof global !== "undefined") && (typeof window === "undefined")) {
            let _engine;
            try {
                _engine = global[process.pid].pkijs.engine;
            }
            catch (ex) {
                throw new Error("Please call 'setEngine' before call to 'getEngine'");
            }
            return _engine;
        }
        return engine;
    }
    function getCrypto(safety) {
        const _engine = getEngine();
        if (!_engine.crypto && safety) {
            throw new Error("Unable to create WebCrypto object");
        }
        return _engine.crypto;
    }
    function createCMSECDSASignature(signatureBuffer) {
        if ((signatureBuffer.byteLength % 2) !== 0)
            return EMPTY_BUFFER;
        const length = signatureBuffer.byteLength / 2;
        const rBuffer = new ArrayBuffer(length);
        const rView = new Uint8Array(rBuffer);
        rView.set(new Uint8Array(signatureBuffer, 0, length));
        const rInteger = new Integer({ valueHex: rBuffer });
        const sBuffer = new ArrayBuffer(length);
        const sView = new Uint8Array(sBuffer);
        sView.set(new Uint8Array(signatureBuffer, length, length));
        const sInteger = new Integer({ valueHex: sBuffer });
        return (new Sequence({
            value: [
                rInteger.convertToDER(),
                sInteger.convertToDER()
            ]
        })).toBER(false);
    }
    function createECDSASignatureFromCMS(cmsSignature, pointSize) {
        if (!(cmsSignature instanceof Sequence
            && cmsSignature.valueBlock.value.length === 2
            && cmsSignature.valueBlock.value[0] instanceof Integer
            && cmsSignature.valueBlock.value[1] instanceof Integer))
            return EMPTY_BUFFER;
        const rValueView = cmsSignature.valueBlock.value[0].convertFromDER().valueBlock.valueHexView;
        const sValueView = cmsSignature.valueBlock.value[1].convertFromDER().valueBlock.valueHexView;
        const res = new Uint8Array(pointSize * 2);
        res.set(rValueView, pointSize - rValueView.byteLength);
        res.set(sValueView, (2 * pointSize) - sValueView.byteLength);
        return res.buffer;
    }
    async function kdfWithCounter(hashFunction, zBuffer, Counter, SharedInfo, crypto) {
        switch (hashFunction.toUpperCase()) {
            case "SHA-1":
            case "SHA-256":
            case "SHA-384":
            case "SHA-512":
                break;
            default:
                throw new ArgumentError(`Unknown hash function: ${hashFunction}`);
        }
        ArgumentError.assert(zBuffer, "zBuffer", "ArrayBuffer");
        if (zBuffer.byteLength === 0)
            throw new ArgumentError("'zBuffer' has zero length, error");
        ArgumentError.assert(SharedInfo, "SharedInfo", "ArrayBuffer");
        if (Counter > 255)
            throw new ArgumentError("Please set 'Counter' argument to value less or equal to 255");
        const counterBuffer = new ArrayBuffer(4);
        const counterView = new Uint8Array(counterBuffer);
        counterView[0] = 0x00;
        counterView[1] = 0x00;
        counterView[2] = 0x00;
        counterView[3] = Counter;
        let combinedBuffer = EMPTY_BUFFER;
        combinedBuffer = utilConcatBuf(combinedBuffer, zBuffer);
        combinedBuffer = utilConcatBuf(combinedBuffer, counterBuffer);
        combinedBuffer = utilConcatBuf(combinedBuffer, SharedInfo);
        const result = await crypto.digest({ name: hashFunction }, combinedBuffer);
        return {
            counter: Counter,
            result
        };
    }
    async function kdf(hashFunction, Zbuffer, keydatalen, SharedInfo, crypto = getCrypto(true)) {
        let hashLength = 0;
        let maxCounter = 1;
        switch (hashFunction.toUpperCase()) {
            case "SHA-1":
                hashLength = 160;
                break;
            case "SHA-256":
                hashLength = 256;
                break;
            case "SHA-384":
                hashLength = 384;
                break;
            case "SHA-512":
                hashLength = 512;
                break;
            default:
                throw new ArgumentError(`Unknown hash function: ${hashFunction}`);
        }
        ArgumentError.assert(Zbuffer, "Zbuffer", "ArrayBuffer");
        if (Zbuffer.byteLength === 0)
            throw new ArgumentError("'Zbuffer' has zero length, error");
        ArgumentError.assert(SharedInfo, "SharedInfo", "ArrayBuffer");
        const quotient = keydatalen / hashLength;
        if (Math.floor(quotient) > 0) {
            maxCounter = Math.floor(quotient);
            if ((quotient - maxCounter) > 0)
                maxCounter++;
        }
        const incomingResult = [];
        for (let i = 1; i <= maxCounter; i++)
            incomingResult.push(await kdfWithCounter(hashFunction, Zbuffer, i, SharedInfo, crypto));
        let combinedBuffer = EMPTY_BUFFER;
        let currentCounter = 1;
        let found = true;
        while (found) {
            found = false;
            for (const result of incomingResult) {
                if (result.counter === currentCounter) {
                    combinedBuffer = utilConcatBuf(combinedBuffer, result.result);
                    found = true;
                    break;
                }
            }
            currentCounter++;
        }
        keydatalen >>= 3;
        if (combinedBuffer.byteLength > keydatalen) {
            const newBuffer = new ArrayBuffer(keydatalen);
            const newView = new Uint8Array(newBuffer);
            const combinedView = new Uint8Array(combinedBuffer);
            for (let i = 0; i < keydatalen; i++)
                newView[i] = combinedView[i];
            return newBuffer;
        }
        return combinedBuffer;
    }

    const VERSION$i = "version";
    const LOG_ID = "logID";
    const EXTENSIONS$6 = "extensions";
    const TIMESTAMP = "timestamp";
    const HASH_ALGORITHM$3 = "hashAlgorithm";
    const SIGNATURE_ALGORITHM$8 = "signatureAlgorithm";
    const SIGNATURE$7 = "signature";
    const NONE = "none";
    const MD5 = "md5";
    const SHA1 = "sha1";
    const SHA224 = "sha224";
    const SHA256 = "sha256";
    const SHA384 = "sha384";
    const SHA512 = "sha512";
    const ANONYMOUS = "anonymous";
    const RSA = "rsa";
    const DSA = "dsa";
    const ECDSA = "ecdsa";
    class SignedCertificateTimestamp extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$i, SignedCertificateTimestamp.defaultValues(VERSION$i));
            this.logID = getParametersValue(parameters, LOG_ID, SignedCertificateTimestamp.defaultValues(LOG_ID));
            this.timestamp = getParametersValue(parameters, TIMESTAMP, SignedCertificateTimestamp.defaultValues(TIMESTAMP));
            this.extensions = getParametersValue(parameters, EXTENSIONS$6, SignedCertificateTimestamp.defaultValues(EXTENSIONS$6));
            this.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM$3, SignedCertificateTimestamp.defaultValues(HASH_ALGORITHM$3));
            this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$8, SignedCertificateTimestamp.defaultValues(SIGNATURE_ALGORITHM$8));
            this.signature = getParametersValue(parameters, SIGNATURE$7, SignedCertificateTimestamp.defaultValues(SIGNATURE$7));
            if ("stream" in parameters && parameters.stream) {
                this.fromStream(parameters.stream);
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$i:
                    return 0;
                case LOG_ID:
                case EXTENSIONS$6:
                    return EMPTY_BUFFER;
                case TIMESTAMP:
                    return new Date(0);
                case HASH_ALGORITHM$3:
                case SIGNATURE_ALGORITHM$8:
                    return EMPTY_STRING;
                case SIGNATURE$7:
                    return new Any();
                default:
                    return super.defaultValues(memberName);
            }
        }
        fromSchema(schema) {
            if ((schema instanceof RawData) === false)
                throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");
            const seqStream = new SeqStream({
                stream: new ByteStream({
                    buffer: schema.data
                })
            });
            this.fromStream(seqStream);
        }
        fromStream(stream) {
            const blockLength = stream.getUint16();
            this.version = (stream.getBlock(1))[0];
            if (this.version === 0) {
                this.logID = (new Uint8Array(stream.getBlock(32))).buffer.slice(0);
                this.timestamp = new Date(utilFromBase(new Uint8Array(stream.getBlock(8)), 8));
                const extensionsLength = stream.getUint16();
                this.extensions = (new Uint8Array(stream.getBlock(extensionsLength))).buffer.slice(0);
                switch ((stream.getBlock(1))[0]) {
                    case 0:
                        this.hashAlgorithm = NONE;
                        break;
                    case 1:
                        this.hashAlgorithm = MD5;
                        break;
                    case 2:
                        this.hashAlgorithm = SHA1;
                        break;
                    case 3:
                        this.hashAlgorithm = SHA224;
                        break;
                    case 4:
                        this.hashAlgorithm = SHA256;
                        break;
                    case 5:
                        this.hashAlgorithm = SHA384;
                        break;
                    case 6:
                        this.hashAlgorithm = SHA512;
                        break;
                    default:
                        throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
                }
                switch ((stream.getBlock(1))[0]) {
                    case 0:
                        this.signatureAlgorithm = ANONYMOUS;
                        break;
                    case 1:
                        this.signatureAlgorithm = RSA;
                        break;
                    case 2:
                        this.signatureAlgorithm = DSA;
                        break;
                    case 3:
                        this.signatureAlgorithm = ECDSA;
                        break;
                    default:
                        throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
                }
                const signatureLength = stream.getUint16();
                const signatureData = new Uint8Array(stream.getBlock(signatureLength)).buffer.slice(0);
                const asn1 = fromBER(signatureData);
                AsnError.assert(asn1, "SignedCertificateTimestamp");
                this.signature = asn1.result;
                if (blockLength !== (47 + extensionsLength + signatureLength)) {
                    throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
                }
            }
        }
        toSchema() {
            const stream = this.toStream();
            return new RawData({ data: stream.stream.buffer });
        }
        toStream() {
            const stream = new SeqStream();
            stream.appendUint16(47 + this.extensions.byteLength + this.signature.valueBeforeDecodeView.byteLength);
            stream.appendChar(this.version);
            stream.appendView(new Uint8Array(this.logID));
            const timeBuffer = new ArrayBuffer(8);
            const timeView = new Uint8Array(timeBuffer);
            const baseArray = utilToBase(this.timestamp.valueOf(), 8);
            timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
            stream.appendView(timeView);
            stream.appendUint16(this.extensions.byteLength);
            if (this.extensions.byteLength)
                stream.appendView(new Uint8Array(this.extensions));
            let _hashAlgorithm;
            switch (this.hashAlgorithm.toLowerCase()) {
                case NONE:
                    _hashAlgorithm = 0;
                    break;
                case MD5:
                    _hashAlgorithm = 1;
                    break;
                case SHA1:
                    _hashAlgorithm = 2;
                    break;
                case SHA224:
                    _hashAlgorithm = 3;
                    break;
                case SHA256:
                    _hashAlgorithm = 4;
                    break;
                case SHA384:
                    _hashAlgorithm = 5;
                    break;
                case SHA512:
                    _hashAlgorithm = 6;
                    break;
                default:
                    throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`);
            }
            stream.appendChar(_hashAlgorithm);
            let _signatureAlgorithm;
            switch (this.signatureAlgorithm.toLowerCase()) {
                case ANONYMOUS:
                    _signatureAlgorithm = 0;
                    break;
                case RSA:
                    _signatureAlgorithm = 1;
                    break;
                case DSA:
                    _signatureAlgorithm = 2;
                    break;
                case ECDSA:
                    _signatureAlgorithm = 3;
                    break;
                default:
                    throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`);
            }
            stream.appendChar(_signatureAlgorithm);
            const _signature = this.signature.toBER(false);
            stream.appendUint16(_signature.byteLength);
            stream.appendView(new Uint8Array(_signature));
            return stream;
        }
        toJSON() {
            return {
                version: this.version,
                logID: bufferToHexCodes(this.logID),
                timestamp: this.timestamp,
                extensions: bufferToHexCodes(this.extensions),
                hashAlgorithm: this.hashAlgorithm,
                signatureAlgorithm: this.signatureAlgorithm,
                signature: this.signature.toJSON()
            };
        }
        async verify(logs, data, dataType = 0, crypto = getCrypto(true)) {
            const logId = toBase64(arrayBufferToString(this.logID));
            let publicKeyBase64 = null;
            const stream = new SeqStream();
            for (const log of logs) {
                if (log.log_id === logId) {
                    publicKeyBase64 = log.key;
                    break;
                }
            }
            if (!publicKeyBase64) {
                throw new Error(`Public key not found for CT with logId: ${logId}`);
            }
            const pki = stringToArrayBuffer(fromBase64(publicKeyBase64));
            const publicKeyInfo = PublicKeyInfo.fromBER(pki);
            stream.appendChar(0x00);
            stream.appendChar(0x00);
            const timeBuffer = new ArrayBuffer(8);
            const timeView = new Uint8Array(timeBuffer);
            const baseArray = utilToBase(this.timestamp.valueOf(), 8);
            timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
            stream.appendView(timeView);
            stream.appendUint16(dataType);
            if (dataType === 0)
                stream.appendUint24(data.byteLength);
            stream.appendView(new Uint8Array(data));
            stream.appendUint16(this.extensions.byteLength);
            if (this.extensions.byteLength !== 0)
                stream.appendView(new Uint8Array(this.extensions));
            return crypto.verifyWithPublicKey(stream.buffer.slice(0, stream.length), { valueBlock: { valueHex: this.signature.toBER(false) } }, publicKeyInfo, { algorithmId: EMPTY_STRING }, "SHA-256");
        }
    }
    SignedCertificateTimestamp.CLASS_NAME = "SignedCertificateTimestamp";

    const TIMESTAMPS = "timestamps";
    class SignedCertificateTimestampList extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.timestamps = getParametersValue(parameters, TIMESTAMPS, SignedCertificateTimestampList.defaultValues(TIMESTAMPS));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TIMESTAMPS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case TIMESTAMPS:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            var _a;
            const names = getParametersValue(parameters, "names", {});
            (_a = names.optional) !== null && _a !== void 0 ? _a : (names.optional = false);
            return (new OctetString({
                name: (names.blockName || "SignedCertificateTimestampList"),
                optional: names.optional
            }));
        }
        fromSchema(schema) {
            if ((schema instanceof OctetString) === false) {
                throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
            }
            const seqStream = new SeqStream({
                stream: new ByteStream({
                    buffer: schema.valueBlock.valueHex
                })
            });
            const dataLength = seqStream.getUint16();
            if (dataLength !== seqStream.length) {
                throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
            }
            while (seqStream.length) {
                this.timestamps.push(new SignedCertificateTimestamp({ stream: seqStream }));
            }
        }
        toSchema() {
            const stream = new SeqStream();
            let overallLength = 0;
            const timestampsData = [];
            for (const timestamp of this.timestamps) {
                const timestampStream = timestamp.toStream();
                timestampsData.push(timestampStream);
                overallLength += timestampStream.stream.buffer.byteLength;
            }
            stream.appendUint16(overallLength);
            for (const timestamp of timestampsData) {
                stream.appendView(timestamp.stream.view);
            }
            return new OctetString({ valueHex: stream.stream.buffer.slice(0) });
        }
        toJSON() {
            return {
                timestamps: Array.from(this.timestamps, o => o.toJSON())
            };
        }
    }
    SignedCertificateTimestampList.CLASS_NAME = "SignedCertificateTimestampList";

    const ATTRIBUTES$4 = "attributes";
    const CLEAR_PROPS$11 = [
        ATTRIBUTES$4
    ];
    class SubjectDirectoryAttributes extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.attributes = getParametersValue(parameters, ATTRIBUTES$4, SubjectDirectoryAttributes.defaultValues(ATTRIBUTES$4));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ATTRIBUTES$4:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.attributes || EMPTY_STRING),
                        value: Attribute.schema()
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$11);
            const asn1 = compareSchema(schema, schema, SubjectDirectoryAttributes.schema({
                names: {
                    attributes: ATTRIBUTES$4
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.attributes = Array.from(asn1.result.attributes, element => new Attribute({ schema: element }));
        }
        toSchema() {
            return (new Sequence({
                value: Array.from(this.attributes, o => o.toSchema())
            }));
        }
        toJSON() {
            return {
                attributes: Array.from(this.attributes, o => o.toJSON())
            };
        }
    }
    SubjectDirectoryAttributes.CLASS_NAME = "SubjectDirectoryAttributes";

    class ExtensionValueFactory {
        static getItems() {
            if (!this.types) {
                this.types = {};
                ExtensionValueFactory.register(id_SubjectAltName, "SubjectAltName", AltName);
                ExtensionValueFactory.register(id_IssuerAltName, "IssuerAltName", AltName);
                ExtensionValueFactory.register(id_AuthorityKeyIdentifier, "AuthorityKeyIdentifier", AuthorityKeyIdentifier);
                ExtensionValueFactory.register(id_BasicConstraints, "BasicConstraints", BasicConstraints);
                ExtensionValueFactory.register(id_MicrosoftCaVersion, "MicrosoftCaVersion", CAVersion);
                ExtensionValueFactory.register(id_CertificatePolicies, "CertificatePolicies", CertificatePolicies);
                ExtensionValueFactory.register(id_MicrosoftAppPolicies, "CertificatePoliciesMicrosoft", CertificatePolicies);
                ExtensionValueFactory.register(id_MicrosoftCertTemplateV2, "MicrosoftCertTemplateV2", CertificateTemplate);
                ExtensionValueFactory.register(id_CRLDistributionPoints, "CRLDistributionPoints", CRLDistributionPoints);
                ExtensionValueFactory.register(id_FreshestCRL, "FreshestCRL", CRLDistributionPoints);
                ExtensionValueFactory.register(id_ExtKeyUsage, "ExtKeyUsage", ExtKeyUsage);
                ExtensionValueFactory.register(id_CertificateIssuer, "CertificateIssuer", GeneralNames);
                ExtensionValueFactory.register(id_AuthorityInfoAccess, "AuthorityInfoAccess", InfoAccess);
                ExtensionValueFactory.register(id_SubjectInfoAccess, "SubjectInfoAccess", InfoAccess);
                ExtensionValueFactory.register(id_IssuingDistributionPoint, "IssuingDistributionPoint", IssuingDistributionPoint);
                ExtensionValueFactory.register(id_NameConstraints, "NameConstraints", NameConstraints);
                ExtensionValueFactory.register(id_PolicyConstraints, "PolicyConstraints", PolicyConstraints);
                ExtensionValueFactory.register(id_PolicyMappings, "PolicyMappings", PolicyMappings);
                ExtensionValueFactory.register(id_PrivateKeyUsagePeriod, "PrivateKeyUsagePeriod", PrivateKeyUsagePeriod);
                ExtensionValueFactory.register(id_QCStatements, "QCStatements", QCStatements);
                ExtensionValueFactory.register(id_SignedCertificateTimestampList, "SignedCertificateTimestampList", SignedCertificateTimestampList);
                ExtensionValueFactory.register(id_SubjectDirectoryAttributes, "SubjectDirectoryAttributes", SubjectDirectoryAttributes);
            }
            return this.types;
        }
        static fromBER(id, raw) {
            const asn1 = fromBER(raw);
            if (asn1.offset === -1) {
                return null;
            }
            const item = this.find(id);
            if (item) {
                try {
                    return new item.type({ schema: asn1.result });
                }
                catch (ex) {
                    const res = new item.type();
                    res.parsingError = `Incorrectly formatted value of extension ${item.name} (${id})`;
                    return res;
                }
            }
            return asn1.result;
        }
        static find(id) {
            const types = this.getItems();
            return types[id] || null;
        }
        static register(id, name, type) {
            this.getItems()[id] = { name, type };
        }
    }

    const EXTN_ID = "extnID";
    const CRITICAL = "critical";
    const EXTN_VALUE = "extnValue";
    const PARSED_VALUE$5 = "parsedValue";
    const CLEAR_PROPS$10 = [
        EXTN_ID,
        CRITICAL,
        EXTN_VALUE
    ];
    class Extension extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.extnID = getParametersValue(parameters, EXTN_ID, Extension.defaultValues(EXTN_ID));
            this.critical = getParametersValue(parameters, CRITICAL, Extension.defaultValues(CRITICAL));
            if (EXTN_VALUE in parameters) {
                this.extnValue = new OctetString({ valueHex: parameters.extnValue });
            }
            else {
                this.extnValue = Extension.defaultValues(EXTN_VALUE);
            }
            if (PARSED_VALUE$5 in parameters) {
                this.parsedValue = getParametersValue(parameters, PARSED_VALUE$5, Extension.defaultValues(PARSED_VALUE$5));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        get parsedValue() {
            if (this._parsedValue === undefined) {
                const parsedValue = ExtensionValueFactory.fromBER(this.extnID, this.extnValue.valueBlock.valueHexView);
                this._parsedValue = parsedValue;
            }
            return this._parsedValue || undefined;
        }
        set parsedValue(value) {
            this._parsedValue = value;
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case EXTN_ID:
                    return EMPTY_STRING;
                case CRITICAL:
                    return false;
                case EXTN_VALUE:
                    return new OctetString();
                case PARSED_VALUE$5:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.extnID || EMPTY_STRING) }),
                    new Boolean$1({
                        name: (names.critical || EMPTY_STRING),
                        optional: true
                    }),
                    new OctetString({ name: (names.extnValue || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$10);
            const asn1 = compareSchema(schema, schema, Extension.schema({
                names: {
                    extnID: EXTN_ID,
                    critical: CRITICAL,
                    extnValue: EXTN_VALUE
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.extnID = asn1.result.extnID.valueBlock.toString();
            if (CRITICAL in asn1.result) {
                this.critical = asn1.result.critical.valueBlock.value;
            }
            this.extnValue = asn1.result.extnValue;
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new ObjectIdentifier({ value: this.extnID }));
            if (this.critical !== Extension.defaultValues(CRITICAL)) {
                outputArray.push(new Boolean$1({ value: this.critical }));
            }
            outputArray.push(this.extnValue);
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const object = {
                extnID: this.extnID,
                extnValue: this.extnValue.toJSON(),
            };
            if (this.critical !== Extension.defaultValues(CRITICAL)) {
                object.critical = this.critical;
            }
            if (this.parsedValue && this.parsedValue.toJSON) {
                object.parsedValue = this.parsedValue.toJSON();
            }
            return object;
        }
    }
    Extension.CLASS_NAME = "Extension";

    const EXTENSIONS$5 = "extensions";
    const CLEAR_PROPS$$ = [
        EXTENSIONS$5,
    ];
    class Extensions extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.extensions = getParametersValue(parameters, EXTENSIONS$5, Extensions.defaultValues(EXTENSIONS$5));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case EXTENSIONS$5:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}, optional = false) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                optional,
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.extensions || EMPTY_STRING),
                        value: Extension.schema(names.extension || {})
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$$);
            const asn1 = compareSchema(schema, schema, Extensions.schema({
                names: {
                    extensions: EXTENSIONS$5
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.extensions = Array.from(asn1.result.extensions, element => new Extension({ schema: element }));
        }
        toSchema() {
            return (new Sequence({
                value: Array.from(this.extensions, o => o.toSchema())
            }));
        }
        toJSON() {
            return {
                extensions: this.extensions.map(o => o.toJSON())
            };
        }
    }
    Extensions.CLASS_NAME = "Extensions";

    const ISSUER$5 = "issuer";
    const SERIAL_NUMBER$6 = "serialNumber";
    const ISSUER_UID = "issuerUID";
    const CLEAR_PROPS$_ = [
        ISSUER$5,
        SERIAL_NUMBER$6,
        ISSUER_UID,
    ];
    class IssuerSerial extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.issuer = getParametersValue(parameters, ISSUER$5, IssuerSerial.defaultValues(ISSUER$5));
            this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$6, IssuerSerial.defaultValues(SERIAL_NUMBER$6));
            if (ISSUER_UID in parameters) {
                this.issuerUID = getParametersValue(parameters, ISSUER_UID, IssuerSerial.defaultValues(ISSUER_UID));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ISSUER$5:
                    return new GeneralNames();
                case SERIAL_NUMBER$6:
                    return new Integer();
                case ISSUER_UID:
                    return new BitString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    GeneralNames.schema(names.issuer || {}),
                    new Integer({ name: (names.serialNumber || EMPTY_STRING) }),
                    new BitString({
                        optional: true,
                        name: (names.issuerUID || EMPTY_STRING)
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$_);
            const asn1 = compareSchema(schema, schema, IssuerSerial.schema({
                names: {
                    issuer: {
                        names: {
                            blockName: ISSUER$5
                        }
                    },
                    serialNumber: SERIAL_NUMBER$6,
                    issuerUID: ISSUER_UID
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.issuer = new GeneralNames({ schema: asn1.result.issuer });
            this.serialNumber = asn1.result.serialNumber;
            if (ISSUER_UID in asn1.result)
                this.issuerUID = asn1.result.issuerUID;
        }
        toSchema() {
            const result = new Sequence({
                value: [
                    this.issuer.toSchema(),
                    this.serialNumber
                ]
            });
            if (this.issuerUID) {
                result.valueBlock.value.push(this.issuerUID);
            }
            return result;
        }
        toJSON() {
            const result = {
                issuer: this.issuer.toJSON(),
                serialNumber: this.serialNumber.toJSON()
            };
            if (this.issuerUID) {
                result.issuerUID = this.issuerUID.toJSON();
            }
            return result;
        }
    }
    IssuerSerial.CLASS_NAME = "IssuerSerial";

    const VERSION$h = "version";
    const BASE_CERTIFICATE_ID$2 = "baseCertificateID";
    const SUBJECT_NAME = "subjectName";
    const ISSUER$4 = "issuer";
    const SIGNATURE$6 = "signature";
    const SERIAL_NUMBER$5 = "serialNumber";
    const ATTR_CERT_VALIDITY_PERIOD$1 = "attrCertValidityPeriod";
    const ATTRIBUTES$3 = "attributes";
    const ISSUER_UNIQUE_ID$2 = "issuerUniqueID";
    const EXTENSIONS$4 = "extensions";
    const CLEAR_PROPS$Z = [
        VERSION$h,
        BASE_CERTIFICATE_ID$2,
        SUBJECT_NAME,
        ISSUER$4,
        SIGNATURE$6,
        SERIAL_NUMBER$5,
        ATTR_CERT_VALIDITY_PERIOD$1,
        ATTRIBUTES$3,
        ISSUER_UNIQUE_ID$2,
        EXTENSIONS$4,
    ];
    class AttributeCertificateInfoV1 extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$h, AttributeCertificateInfoV1.defaultValues(VERSION$h));
            if (BASE_CERTIFICATE_ID$2 in parameters) {
                this.baseCertificateID = getParametersValue(parameters, BASE_CERTIFICATE_ID$2, AttributeCertificateInfoV1.defaultValues(BASE_CERTIFICATE_ID$2));
            }
            if (SUBJECT_NAME in parameters) {
                this.subjectName = getParametersValue(parameters, SUBJECT_NAME, AttributeCertificateInfoV1.defaultValues(SUBJECT_NAME));
            }
            this.issuer = getParametersValue(parameters, ISSUER$4, AttributeCertificateInfoV1.defaultValues(ISSUER$4));
            this.signature = getParametersValue(parameters, SIGNATURE$6, AttributeCertificateInfoV1.defaultValues(SIGNATURE$6));
            this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$5, AttributeCertificateInfoV1.defaultValues(SERIAL_NUMBER$5));
            this.attrCertValidityPeriod = getParametersValue(parameters, ATTR_CERT_VALIDITY_PERIOD$1, AttributeCertificateInfoV1.defaultValues(ATTR_CERT_VALIDITY_PERIOD$1));
            this.attributes = getParametersValue(parameters, ATTRIBUTES$3, AttributeCertificateInfoV1.defaultValues(ATTRIBUTES$3));
            if (ISSUER_UNIQUE_ID$2 in parameters)
                this.issuerUniqueID = getParametersValue(parameters, ISSUER_UNIQUE_ID$2, AttributeCertificateInfoV1.defaultValues(ISSUER_UNIQUE_ID$2));
            if (EXTENSIONS$4 in parameters) {
                this.extensions = getParametersValue(parameters, EXTENSIONS$4, AttributeCertificateInfoV1.defaultValues(EXTENSIONS$4));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$h:
                    return 0;
                case BASE_CERTIFICATE_ID$2:
                    return new IssuerSerial();
                case SUBJECT_NAME:
                    return new GeneralNames();
                case ISSUER$4:
                    return new GeneralNames();
                case SIGNATURE$6:
                    return new AlgorithmIdentifier();
                case SERIAL_NUMBER$5:
                    return new Integer();
                case ATTR_CERT_VALIDITY_PERIOD$1:
                    return new AttCertValidityPeriod();
                case ATTRIBUTES$3:
                    return [];
                case ISSUER_UNIQUE_ID$2:
                    return new BitString();
                case EXTENSIONS$4:
                    return new Extensions();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.version || EMPTY_STRING) }),
                    new Choice({
                        value: [
                            new Constructed({
                                name: (names.baseCertificateID || EMPTY_STRING),
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 0
                                },
                                value: IssuerSerial.schema().valueBlock.value
                            }),
                            new Constructed({
                                name: (names.subjectName || EMPTY_STRING),
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 1
                                },
                                value: GeneralNames.schema().valueBlock.value
                            }),
                        ]
                    }),
                    GeneralNames.schema({
                        names: {
                            blockName: (names.issuer || EMPTY_STRING)
                        }
                    }),
                    AlgorithmIdentifier.schema(names.signature || {}),
                    new Integer({ name: (names.serialNumber || EMPTY_STRING) }),
                    AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}),
                    new Sequence({
                        name: (names.attributes || EMPTY_STRING),
                        value: [
                            new Repeated({
                                value: Attribute.schema()
                            })
                        ]
                    }),
                    new BitString({
                        optional: true,
                        name: (names.issuerUniqueID || EMPTY_STRING)
                    }),
                    Extensions.schema(names.extensions || {}, true)
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$Z);
            const asn1 = compareSchema(schema, schema, AttributeCertificateInfoV1.schema({
                names: {
                    version: VERSION$h,
                    baseCertificateID: BASE_CERTIFICATE_ID$2,
                    subjectName: SUBJECT_NAME,
                    issuer: ISSUER$4,
                    signature: {
                        names: {
                            blockName: SIGNATURE$6
                        }
                    },
                    serialNumber: SERIAL_NUMBER$5,
                    attrCertValidityPeriod: {
                        names: {
                            blockName: ATTR_CERT_VALIDITY_PERIOD$1
                        }
                    },
                    attributes: ATTRIBUTES$3,
                    issuerUniqueID: ISSUER_UNIQUE_ID$2,
                    extensions: {
                        names: {
                            blockName: EXTENSIONS$4
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result.version.valueBlock.valueDec;
            if (BASE_CERTIFICATE_ID$2 in asn1.result) {
                this.baseCertificateID = new IssuerSerial({
                    schema: new Sequence({
                        value: asn1.result.baseCertificateID.valueBlock.value
                    })
                });
            }
            if (SUBJECT_NAME in asn1.result) {
                this.subjectName = new GeneralNames({
                    schema: new Sequence({
                        value: asn1.result.subjectName.valueBlock.value
                    })
                });
            }
            this.issuer = asn1.result.issuer;
            this.signature = new AlgorithmIdentifier({ schema: asn1.result.signature });
            this.serialNumber = asn1.result.serialNumber;
            this.attrCertValidityPeriod = new AttCertValidityPeriod({ schema: asn1.result.attrCertValidityPeriod });
            this.attributes = Array.from(asn1.result.attributes.valueBlock.value, element => new Attribute({ schema: element }));
            if (ISSUER_UNIQUE_ID$2 in asn1.result) {
                this.issuerUniqueID = asn1.result.issuerUniqueID;
            }
            if (EXTENSIONS$4 in asn1.result) {
                this.extensions = new Extensions({ schema: asn1.result.extensions });
            }
        }
        toSchema() {
            const result = new Sequence({
                value: [new Integer({ value: this.version })]
            });
            if (this.baseCertificateID) {
                result.valueBlock.value.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: this.baseCertificateID.toSchema().valueBlock.value
                }));
            }
            if (this.subjectName) {
                result.valueBlock.value.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: this.subjectName.toSchema().valueBlock.value
                }));
            }
            result.valueBlock.value.push(this.issuer.toSchema());
            result.valueBlock.value.push(this.signature.toSchema());
            result.valueBlock.value.push(this.serialNumber);
            result.valueBlock.value.push(this.attrCertValidityPeriod.toSchema());
            result.valueBlock.value.push(new Sequence({
                value: Array.from(this.attributes, o => o.toSchema())
            }));
            if (this.issuerUniqueID) {
                result.valueBlock.value.push(this.issuerUniqueID);
            }
            if (this.extensions) {
                result.valueBlock.value.push(this.extensions.toSchema());
            }
            return result;
        }
        toJSON() {
            const result = {
                version: this.version
            };
            if (this.baseCertificateID) {
                result.baseCertificateID = this.baseCertificateID.toJSON();
            }
            if (this.subjectName) {
                result.subjectName = this.subjectName.toJSON();
            }
            result.issuer = this.issuer.toJSON();
            result.signature = this.signature.toJSON();
            result.serialNumber = this.serialNumber.toJSON();
            result.attrCertValidityPeriod = this.attrCertValidityPeriod.toJSON();
            result.attributes = Array.from(this.attributes, o => o.toJSON());
            if (this.issuerUniqueID) {
                result.issuerUniqueID = this.issuerUniqueID.toJSON();
            }
            if (this.extensions) {
                result.extensions = this.extensions.toJSON();
            }
            return result;
        }
    }
    AttributeCertificateInfoV1.CLASS_NAME = "AttributeCertificateInfoV1";

    const ACINFO$1 = "acinfo";
    const SIGNATURE_ALGORITHM$7 = "signatureAlgorithm";
    const SIGNATURE_VALUE$4 = "signatureValue";
    const CLEAR_PROPS$Y = [
        ACINFO$1,
        SIGNATURE_VALUE$4,
        SIGNATURE_ALGORITHM$7
    ];
    class AttributeCertificateV1 extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.acinfo = getParametersValue(parameters, ACINFO$1, AttributeCertificateV1.defaultValues(ACINFO$1));
            this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$7, AttributeCertificateV1.defaultValues(SIGNATURE_ALGORITHM$7));
            this.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE$4, AttributeCertificateV1.defaultValues(SIGNATURE_VALUE$4));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ACINFO$1:
                    return new AttributeCertificateInfoV1();
                case SIGNATURE_ALGORITHM$7:
                    return new AlgorithmIdentifier();
                case SIGNATURE_VALUE$4:
                    return new BitString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    AttributeCertificateInfoV1.schema(names.acinfo || {}),
                    AlgorithmIdentifier.schema(names.signatureAlgorithm || {}),
                    new BitString({ name: (names.signatureValue || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$Y);
            const asn1 = compareSchema(schema, schema, AttributeCertificateV1.schema({
                names: {
                    acinfo: {
                        names: {
                            blockName: ACINFO$1
                        }
                    },
                    signatureAlgorithm: {
                        names: {
                            blockName: SIGNATURE_ALGORITHM$7
                        }
                    },
                    signatureValue: SIGNATURE_VALUE$4
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.acinfo = new AttributeCertificateInfoV1({ schema: asn1.result.acinfo });
            this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
            this.signatureValue = asn1.result.signatureValue;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    this.acinfo.toSchema(),
                    this.signatureAlgorithm.toSchema(),
                    this.signatureValue
                ]
            }));
        }
        toJSON() {
            return {
                acinfo: this.acinfo.toJSON(),
                signatureAlgorithm: this.signatureAlgorithm.toJSON(),
                signatureValue: this.signatureValue.toJSON(),
            };
        }
    }
    AttributeCertificateV1.CLASS_NAME = "AttributeCertificateV1";

    const DIGESTED_OBJECT_TYPE = "digestedObjectType";
    const OTHER_OBJECT_TYPE_ID = "otherObjectTypeID";
    const DIGEST_ALGORITHM$2 = "digestAlgorithm";
    const OBJECT_DIGEST = "objectDigest";
    const CLEAR_PROPS$X = [
        DIGESTED_OBJECT_TYPE,
        OTHER_OBJECT_TYPE_ID,
        DIGEST_ALGORITHM$2,
        OBJECT_DIGEST,
    ];
    class ObjectDigestInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.digestedObjectType = getParametersValue(parameters, DIGESTED_OBJECT_TYPE, ObjectDigestInfo.defaultValues(DIGESTED_OBJECT_TYPE));
            if (OTHER_OBJECT_TYPE_ID in parameters) {
                this.otherObjectTypeID = getParametersValue(parameters, OTHER_OBJECT_TYPE_ID, ObjectDigestInfo.defaultValues(OTHER_OBJECT_TYPE_ID));
            }
            this.digestAlgorithm = getParametersValue(parameters, DIGEST_ALGORITHM$2, ObjectDigestInfo.defaultValues(DIGEST_ALGORITHM$2));
            this.objectDigest = getParametersValue(parameters, OBJECT_DIGEST, ObjectDigestInfo.defaultValues(OBJECT_DIGEST));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case DIGESTED_OBJECT_TYPE:
                    return new Enumerated();
                case OTHER_OBJECT_TYPE_ID:
                    return new ObjectIdentifier();
                case DIGEST_ALGORITHM$2:
                    return new AlgorithmIdentifier();
                case OBJECT_DIGEST:
                    return new BitString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Enumerated({ name: (names.digestedObjectType || EMPTY_STRING) }),
                    new ObjectIdentifier({
                        optional: true,
                        name: (names.otherObjectTypeID || EMPTY_STRING)
                    }),
                    AlgorithmIdentifier.schema(names.digestAlgorithm || {}),
                    new BitString({ name: (names.objectDigest || EMPTY_STRING) }),
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$X);
            const asn1 = compareSchema(schema, schema, ObjectDigestInfo.schema({
                names: {
                    digestedObjectType: DIGESTED_OBJECT_TYPE,
                    otherObjectTypeID: OTHER_OBJECT_TYPE_ID,
                    digestAlgorithm: {
                        names: {
                            blockName: DIGEST_ALGORITHM$2
                        }
                    },
                    objectDigest: OBJECT_DIGEST
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.digestedObjectType = asn1.result.digestedObjectType;
            if (OTHER_OBJECT_TYPE_ID in asn1.result) {
                this.otherObjectTypeID = asn1.result.otherObjectTypeID;
            }
            this.digestAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.digestAlgorithm });
            this.objectDigest = asn1.result.objectDigest;
        }
        toSchema() {
            const result = new Sequence({
                value: [this.digestedObjectType]
            });
            if (this.otherObjectTypeID) {
                result.valueBlock.value.push(this.otherObjectTypeID);
            }
            result.valueBlock.value.push(this.digestAlgorithm.toSchema());
            result.valueBlock.value.push(this.objectDigest);
            return result;
        }
        toJSON() {
            const result = {
                digestedObjectType: this.digestedObjectType.toJSON(),
                digestAlgorithm: this.digestAlgorithm.toJSON(),
                objectDigest: this.objectDigest.toJSON(),
            };
            if (this.otherObjectTypeID) {
                result.otherObjectTypeID = this.otherObjectTypeID.toJSON();
            }
            return result;
        }
    }
    ObjectDigestInfo.CLASS_NAME = "ObjectDigestInfo";

    const ISSUER_NAME = "issuerName";
    const BASE_CERTIFICATE_ID$1 = "baseCertificateID";
    const OBJECT_DIGEST_INFO$1 = "objectDigestInfo";
    const CLEAR_PROPS$W = [
        ISSUER_NAME,
        BASE_CERTIFICATE_ID$1,
        OBJECT_DIGEST_INFO$1
    ];
    class V2Form extends PkiObject {
        constructor(parameters = {}) {
            super();
            if (ISSUER_NAME in parameters) {
                this.issuerName = getParametersValue(parameters, ISSUER_NAME, V2Form.defaultValues(ISSUER_NAME));
            }
            if (BASE_CERTIFICATE_ID$1 in parameters) {
                this.baseCertificateID = getParametersValue(parameters, BASE_CERTIFICATE_ID$1, V2Form.defaultValues(BASE_CERTIFICATE_ID$1));
            }
            if (OBJECT_DIGEST_INFO$1 in parameters) {
                this.objectDigestInfo = getParametersValue(parameters, OBJECT_DIGEST_INFO$1, V2Form.defaultValues(OBJECT_DIGEST_INFO$1));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ISSUER_NAME:
                    return new GeneralNames();
                case BASE_CERTIFICATE_ID$1:
                    return new IssuerSerial();
                case OBJECT_DIGEST_INFO$1:
                    return new ObjectDigestInfo();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    GeneralNames.schema({
                        names: {
                            blockName: names.issuerName
                        }
                    }, true),
                    new Constructed({
                        optional: true,
                        name: (names.baseCertificateID || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: IssuerSerial.schema().valueBlock.value
                    }),
                    new Constructed({
                        optional: true,
                        name: (names.objectDigestInfo || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: ObjectDigestInfo.schema().valueBlock.value
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$W);
            const asn1 = compareSchema(schema, schema, V2Form.schema({
                names: {
                    issuerName: ISSUER_NAME,
                    baseCertificateID: BASE_CERTIFICATE_ID$1,
                    objectDigestInfo: OBJECT_DIGEST_INFO$1
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (ISSUER_NAME in asn1.result)
                this.issuerName = new GeneralNames({ schema: asn1.result.issuerName });
            if (BASE_CERTIFICATE_ID$1 in asn1.result) {
                this.baseCertificateID = new IssuerSerial({
                    schema: new Sequence({
                        value: asn1.result.baseCertificateID.valueBlock.value
                    })
                });
            }
            if (OBJECT_DIGEST_INFO$1 in asn1.result) {
                this.objectDigestInfo = new ObjectDigestInfo({
                    schema: new Sequence({
                        value: asn1.result.objectDigestInfo.valueBlock.value
                    })
                });
            }
        }
        toSchema() {
            const result = new Sequence();
            if (this.issuerName)
                result.valueBlock.value.push(this.issuerName.toSchema());
            if (this.baseCertificateID) {
                result.valueBlock.value.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: this.baseCertificateID.toSchema().valueBlock.value
                }));
            }
            if (this.objectDigestInfo) {
                result.valueBlock.value.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: this.objectDigestInfo.toSchema().valueBlock.value
                }));
            }
            return result;
        }
        toJSON() {
            const result = {};
            if (this.issuerName) {
                result.issuerName = this.issuerName.toJSON();
            }
            if (this.baseCertificateID) {
                result.baseCertificateID = this.baseCertificateID.toJSON();
            }
            if (this.objectDigestInfo) {
                result.objectDigestInfo = this.objectDigestInfo.toJSON();
            }
            return result;
        }
    }
    V2Form.CLASS_NAME = "V2Form";

    const BASE_CERTIFICATE_ID = "baseCertificateID";
    const ENTITY_NAME = "entityName";
    const OBJECT_DIGEST_INFO = "objectDigestInfo";
    const CLEAR_PROPS$V = [
        BASE_CERTIFICATE_ID,
        ENTITY_NAME,
        OBJECT_DIGEST_INFO
    ];
    class Holder extends PkiObject {
        constructor(parameters = {}) {
            super();
            if (BASE_CERTIFICATE_ID in parameters) {
                this.baseCertificateID = getParametersValue(parameters, BASE_CERTIFICATE_ID, Holder.defaultValues(BASE_CERTIFICATE_ID));
            }
            if (ENTITY_NAME in parameters) {
                this.entityName = getParametersValue(parameters, ENTITY_NAME, Holder.defaultValues(ENTITY_NAME));
            }
            if (OBJECT_DIGEST_INFO in parameters) {
                this.objectDigestInfo = getParametersValue(parameters, OBJECT_DIGEST_INFO, Holder.defaultValues(OBJECT_DIGEST_INFO));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case BASE_CERTIFICATE_ID:
                    return new IssuerSerial();
                case ENTITY_NAME:
                    return new GeneralNames();
                case OBJECT_DIGEST_INFO:
                    return new ObjectDigestInfo();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Constructed({
                        optional: true,
                        name: (names.baseCertificateID || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: IssuerSerial.schema().valueBlock.value
                    }),
                    new Constructed({
                        optional: true,
                        name: (names.entityName || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: GeneralNames.schema().valueBlock.value
                    }),
                    new Constructed({
                        optional: true,
                        name: (names.objectDigestInfo || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 2
                        },
                        value: ObjectDigestInfo.schema().valueBlock.value
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$V);
            const asn1 = compareSchema(schema, schema, Holder.schema({
                names: {
                    baseCertificateID: BASE_CERTIFICATE_ID,
                    entityName: ENTITY_NAME,
                    objectDigestInfo: OBJECT_DIGEST_INFO
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (BASE_CERTIFICATE_ID in asn1.result) {
                this.baseCertificateID = new IssuerSerial({
                    schema: new Sequence({
                        value: asn1.result.baseCertificateID.valueBlock.value
                    })
                });
            }
            if (ENTITY_NAME in asn1.result) {
                this.entityName = new GeneralNames({
                    schema: new Sequence({
                        value: asn1.result.entityName.valueBlock.value
                    })
                });
            }
            if (OBJECT_DIGEST_INFO in asn1.result) {
                this.objectDigestInfo = new ObjectDigestInfo({
                    schema: new Sequence({
                        value: asn1.result.objectDigestInfo.valueBlock.value
                    })
                });
            }
        }
        toSchema() {
            const result = new Sequence();
            if (this.baseCertificateID) {
                result.valueBlock.value.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: this.baseCertificateID.toSchema().valueBlock.value
                }));
            }
            if (this.entityName) {
                result.valueBlock.value.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: this.entityName.toSchema().valueBlock.value
                }));
            }
            if (this.objectDigestInfo) {
                result.valueBlock.value.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    value: this.objectDigestInfo.toSchema().valueBlock.value
                }));
            }
            return result;
        }
        toJSON() {
            const result = {};
            if (this.baseCertificateID) {
                result.baseCertificateID = this.baseCertificateID.toJSON();
            }
            if (this.entityName) {
                result.entityName = this.entityName.toJSON();
            }
            if (this.objectDigestInfo) {
                result.objectDigestInfo = this.objectDigestInfo.toJSON();
            }
            return result;
        }
    }
    Holder.CLASS_NAME = "Holder";

    const VERSION$g = "version";
    const HOLDER = "holder";
    const ISSUER$3 = "issuer";
    const SIGNATURE$5 = "signature";
    const SERIAL_NUMBER$4 = "serialNumber";
    const ATTR_CERT_VALIDITY_PERIOD = "attrCertValidityPeriod";
    const ATTRIBUTES$2 = "attributes";
    const ISSUER_UNIQUE_ID$1 = "issuerUniqueID";
    const EXTENSIONS$3 = "extensions";
    const CLEAR_PROPS$U = [
        VERSION$g,
        HOLDER,
        ISSUER$3,
        SIGNATURE$5,
        SERIAL_NUMBER$4,
        ATTR_CERT_VALIDITY_PERIOD,
        ATTRIBUTES$2,
        ISSUER_UNIQUE_ID$1,
        EXTENSIONS$3
    ];
    class AttributeCertificateInfoV2 extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$g, AttributeCertificateInfoV2.defaultValues(VERSION$g));
            this.holder = getParametersValue(parameters, HOLDER, AttributeCertificateInfoV2.defaultValues(HOLDER));
            this.issuer = getParametersValue(parameters, ISSUER$3, AttributeCertificateInfoV2.defaultValues(ISSUER$3));
            this.signature = getParametersValue(parameters, SIGNATURE$5, AttributeCertificateInfoV2.defaultValues(SIGNATURE$5));
            this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$4, AttributeCertificateInfoV2.defaultValues(SERIAL_NUMBER$4));
            this.attrCertValidityPeriod = getParametersValue(parameters, ATTR_CERT_VALIDITY_PERIOD, AttributeCertificateInfoV2.defaultValues(ATTR_CERT_VALIDITY_PERIOD));
            this.attributes = getParametersValue(parameters, ATTRIBUTES$2, AttributeCertificateInfoV2.defaultValues(ATTRIBUTES$2));
            if (ISSUER_UNIQUE_ID$1 in parameters) {
                this.issuerUniqueID = getParametersValue(parameters, ISSUER_UNIQUE_ID$1, AttributeCertificateInfoV2.defaultValues(ISSUER_UNIQUE_ID$1));
            }
            if (EXTENSIONS$3 in parameters) {
                this.extensions = getParametersValue(parameters, EXTENSIONS$3, AttributeCertificateInfoV2.defaultValues(EXTENSIONS$3));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$g:
                    return 1;
                case HOLDER:
                    return new Holder();
                case ISSUER$3:
                    return {};
                case SIGNATURE$5:
                    return new AlgorithmIdentifier();
                case SERIAL_NUMBER$4:
                    return new Integer();
                case ATTR_CERT_VALIDITY_PERIOD:
                    return new AttCertValidityPeriod();
                case ATTRIBUTES$2:
                    return [];
                case ISSUER_UNIQUE_ID$1:
                    return new BitString();
                case EXTENSIONS$3:
                    return new Extensions();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.version || EMPTY_STRING) }),
                    Holder.schema(names.holder || {}),
                    new Choice({
                        value: [
                            GeneralNames.schema({
                                names: {
                                    blockName: (names.issuer || EMPTY_STRING)
                                }
                            }),
                            new Constructed({
                                name: (names.issuer || EMPTY_STRING),
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 0
                                },
                                value: V2Form.schema().valueBlock.value
                            })
                        ]
                    }),
                    AlgorithmIdentifier.schema(names.signature || {}),
                    new Integer({ name: (names.serialNumber || EMPTY_STRING) }),
                    AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}),
                    new Sequence({
                        name: (names.attributes || EMPTY_STRING),
                        value: [
                            new Repeated({
                                value: Attribute.schema()
                            })
                        ]
                    }),
                    new BitString({
                        optional: true,
                        name: (names.issuerUniqueID || EMPTY_STRING)
                    }),
                    Extensions.schema(names.extensions || {}, true)
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$U);
            const asn1 = compareSchema(schema, schema, AttributeCertificateInfoV2.schema({
                names: {
                    version: VERSION$g,
                    holder: {
                        names: {
                            blockName: HOLDER
                        }
                    },
                    issuer: ISSUER$3,
                    signature: {
                        names: {
                            blockName: SIGNATURE$5
                        }
                    },
                    serialNumber: SERIAL_NUMBER$4,
                    attrCertValidityPeriod: {
                        names: {
                            blockName: ATTR_CERT_VALIDITY_PERIOD
                        }
                    },
                    attributes: ATTRIBUTES$2,
                    issuerUniqueID: ISSUER_UNIQUE_ID$1,
                    extensions: {
                        names: {
                            blockName: EXTENSIONS$3
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result.version.valueBlock.valueDec;
            this.holder = new Holder({ schema: asn1.result.holder });
            switch (asn1.result.issuer.idBlock.tagClass) {
                case 3:
                    this.issuer = new V2Form({
                        schema: new Sequence({
                            value: asn1.result.issuer.valueBlock.value
                        })
                    });
                    break;
                case 1:
                default:
                    throw new Error("Incorrect value for 'issuer' in AttributeCertificateInfoV2");
            }
            this.signature = new AlgorithmIdentifier({ schema: asn1.result.signature });
            this.serialNumber = asn1.result.serialNumber;
            this.attrCertValidityPeriod = new AttCertValidityPeriod({ schema: asn1.result.attrCertValidityPeriod });
            this.attributes = Array.from(asn1.result.attributes.valueBlock.value, element => new Attribute({ schema: element }));
            if (ISSUER_UNIQUE_ID$1 in asn1.result) {
                this.issuerUniqueID = asn1.result.issuerUniqueID;
            }
            if (EXTENSIONS$3 in asn1.result) {
                this.extensions = new Extensions({ schema: asn1.result.extensions });
            }
        }
        toSchema() {
            const result = new Sequence({
                value: [
                    new Integer({ value: this.version }),
                    this.holder.toSchema(),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: this.issuer.toSchema().valueBlock.value
                    }),
                    this.signature.toSchema(),
                    this.serialNumber,
                    this.attrCertValidityPeriod.toSchema(),
                    new Sequence({
                        value: Array.from(this.attributes, o => o.toSchema())
                    })
                ]
            });
            if (this.issuerUniqueID) {
                result.valueBlock.value.push(this.issuerUniqueID);
            }
            if (this.extensions) {
                result.valueBlock.value.push(this.extensions.toSchema());
            }
            return result;
        }
        toJSON() {
            const result = {
                version: this.version,
                holder: this.holder.toJSON(),
                issuer: this.issuer.toJSON(),
                signature: this.signature.toJSON(),
                serialNumber: this.serialNumber.toJSON(),
                attrCertValidityPeriod: this.attrCertValidityPeriod.toJSON(),
                attributes: Array.from(this.attributes, o => o.toJSON())
            };
            if (this.issuerUniqueID) {
                result.issuerUniqueID = this.issuerUniqueID.toJSON();
            }
            if (this.extensions) {
                result.extensions = this.extensions.toJSON();
            }
            return result;
        }
    }
    AttributeCertificateInfoV2.CLASS_NAME = "AttributeCertificateInfoV2";

    const ACINFO = "acinfo";
    const SIGNATURE_ALGORITHM$6 = "signatureAlgorithm";
    const SIGNATURE_VALUE$3 = "signatureValue";
    const CLEAR_PROPS$T = [
        ACINFO,
        SIGNATURE_ALGORITHM$6,
        SIGNATURE_VALUE$3,
    ];
    class AttributeCertificateV2 extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.acinfo = getParametersValue(parameters, ACINFO, AttributeCertificateV2.defaultValues(ACINFO));
            this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$6, AttributeCertificateV2.defaultValues(SIGNATURE_ALGORITHM$6));
            this.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE$3, AttributeCertificateV2.defaultValues(SIGNATURE_VALUE$3));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ACINFO:
                    return new AttributeCertificateInfoV2();
                case SIGNATURE_ALGORITHM$6:
                    return new AlgorithmIdentifier();
                case SIGNATURE_VALUE$3:
                    return new BitString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    AttributeCertificateInfoV2.schema(names.acinfo || {}),
                    AlgorithmIdentifier.schema(names.signatureAlgorithm || {}),
                    new BitString({ name: (names.signatureValue || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$T);
            const asn1 = compareSchema(schema, schema, AttributeCertificateV2.schema({
                names: {
                    acinfo: {
                        names: {
                            blockName: ACINFO
                        }
                    },
                    signatureAlgorithm: {
                        names: {
                            blockName: SIGNATURE_ALGORITHM$6
                        }
                    },
                    signatureValue: SIGNATURE_VALUE$3
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.acinfo = new AttributeCertificateInfoV2({ schema: asn1.result.acinfo });
            this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
            this.signatureValue = asn1.result.signatureValue;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    this.acinfo.toSchema(),
                    this.signatureAlgorithm.toSchema(),
                    this.signatureValue
                ]
            }));
        }
        toJSON() {
            return {
                acinfo: this.acinfo.toJSON(),
                signatureAlgorithm: this.signatureAlgorithm.toJSON(),
                signatureValue: this.signatureValue.toJSON(),
            };
        }
    }
    AttributeCertificateV2.CLASS_NAME = "AttributeCertificateV2";

    const CONTENT_TYPE = "contentType";
    const CONTENT = "content";
    const CLEAR_PROPS$S = [CONTENT_TYPE, CONTENT];
    class ContentInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.contentType = getParametersValue(parameters, CONTENT_TYPE, ContentInfo.defaultValues(CONTENT_TYPE));
            this.content = getParametersValue(parameters, CONTENT, ContentInfo.defaultValues(CONTENT));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case CONTENT_TYPE:
                    return EMPTY_STRING;
                case CONTENT:
                    return new Any();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case CONTENT_TYPE:
                    return (typeof memberValue === "string" &&
                        memberValue === this.defaultValues(CONTENT_TYPE));
                case CONTENT:
                    return (memberValue instanceof Any);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            if (("optional" in names) === false) {
                names.optional = false;
            }
            return (new Sequence({
                name: (names.blockName || "ContentInfo"),
                optional: names.optional,
                value: [
                    new ObjectIdentifier({ name: (names.contentType || CONTENT_TYPE) }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [new Any({ name: (names.content || CONTENT) })]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$S);
            const asn1 = compareSchema(schema, schema, ContentInfo.schema());
            AsnError.assertSchema(asn1, this.className);
            this.contentType = asn1.result.contentType.valueBlock.toString();
            this.content = asn1.result.content;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    new ObjectIdentifier({ value: this.contentType }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [this.content]
                    })
                ]
            }));
        }
        toJSON() {
            const object = {
                contentType: this.contentType
            };
            if (!(this.content instanceof Any)) {
                object.content = this.content.toJSON();
            }
            return object;
        }
    }
    ContentInfo.CLASS_NAME = "ContentInfo";
    ContentInfo.DATA = id_ContentType_Data;
    ContentInfo.SIGNED_DATA = id_ContentType_SignedData;
    ContentInfo.ENVELOPED_DATA = id_ContentType_EnvelopedData;
    ContentInfo.ENCRYPTED_DATA = id_ContentType_EncryptedData;

    const TYPE$1 = "type";
    const VALUE$4 = "value";
    const UTC_TIME_NAME = "utcTimeName";
    const GENERAL_TIME_NAME = "generalTimeName";
    const CLEAR_PROPS$R = [UTC_TIME_NAME, GENERAL_TIME_NAME];
    var TimeType;
    (function (TimeType) {
        TimeType[TimeType["UTCTime"] = 0] = "UTCTime";
        TimeType[TimeType["GeneralizedTime"] = 1] = "GeneralizedTime";
        TimeType[TimeType["empty"] = 2] = "empty";
    })(TimeType || (TimeType = {}));
    class Time extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.type = getParametersValue(parameters, TYPE$1, Time.defaultValues(TYPE$1));
            this.value = getParametersValue(parameters, VALUE$4, Time.defaultValues(VALUE$4));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TYPE$1:
                    return 0;
                case VALUE$4:
                    return new Date(0, 0, 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}, optional = false) {
            const names = getParametersValue(parameters, "names", {});
            return (new Choice({
                optional,
                value: [
                    new UTCTime({ name: (names.utcTimeName || EMPTY_STRING) }),
                    new GeneralizedTime({ name: (names.generalTimeName || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$R);
            const asn1 = compareSchema(schema, schema, Time.schema({
                names: {
                    utcTimeName: UTC_TIME_NAME,
                    generalTimeName: GENERAL_TIME_NAME
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (UTC_TIME_NAME in asn1.result) {
                this.type = 0;
                this.value = asn1.result.utcTimeName.toDate();
            }
            if (GENERAL_TIME_NAME in asn1.result) {
                this.type = 1;
                this.value = asn1.result.generalTimeName.toDate();
            }
        }
        toSchema() {
            if (this.type === 0) {
                return new UTCTime({ valueDate: this.value });
            }
            else if (this.type === 1) {
                return new GeneralizedTime({ valueDate: this.value });
            }
            return {};
        }
        toJSON() {
            return {
                type: this.type,
                value: this.value
            };
        }
    }
    Time.CLASS_NAME = "Time";

    const TBS$4 = "tbs";
    const VERSION$f = "version";
    const SERIAL_NUMBER$3 = "serialNumber";
    const SIGNATURE$4 = "signature";
    const ISSUER$2 = "issuer";
    const NOT_BEFORE = "notBefore";
    const NOT_AFTER = "notAfter";
    const SUBJECT$1 = "subject";
    const SUBJECT_PUBLIC_KEY_INFO = "subjectPublicKeyInfo";
    const ISSUER_UNIQUE_ID = "issuerUniqueID";
    const SUBJECT_UNIQUE_ID = "subjectUniqueID";
    const EXTENSIONS$2 = "extensions";
    const SIGNATURE_ALGORITHM$5 = "signatureAlgorithm";
    const SIGNATURE_VALUE$2 = "signatureValue";
    const TBS_CERTIFICATE = "tbsCertificate";
    const TBS_CERTIFICATE_VERSION = `${TBS_CERTIFICATE}.${VERSION$f}`;
    const TBS_CERTIFICATE_SERIAL_NUMBER = `${TBS_CERTIFICATE}.${SERIAL_NUMBER$3}`;
    const TBS_CERTIFICATE_SIGNATURE = `${TBS_CERTIFICATE}.${SIGNATURE$4}`;
    const TBS_CERTIFICATE_ISSUER = `${TBS_CERTIFICATE}.${ISSUER$2}`;
    const TBS_CERTIFICATE_NOT_BEFORE = `${TBS_CERTIFICATE}.${NOT_BEFORE}`;
    const TBS_CERTIFICATE_NOT_AFTER = `${TBS_CERTIFICATE}.${NOT_AFTER}`;
    const TBS_CERTIFICATE_SUBJECT = `${TBS_CERTIFICATE}.${SUBJECT$1}`;
    const TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY = `${TBS_CERTIFICATE}.${SUBJECT_PUBLIC_KEY_INFO}`;
    const TBS_CERTIFICATE_ISSUER_UNIQUE_ID = `${TBS_CERTIFICATE}.${ISSUER_UNIQUE_ID}`;
    const TBS_CERTIFICATE_SUBJECT_UNIQUE_ID = `${TBS_CERTIFICATE}.${SUBJECT_UNIQUE_ID}`;
    const TBS_CERTIFICATE_EXTENSIONS = `${TBS_CERTIFICATE}.${EXTENSIONS$2}`;
    const CLEAR_PROPS$Q = [
        TBS_CERTIFICATE,
        TBS_CERTIFICATE_VERSION,
        TBS_CERTIFICATE_SERIAL_NUMBER,
        TBS_CERTIFICATE_SIGNATURE,
        TBS_CERTIFICATE_ISSUER,
        TBS_CERTIFICATE_NOT_BEFORE,
        TBS_CERTIFICATE_NOT_AFTER,
        TBS_CERTIFICATE_SUBJECT,
        TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY,
        TBS_CERTIFICATE_ISSUER_UNIQUE_ID,
        TBS_CERTIFICATE_SUBJECT_UNIQUE_ID,
        TBS_CERTIFICATE_EXTENSIONS,
        SIGNATURE_ALGORITHM$5,
        SIGNATURE_VALUE$2
    ];
    function tbsCertificate(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return (new Sequence({
            name: (names.blockName || TBS_CERTIFICATE),
            value: [
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Integer({ name: (names.tbsCertificateVersion || TBS_CERTIFICATE_VERSION) })
                    ]
                }),
                new Integer({ name: (names.tbsCertificateSerialNumber || TBS_CERTIFICATE_SERIAL_NUMBER) }),
                AlgorithmIdentifier.schema(names.signature || {
                    names: {
                        blockName: TBS_CERTIFICATE_SIGNATURE
                    }
                }),
                RelativeDistinguishedNames.schema(names.issuer || {
                    names: {
                        blockName: TBS_CERTIFICATE_ISSUER
                    }
                }),
                new Sequence({
                    name: (names.tbsCertificateValidity || "tbsCertificate.validity"),
                    value: [
                        Time.schema(names.notBefore || {
                            names: {
                                utcTimeName: TBS_CERTIFICATE_NOT_BEFORE,
                                generalTimeName: TBS_CERTIFICATE_NOT_BEFORE
                            }
                        }),
                        Time.schema(names.notAfter || {
                            names: {
                                utcTimeName: TBS_CERTIFICATE_NOT_AFTER,
                                generalTimeName: TBS_CERTIFICATE_NOT_AFTER
                            }
                        })
                    ]
                }),
                RelativeDistinguishedNames.schema(names.subject || {
                    names: {
                        blockName: TBS_CERTIFICATE_SUBJECT
                    }
                }),
                PublicKeyInfo.schema(names.subjectPublicKeyInfo || {
                    names: {
                        blockName: TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY
                    }
                }),
                new Primitive({
                    name: (names.tbsCertificateIssuerUniqueID || TBS_CERTIFICATE_ISSUER_UNIQUE_ID),
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    }
                }),
                new Primitive({
                    name: (names.tbsCertificateSubjectUniqueID || TBS_CERTIFICATE_SUBJECT_UNIQUE_ID),
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    }
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 3
                    },
                    value: [Extensions.schema(names.extensions || {
                            names: {
                                blockName: TBS_CERTIFICATE_EXTENSIONS
                            }
                        })]
                })
            ]
        }));
    }
    class Certificate extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.tbsView = new Uint8Array(getParametersValue(parameters, TBS$4, Certificate.defaultValues(TBS$4)));
            this.version = getParametersValue(parameters, VERSION$f, Certificate.defaultValues(VERSION$f));
            this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$3, Certificate.defaultValues(SERIAL_NUMBER$3));
            this.signature = getParametersValue(parameters, SIGNATURE$4, Certificate.defaultValues(SIGNATURE$4));
            this.issuer = getParametersValue(parameters, ISSUER$2, Certificate.defaultValues(ISSUER$2));
            this.notBefore = getParametersValue(parameters, NOT_BEFORE, Certificate.defaultValues(NOT_BEFORE));
            this.notAfter = getParametersValue(parameters, NOT_AFTER, Certificate.defaultValues(NOT_AFTER));
            this.subject = getParametersValue(parameters, SUBJECT$1, Certificate.defaultValues(SUBJECT$1));
            this.subjectPublicKeyInfo = getParametersValue(parameters, SUBJECT_PUBLIC_KEY_INFO, Certificate.defaultValues(SUBJECT_PUBLIC_KEY_INFO));
            if (ISSUER_UNIQUE_ID in parameters) {
                this.issuerUniqueID = getParametersValue(parameters, ISSUER_UNIQUE_ID, Certificate.defaultValues(ISSUER_UNIQUE_ID));
            }
            if (SUBJECT_UNIQUE_ID in parameters) {
                this.subjectUniqueID = getParametersValue(parameters, SUBJECT_UNIQUE_ID, Certificate.defaultValues(SUBJECT_UNIQUE_ID));
            }
            if (EXTENSIONS$2 in parameters) {
                this.extensions = getParametersValue(parameters, EXTENSIONS$2, Certificate.defaultValues(EXTENSIONS$2));
            }
            this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$5, Certificate.defaultValues(SIGNATURE_ALGORITHM$5));
            this.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE$2, Certificate.defaultValues(SIGNATURE_VALUE$2));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        get tbs() {
            return BufferSourceConverter_1.toArrayBuffer(this.tbsView);
        }
        set tbs(value) {
            this.tbsView = new Uint8Array(value);
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TBS$4:
                    return EMPTY_BUFFER;
                case VERSION$f:
                    return 0;
                case SERIAL_NUMBER$3:
                    return new Integer();
                case SIGNATURE$4:
                    return new AlgorithmIdentifier();
                case ISSUER$2:
                    return new RelativeDistinguishedNames();
                case NOT_BEFORE:
                    return new Time();
                case NOT_AFTER:
                    return new Time();
                case SUBJECT$1:
                    return new RelativeDistinguishedNames();
                case SUBJECT_PUBLIC_KEY_INFO:
                    return new PublicKeyInfo();
                case ISSUER_UNIQUE_ID:
                    return EMPTY_BUFFER;
                case SUBJECT_UNIQUE_ID:
                    return EMPTY_BUFFER;
                case EXTENSIONS$2:
                    return [];
                case SIGNATURE_ALGORITHM$5:
                    return new AlgorithmIdentifier();
                case SIGNATURE_VALUE$2:
                    return new BitString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    tbsCertificate(names.tbsCertificate),
                    AlgorithmIdentifier.schema(names.signatureAlgorithm || {
                        names: {
                            blockName: SIGNATURE_ALGORITHM$5
                        }
                    }),
                    new BitString({ name: (names.signatureValue || SIGNATURE_VALUE$2) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$Q);
            const asn1 = compareSchema(schema, schema, Certificate.schema({
                names: {
                    tbsCertificate: {
                        names: {
                            extensions: {
                                names: {
                                    extensions: TBS_CERTIFICATE_EXTENSIONS
                                }
                            }
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.tbsView = asn1.result.tbsCertificate.valueBeforeDecodeView;
            if (TBS_CERTIFICATE_VERSION in asn1.result)
                this.version = asn1.result[TBS_CERTIFICATE_VERSION].valueBlock.valueDec;
            this.serialNumber = asn1.result[TBS_CERTIFICATE_SERIAL_NUMBER];
            this.signature = new AlgorithmIdentifier({ schema: asn1.result[TBS_CERTIFICATE_SIGNATURE] });
            this.issuer = new RelativeDistinguishedNames({ schema: asn1.result[TBS_CERTIFICATE_ISSUER] });
            this.notBefore = new Time({ schema: asn1.result[TBS_CERTIFICATE_NOT_BEFORE] });
            this.notAfter = new Time({ schema: asn1.result[TBS_CERTIFICATE_NOT_AFTER] });
            this.subject = new RelativeDistinguishedNames({ schema: asn1.result[TBS_CERTIFICATE_SUBJECT] });
            this.subjectPublicKeyInfo = new PublicKeyInfo({ schema: asn1.result[TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY] });
            if (TBS_CERTIFICATE_ISSUER_UNIQUE_ID in asn1.result)
                this.issuerUniqueID = asn1.result[TBS_CERTIFICATE_ISSUER_UNIQUE_ID].valueBlock.valueHex;
            if (TBS_CERTIFICATE_SUBJECT_UNIQUE_ID in asn1.result)
                this.subjectUniqueID = asn1.result[TBS_CERTIFICATE_SUBJECT_UNIQUE_ID].valueBlock.valueHex;
            if (TBS_CERTIFICATE_EXTENSIONS in asn1.result)
                this.extensions = Array.from(asn1.result[TBS_CERTIFICATE_EXTENSIONS], element => new Extension({ schema: element }));
            this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
            this.signatureValue = asn1.result.signatureValue;
        }
        encodeTBS() {
            const outputArray = [];
            if ((VERSION$f in this) && (this.version !== Certificate.defaultValues(VERSION$f))) {
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Integer({ value: this.version })
                    ]
                }));
            }
            outputArray.push(this.serialNumber);
            outputArray.push(this.signature.toSchema());
            outputArray.push(this.issuer.toSchema());
            outputArray.push(new Sequence({
                value: [
                    this.notBefore.toSchema(),
                    this.notAfter.toSchema()
                ]
            }));
            outputArray.push(this.subject.toSchema());
            outputArray.push(this.subjectPublicKeyInfo.toSchema());
            if (this.issuerUniqueID) {
                outputArray.push(new Primitive({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    valueHex: this.issuerUniqueID
                }));
            }
            if (this.subjectUniqueID) {
                outputArray.push(new Primitive({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    valueHex: this.subjectUniqueID
                }));
            }
            if (this.extensions) {
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 3
                    },
                    value: [new Sequence({
                            value: Array.from(this.extensions, o => o.toSchema())
                        })]
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toSchema(encodeFlag = false) {
            let tbsSchema;
            if (encodeFlag === false) {
                if (!this.tbsView.byteLength) {
                    return Certificate.schema().value[0];
                }
                const asn1 = fromBER(this.tbsView);
                AsnError.assert(asn1, "TBS Certificate");
                tbsSchema = asn1.result;
            }
            else {
                tbsSchema = this.encodeTBS();
            }
            return (new Sequence({
                value: [
                    tbsSchema,
                    this.signatureAlgorithm.toSchema(),
                    this.signatureValue
                ]
            }));
        }
        toJSON() {
            const res = {
                tbs: Convert_1.ToHex(this.tbsView),
                version: this.version,
                serialNumber: this.serialNumber.toJSON(),
                signature: this.signature.toJSON(),
                issuer: this.issuer.toJSON(),
                notBefore: this.notBefore.toJSON(),
                notAfter: this.notAfter.toJSON(),
                subject: this.subject.toJSON(),
                subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
                signatureAlgorithm: this.signatureAlgorithm.toJSON(),
                signatureValue: this.signatureValue.toJSON(),
            };
            if ((VERSION$f in this) && (this.version !== Certificate.defaultValues(VERSION$f))) {
                res.version = this.version;
            }
            if (this.issuerUniqueID) {
                res.issuerUniqueID = Convert_1.ToHex(this.issuerUniqueID);
            }
            if (this.subjectUniqueID) {
                res.subjectUniqueID = Convert_1.ToHex(this.subjectUniqueID);
            }
            if (this.extensions) {
                res.extensions = Array.from(this.extensions, o => o.toJSON());
            }
            return res;
        }
        async getPublicKey(parameters, crypto = getCrypto(true)) {
            return crypto.getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);
        }
        async getKeyHash(hashAlgorithm = "SHA-1", crypto = getCrypto(true)) {
            return crypto.digest({ name: hashAlgorithm }, this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);
        }
        async sign(privateKey, hashAlgorithm = "SHA-1", crypto = getCrypto(true)) {
            if (!privateKey) {
                throw new Error("Need to provide a private key for signing");
            }
            const signatureParameters = await crypto.getSignatureParameters(privateKey, hashAlgorithm);
            const parameters = signatureParameters.parameters;
            this.signature = signatureParameters.signatureAlgorithm;
            this.signatureAlgorithm = signatureParameters.signatureAlgorithm;
            this.tbsView = new Uint8Array(this.encodeTBS().toBER());
            const signature = await crypto.signWithPrivateKey(this.tbsView, privateKey, parameters);
            this.signatureValue = new BitString({ valueHex: signature });
        }
        async verify(issuerCertificate, crypto = getCrypto(true)) {
            let subjectPublicKeyInfo;
            if (issuerCertificate) {
                subjectPublicKeyInfo = issuerCertificate.subjectPublicKeyInfo;
            }
            else if (this.issuer.isEqual(this.subject)) {
                subjectPublicKeyInfo = this.subjectPublicKeyInfo;
            }
            if (!(subjectPublicKeyInfo instanceof PublicKeyInfo)) {
                throw new Error("Please provide issuer certificate as a parameter");
            }
            return crypto.verifyWithPublicKey(this.tbsView, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm);
        }
    }
    Certificate.CLASS_NAME = "Certificate";
    function checkCA(cert, signerCert = null) {
        if (signerCert && cert.issuer.isEqual(signerCert.issuer) && cert.serialNumber.isEqual(signerCert.serialNumber)) {
            return null;
        }
        let isCA = false;
        if (cert.extensions) {
            for (const extension of cert.extensions) {
                if (extension.extnID === id_BasicConstraints && extension.parsedValue instanceof BasicConstraints) {
                    if (extension.parsedValue.cA) {
                        isCA = true;
                        break;
                    }
                }
            }
        }
        if (isCA) {
            return cert;
        }
        return null;
    }

    const CERT_ID$1 = "certId";
    const CERT_VALUE = "certValue";
    const PARSED_VALUE$4 = "parsedValue";
    const CLEAR_PROPS$P = [
        CERT_ID$1,
        CERT_VALUE
    ];
    class CertBag extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.certId = getParametersValue(parameters, CERT_ID$1, CertBag.defaultValues(CERT_ID$1));
            this.certValue = getParametersValue(parameters, CERT_VALUE, CertBag.defaultValues(CERT_VALUE));
            if (PARSED_VALUE$4 in parameters) {
                this.parsedValue = getParametersValue(parameters, PARSED_VALUE$4, CertBag.defaultValues(PARSED_VALUE$4));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case CERT_ID$1:
                    return EMPTY_STRING;
                case CERT_VALUE:
                    return (new Any());
                case PARSED_VALUE$4:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case CERT_ID$1:
                    return (memberValue === EMPTY_STRING);
                case CERT_VALUE:
                    return (memberValue instanceof Any);
                case PARSED_VALUE$4:
                    return ((memberValue instanceof Object) && (Object.keys(memberValue).length === 0));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.id || "id") }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [new Any({ name: (names.value || "value") })]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$P);
            const asn1 = compareSchema(schema, schema, CertBag.schema({
                names: {
                    id: CERT_ID$1,
                    value: CERT_VALUE
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.certId = asn1.result.certId.valueBlock.toString();
            this.certValue = asn1.result.certValue;
            const certValueHex = this.certValue.valueBlock.valueHexView;
            switch (this.certId) {
                case id_CertBag_X509Certificate:
                    {
                        try {
                            this.parsedValue = Certificate.fromBER(certValueHex);
                        }
                        catch (ex) {
                            AttributeCertificateV2.fromBER(certValueHex);
                        }
                    }
                    break;
                case id_CertBag_AttributeCertificate:
                    {
                        this.parsedValue = AttributeCertificateV2.fromBER(certValueHex);
                    }
                    break;
                case id_CertBag_SDSICertificate:
                default:
                    throw new Error(`Incorrect CERT_ID value in CertBag: ${this.certId}`);
            }
        }
        toSchema() {
            if (PARSED_VALUE$4 in this) {
                if ("acinfo" in this.parsedValue) {
                    this.certId = id_CertBag_AttributeCertificate;
                }
                else {
                    this.certId = id_CertBag_X509Certificate;
                }
                this.certValue = new OctetString({ valueHex: this.parsedValue.toSchema().toBER(false) });
            }
            return (new Sequence({
                value: [
                    new ObjectIdentifier({ value: this.certId }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [(("toSchema" in this.certValue) ? this.certValue.toSchema() : this.certValue)]
                    })
                ]
            }));
        }
        toJSON() {
            return {
                certId: this.certId,
                certValue: this.certValue.toJSON()
            };
        }
    }
    CertBag.CLASS_NAME = "CertBag";

    const USER_CERTIFICATE = "userCertificate";
    const REVOCATION_DATE = "revocationDate";
    const CRL_ENTRY_EXTENSIONS = "crlEntryExtensions";
    const CLEAR_PROPS$O = [
        USER_CERTIFICATE,
        REVOCATION_DATE,
        CRL_ENTRY_EXTENSIONS
    ];
    class RevokedCertificate extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.userCertificate = getParametersValue(parameters, USER_CERTIFICATE, RevokedCertificate.defaultValues(USER_CERTIFICATE));
            this.revocationDate = getParametersValue(parameters, REVOCATION_DATE, RevokedCertificate.defaultValues(REVOCATION_DATE));
            if (CRL_ENTRY_EXTENSIONS in parameters) {
                this.crlEntryExtensions = getParametersValue(parameters, CRL_ENTRY_EXTENSIONS, RevokedCertificate.defaultValues(CRL_ENTRY_EXTENSIONS));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case USER_CERTIFICATE:
                    return new Integer();
                case REVOCATION_DATE:
                    return new Time();
                case CRL_ENTRY_EXTENSIONS:
                    return new Extensions();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.userCertificate || USER_CERTIFICATE) }),
                    Time.schema({
                        names: {
                            utcTimeName: (names.revocationDate || REVOCATION_DATE),
                            generalTimeName: (names.revocationDate || REVOCATION_DATE)
                        }
                    }),
                    Extensions.schema({
                        names: {
                            blockName: (names.crlEntryExtensions || CRL_ENTRY_EXTENSIONS)
                        }
                    }, true)
                ]
            });
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$O);
            const asn1 = compareSchema(schema, schema, RevokedCertificate.schema());
            AsnError.assertSchema(asn1, this.className);
            this.userCertificate = asn1.result.userCertificate;
            this.revocationDate = new Time({ schema: asn1.result.revocationDate });
            if (CRL_ENTRY_EXTENSIONS in asn1.result) {
                this.crlEntryExtensions = new Extensions({ schema: asn1.result.crlEntryExtensions });
            }
        }
        toSchema() {
            const outputArray = [
                this.userCertificate,
                this.revocationDate.toSchema()
            ];
            if (this.crlEntryExtensions) {
                outputArray.push(this.crlEntryExtensions.toSchema());
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                userCertificate: this.userCertificate.toJSON(),
                revocationDate: this.revocationDate.toJSON(),
            };
            if (this.crlEntryExtensions) {
                res.crlEntryExtensions = this.crlEntryExtensions.toJSON();
            }
            return res;
        }
    }
    RevokedCertificate.CLASS_NAME = "RevokedCertificate";

    const TBS$3 = "tbs";
    const VERSION$e = "version";
    const SIGNATURE$3 = "signature";
    const ISSUER$1 = "issuer";
    const THIS_UPDATE$1 = "thisUpdate";
    const NEXT_UPDATE$1 = "nextUpdate";
    const REVOKED_CERTIFICATES = "revokedCertificates";
    const CRL_EXTENSIONS = "crlExtensions";
    const SIGNATURE_ALGORITHM$4 = "signatureAlgorithm";
    const SIGNATURE_VALUE$1 = "signatureValue";
    const TBS_CERT_LIST = "tbsCertList";
    const TBS_CERT_LIST_VERSION = `${TBS_CERT_LIST}.version`;
    const TBS_CERT_LIST_SIGNATURE = `${TBS_CERT_LIST}.signature`;
    const TBS_CERT_LIST_ISSUER = `${TBS_CERT_LIST}.issuer`;
    const TBS_CERT_LIST_THIS_UPDATE = `${TBS_CERT_LIST}.thisUpdate`;
    const TBS_CERT_LIST_NEXT_UPDATE = `${TBS_CERT_LIST}.nextUpdate`;
    const TBS_CERT_LIST_REVOKED_CERTIFICATES = `${TBS_CERT_LIST}.revokedCertificates`;
    const TBS_CERT_LIST_EXTENSIONS = `${TBS_CERT_LIST}.extensions`;
    const CLEAR_PROPS$N = [
        TBS_CERT_LIST,
        TBS_CERT_LIST_VERSION,
        TBS_CERT_LIST_SIGNATURE,
        TBS_CERT_LIST_ISSUER,
        TBS_CERT_LIST_THIS_UPDATE,
        TBS_CERT_LIST_NEXT_UPDATE,
        TBS_CERT_LIST_REVOKED_CERTIFICATES,
        TBS_CERT_LIST_EXTENSIONS,
        SIGNATURE_ALGORITHM$4,
        SIGNATURE_VALUE$1
    ];
    function tbsCertList(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return (new Sequence({
            name: (names.blockName || TBS_CERT_LIST),
            value: [
                new Integer({
                    optional: true,
                    name: (names.tbsCertListVersion || TBS_CERT_LIST_VERSION),
                    value: 2
                }),
                AlgorithmIdentifier.schema(names.signature || {
                    names: {
                        blockName: TBS_CERT_LIST_SIGNATURE
                    }
                }),
                RelativeDistinguishedNames.schema(names.issuer || {
                    names: {
                        blockName: TBS_CERT_LIST_ISSUER
                    }
                }),
                Time.schema(names.tbsCertListThisUpdate || {
                    names: {
                        utcTimeName: TBS_CERT_LIST_THIS_UPDATE,
                        generalTimeName: TBS_CERT_LIST_THIS_UPDATE
                    }
                }),
                Time.schema(names.tbsCertListNextUpdate || {
                    names: {
                        utcTimeName: TBS_CERT_LIST_NEXT_UPDATE,
                        generalTimeName: TBS_CERT_LIST_NEXT_UPDATE
                    }
                }, true),
                new Sequence({
                    optional: true,
                    value: [
                        new Repeated({
                            name: (names.tbsCertListRevokedCertificates || TBS_CERT_LIST_REVOKED_CERTIFICATES),
                            value: new Sequence({
                                value: [
                                    new Integer(),
                                    Time.schema(),
                                    Extensions.schema({}, true)
                                ]
                            })
                        })
                    ]
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [Extensions.schema(names.crlExtensions || {
                            names: {
                                blockName: TBS_CERT_LIST_EXTENSIONS
                            }
                        })]
                })
            ]
        }));
    }
    const WELL_KNOWN_EXTENSIONS = [
        id_AuthorityKeyIdentifier,
        id_IssuerAltName,
        id_CRLNumber,
        id_BaseCRLNumber,
        id_IssuingDistributionPoint,
        id_FreshestCRL,
        id_AuthorityInfoAccess,
        id_CRLReason,
        id_InvalidityDate,
        id_CertificateIssuer,
    ];
    class CertificateRevocationList extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.tbsView = new Uint8Array(getParametersValue(parameters, TBS$3, CertificateRevocationList.defaultValues(TBS$3)));
            this.version = getParametersValue(parameters, VERSION$e, CertificateRevocationList.defaultValues(VERSION$e));
            this.signature = getParametersValue(parameters, SIGNATURE$3, CertificateRevocationList.defaultValues(SIGNATURE$3));
            this.issuer = getParametersValue(parameters, ISSUER$1, CertificateRevocationList.defaultValues(ISSUER$1));
            this.thisUpdate = getParametersValue(parameters, THIS_UPDATE$1, CertificateRevocationList.defaultValues(THIS_UPDATE$1));
            if (NEXT_UPDATE$1 in parameters) {
                this.nextUpdate = getParametersValue(parameters, NEXT_UPDATE$1, CertificateRevocationList.defaultValues(NEXT_UPDATE$1));
            }
            if (REVOKED_CERTIFICATES in parameters) {
                this.revokedCertificates = getParametersValue(parameters, REVOKED_CERTIFICATES, CertificateRevocationList.defaultValues(REVOKED_CERTIFICATES));
            }
            if (CRL_EXTENSIONS in parameters) {
                this.crlExtensions = getParametersValue(parameters, CRL_EXTENSIONS, CertificateRevocationList.defaultValues(CRL_EXTENSIONS));
            }
            this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$4, CertificateRevocationList.defaultValues(SIGNATURE_ALGORITHM$4));
            this.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE$1, CertificateRevocationList.defaultValues(SIGNATURE_VALUE$1));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        get tbs() {
            return BufferSourceConverter_1.toArrayBuffer(this.tbsView);
        }
        set tbs(value) {
            this.tbsView = new Uint8Array(value);
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TBS$3:
                    return EMPTY_BUFFER;
                case VERSION$e:
                    return 0;
                case SIGNATURE$3:
                    return new AlgorithmIdentifier();
                case ISSUER$1:
                    return new RelativeDistinguishedNames();
                case THIS_UPDATE$1:
                    return new Time();
                case NEXT_UPDATE$1:
                    return new Time();
                case REVOKED_CERTIFICATES:
                    return [];
                case CRL_EXTENSIONS:
                    return new Extensions();
                case SIGNATURE_ALGORITHM$4:
                    return new AlgorithmIdentifier();
                case SIGNATURE_VALUE$1:
                    return new BitString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || "CertificateList"),
                value: [
                    tbsCertList(parameters),
                    AlgorithmIdentifier.schema(names.signatureAlgorithm || {
                        names: {
                            blockName: SIGNATURE_ALGORITHM$4
                        }
                    }),
                    new BitString({ name: (names.signatureValue || SIGNATURE_VALUE$1) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$N);
            const asn1 = compareSchema(schema, schema, CertificateRevocationList.schema());
            AsnError.assertSchema(asn1, this.className);
            this.tbsView = asn1.result.tbsCertList.valueBeforeDecodeView;
            if (TBS_CERT_LIST_VERSION in asn1.result) {
                this.version = asn1.result[TBS_CERT_LIST_VERSION].valueBlock.valueDec;
            }
            this.signature = new AlgorithmIdentifier({ schema: asn1.result[TBS_CERT_LIST_SIGNATURE] });
            this.issuer = new RelativeDistinguishedNames({ schema: asn1.result[TBS_CERT_LIST_ISSUER] });
            this.thisUpdate = new Time({ schema: asn1.result[TBS_CERT_LIST_THIS_UPDATE] });
            if (TBS_CERT_LIST_NEXT_UPDATE in asn1.result) {
                this.nextUpdate = new Time({ schema: asn1.result[TBS_CERT_LIST_NEXT_UPDATE] });
            }
            if (TBS_CERT_LIST_REVOKED_CERTIFICATES in asn1.result) {
                this.revokedCertificates = Array.from(asn1.result[TBS_CERT_LIST_REVOKED_CERTIFICATES], element => new RevokedCertificate({ schema: element }));
            }
            if (TBS_CERT_LIST_EXTENSIONS in asn1.result) {
                this.crlExtensions = new Extensions({ schema: asn1.result[TBS_CERT_LIST_EXTENSIONS] });
            }
            this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
            this.signatureValue = asn1.result.signatureValue;
        }
        encodeTBS() {
            const outputArray = [];
            if (this.version !== CertificateRevocationList.defaultValues(VERSION$e)) {
                outputArray.push(new Integer({ value: this.version }));
            }
            outputArray.push(this.signature.toSchema());
            outputArray.push(this.issuer.toSchema());
            outputArray.push(this.thisUpdate.toSchema());
            if (this.nextUpdate) {
                outputArray.push(this.nextUpdate.toSchema());
            }
            if (this.revokedCertificates) {
                outputArray.push(new Sequence({
                    value: Array.from(this.revokedCertificates, o => o.toSchema())
                }));
            }
            if (this.crlExtensions) {
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        this.crlExtensions.toSchema()
                    ]
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toSchema(encodeFlag = false) {
            let tbsSchema;
            if (!encodeFlag) {
                if (!this.tbsView.byteLength) {
                    return CertificateRevocationList.schema();
                }
                const asn1 = fromBER(this.tbsView);
                AsnError.assert(asn1, "TBS Certificate Revocation List");
                tbsSchema = asn1.result;
            }
            else {
                tbsSchema = this.encodeTBS();
            }
            return (new Sequence({
                value: [
                    tbsSchema,
                    this.signatureAlgorithm.toSchema(),
                    this.signatureValue
                ]
            }));
        }
        toJSON() {
            const res = {
                tbs: Convert_1.ToHex(this.tbsView),
                version: this.version,
                signature: this.signature.toJSON(),
                issuer: this.issuer.toJSON(),
                thisUpdate: this.thisUpdate.toJSON(),
                signatureAlgorithm: this.signatureAlgorithm.toJSON(),
                signatureValue: this.signatureValue.toJSON()
            };
            if (this.version !== CertificateRevocationList.defaultValues(VERSION$e))
                res.version = this.version;
            if (this.nextUpdate) {
                res.nextUpdate = this.nextUpdate.toJSON();
            }
            if (this.revokedCertificates) {
                res.revokedCertificates = Array.from(this.revokedCertificates, o => o.toJSON());
            }
            if (this.crlExtensions) {
                res.crlExtensions = this.crlExtensions.toJSON();
            }
            return res;
        }
        isCertificateRevoked(certificate) {
            if (!this.issuer.isEqual(certificate.issuer)) {
                return false;
            }
            if (!this.revokedCertificates) {
                return false;
            }
            for (const revokedCertificate of this.revokedCertificates) {
                if (revokedCertificate.userCertificate.isEqual(certificate.serialNumber)) {
                    return true;
                }
            }
            return false;
        }
        async sign(privateKey, hashAlgorithm = "SHA-1", crypto = getCrypto(true)) {
            if (!privateKey) {
                throw new Error("Need to provide a private key for signing");
            }
            const signatureParameters = await crypto.getSignatureParameters(privateKey, hashAlgorithm);
            const { parameters } = signatureParameters;
            this.signature = signatureParameters.signatureAlgorithm;
            this.signatureAlgorithm = signatureParameters.signatureAlgorithm;
            this.tbsView = new Uint8Array(this.encodeTBS().toBER());
            const signature = await crypto.signWithPrivateKey(this.tbsView, privateKey, parameters);
            this.signatureValue = new BitString({ valueHex: signature });
        }
        async verify(parameters = {}, crypto = getCrypto(true)) {
            let subjectPublicKeyInfo;
            if (parameters.issuerCertificate) {
                subjectPublicKeyInfo = parameters.issuerCertificate.subjectPublicKeyInfo;
                if (!this.issuer.isEqual(parameters.issuerCertificate.subject)) {
                    return false;
                }
            }
            if (parameters.publicKeyInfo) {
                subjectPublicKeyInfo = parameters.publicKeyInfo;
            }
            if (!subjectPublicKeyInfo) {
                throw new Error("Issuer's certificate must be provided as an input parameter");
            }
            if (this.crlExtensions) {
                for (const extension of this.crlExtensions.extensions) {
                    if (extension.critical) {
                        if (!WELL_KNOWN_EXTENSIONS.includes(extension.extnID))
                            return false;
                    }
                }
            }
            return crypto.verifyWithPublicKey(this.tbsView, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm);
        }
    }
    CertificateRevocationList.CLASS_NAME = "CertificateRevocationList";

    const CRL_ID = "crlId";
    const CRL_VALUE = "crlValue";
    const PARSED_VALUE$3 = "parsedValue";
    const CLEAR_PROPS$M = [
        CRL_ID,
        CRL_VALUE,
    ];
    class CRLBag extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.crlId = getParametersValue(parameters, CRL_ID, CRLBag.defaultValues(CRL_ID));
            this.crlValue = getParametersValue(parameters, CRL_VALUE, CRLBag.defaultValues(CRL_VALUE));
            if (PARSED_VALUE$3 in parameters) {
                this.parsedValue = getParametersValue(parameters, PARSED_VALUE$3, CRLBag.defaultValues(PARSED_VALUE$3));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case CRL_ID:
                    return EMPTY_STRING;
                case CRL_VALUE:
                    return (new Any());
                case PARSED_VALUE$3:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case CRL_ID:
                    return (memberValue === EMPTY_STRING);
                case CRL_VALUE:
                    return (memberValue instanceof Any);
                case PARSED_VALUE$3:
                    return ((memberValue instanceof Object) && (Object.keys(memberValue).length === 0));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.id || "id") }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [new Any({ name: (names.value || "value") })]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$M);
            const asn1 = compareSchema(schema, schema, CRLBag.schema({
                names: {
                    id: CRL_ID,
                    value: CRL_VALUE
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.crlId = asn1.result.crlId.valueBlock.toString();
            this.crlValue = asn1.result.crlValue;
            switch (this.crlId) {
                case id_CRLBag_X509CRL:
                    {
                        this.parsedValue = CertificateRevocationList.fromBER(this.certValue.valueBlock.valueHex);
                    }
                    break;
                default:
                    throw new Error(`Incorrect CRL_ID value in CRLBag: ${this.crlId}`);
            }
        }
        toSchema() {
            if (this.parsedValue) {
                this.crlId = id_CRLBag_X509CRL;
                this.crlValue = new OctetString({ valueHex: this.parsedValue.toSchema().toBER(false) });
            }
            return (new Sequence({
                value: [
                    new ObjectIdentifier({ value: this.crlId }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [this.crlValue.toSchema()]
                    })
                ]
            }));
        }
        toJSON() {
            return {
                crlId: this.crlId,
                crlValue: this.crlValue.toJSON()
            };
        }
    }
    CRLBag.CLASS_NAME = "CRLBag";

    const VERSION$d = "version";
    const ENCRYPTED_CONTENT_INFO$1 = "encryptedContentInfo";
    const UNPROTECTED_ATTRS$1 = "unprotectedAttrs";
    const CLEAR_PROPS$L = [
        VERSION$d,
        ENCRYPTED_CONTENT_INFO$1,
        UNPROTECTED_ATTRS$1,
    ];
    class EncryptedData extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$d, EncryptedData.defaultValues(VERSION$d));
            this.encryptedContentInfo = getParametersValue(parameters, ENCRYPTED_CONTENT_INFO$1, EncryptedData.defaultValues(ENCRYPTED_CONTENT_INFO$1));
            if (UNPROTECTED_ATTRS$1 in parameters) {
                this.unprotectedAttrs = getParametersValue(parameters, UNPROTECTED_ATTRS$1, EncryptedData.defaultValues(UNPROTECTED_ATTRS$1));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$d:
                    return 0;
                case ENCRYPTED_CONTENT_INFO$1:
                    return new EncryptedContentInfo();
                case UNPROTECTED_ATTRS$1:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VERSION$d:
                    return (memberValue === 0);
                case ENCRYPTED_CONTENT_INFO$1:
                    return ((EncryptedContentInfo.compareWithDefault("contentType", memberValue.contentType)) &&
                        (EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm", memberValue.contentEncryptionAlgorithm)) &&
                        (EncryptedContentInfo.compareWithDefault("encryptedContent", memberValue.encryptedContent)));
                case UNPROTECTED_ATTRS$1:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.version || EMPTY_STRING) }),
                    EncryptedContentInfo.schema(names.encryptedContentInfo || {}),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [
                            new Repeated({
                                name: (names.unprotectedAttrs || EMPTY_STRING),
                                value: Attribute.schema()
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$L);
            const asn1 = compareSchema(schema, schema, EncryptedData.schema({
                names: {
                    version: VERSION$d,
                    encryptedContentInfo: {
                        names: {
                            blockName: ENCRYPTED_CONTENT_INFO$1
                        }
                    },
                    unprotectedAttrs: UNPROTECTED_ATTRS$1
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result.version.valueBlock.valueDec;
            this.encryptedContentInfo = new EncryptedContentInfo({ schema: asn1.result.encryptedContentInfo });
            if (UNPROTECTED_ATTRS$1 in asn1.result)
                this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, element => new Attribute({ schema: element }));
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new Integer({ value: this.version }));
            outputArray.push(this.encryptedContentInfo.toSchema());
            if (this.unprotectedAttrs) {
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: Array.from(this.unprotectedAttrs, o => o.toSchema())
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                version: this.version,
                encryptedContentInfo: this.encryptedContentInfo.toJSON()
            };
            if (this.unprotectedAttrs)
                res.unprotectedAttrs = Array.from(this.unprotectedAttrs, o => o.toJSON());
            return res;
        }
        async encrypt(parameters) {
            ArgumentError.assert(parameters, "parameters", "object");
            const encryptParams = {
                ...parameters,
                contentType: "1.2.840.113549.1.7.1",
            };
            this.encryptedContentInfo = await getCrypto(true).encryptEncryptedContentInfo(encryptParams);
        }
        async decrypt(parameters, crypto = getCrypto(true)) {
            ArgumentError.assert(parameters, "parameters", "object");
            const decryptParams = {
                ...parameters,
                encryptedContentInfo: this.encryptedContentInfo,
            };
            return crypto.decryptEncryptedContentInfo(decryptParams);
        }
    }
    EncryptedData.CLASS_NAME = "EncryptedData";

    const ENCRYPTION_ALGORITHM = "encryptionAlgorithm";
    const ENCRYPTED_DATA = "encryptedData";
    const PARSED_VALUE$2 = "parsedValue";
    const CLEAR_PROPS$K = [
        ENCRYPTION_ALGORITHM,
        ENCRYPTED_DATA,
    ];
    class PKCS8ShroudedKeyBag extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.encryptionAlgorithm = getParametersValue(parameters, ENCRYPTION_ALGORITHM, PKCS8ShroudedKeyBag.defaultValues(ENCRYPTION_ALGORITHM));
            this.encryptedData = getParametersValue(parameters, ENCRYPTED_DATA, PKCS8ShroudedKeyBag.defaultValues(ENCRYPTED_DATA));
            if (PARSED_VALUE$2 in parameters) {
                this.parsedValue = getParametersValue(parameters, PARSED_VALUE$2, PKCS8ShroudedKeyBag.defaultValues(PARSED_VALUE$2));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ENCRYPTION_ALGORITHM:
                    return (new AlgorithmIdentifier());
                case ENCRYPTED_DATA:
                    return (new OctetString());
                case PARSED_VALUE$2:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case ENCRYPTION_ALGORITHM:
                    return ((AlgorithmIdentifier.compareWithDefault("algorithmId", memberValue.algorithmId)) &&
                        (("algorithmParams" in memberValue) === false));
                case ENCRYPTED_DATA:
                    return (memberValue.isEqual(PKCS8ShroudedKeyBag.defaultValues(memberName)));
                case PARSED_VALUE$2:
                    return ((memberValue instanceof Object) && (Object.keys(memberValue).length === 0));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    AlgorithmIdentifier.schema(names.encryptionAlgorithm || {
                        names: {
                            blockName: ENCRYPTION_ALGORITHM
                        }
                    }),
                    new Choice({
                        value: [
                            new OctetString({ name: (names.encryptedData || ENCRYPTED_DATA) }),
                            new OctetString({
                                idBlock: {
                                    isConstructed: true
                                },
                                name: (names.encryptedData || ENCRYPTED_DATA)
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$K);
            const asn1 = compareSchema(schema, schema, PKCS8ShroudedKeyBag.schema({
                names: {
                    encryptionAlgorithm: {
                        names: {
                            blockName: ENCRYPTION_ALGORITHM
                        }
                    },
                    encryptedData: ENCRYPTED_DATA
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.encryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.encryptionAlgorithm });
            this.encryptedData = asn1.result.encryptedData;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    this.encryptionAlgorithm.toSchema(),
                    this.encryptedData
                ]
            }));
        }
        toJSON() {
            return {
                encryptionAlgorithm: this.encryptionAlgorithm.toJSON(),
                encryptedData: this.encryptedData.toJSON(),
            };
        }
        async parseInternalValues(parameters, crypto = getCrypto(true)) {
            const cmsEncrypted = new EncryptedData({
                encryptedContentInfo: new EncryptedContentInfo({
                    contentEncryptionAlgorithm: this.encryptionAlgorithm,
                    encryptedContent: this.encryptedData
                })
            });
            const decryptedData = await cmsEncrypted.decrypt(parameters, crypto);
            this.parsedValue = PrivateKeyInfo.fromBER(decryptedData);
        }
        async makeInternalValues(parameters) {
            if (!this.parsedValue) {
                throw new Error("Please initialize \"parsedValue\" first");
            }
            const cmsEncrypted = new EncryptedData();
            const encryptParams = {
                ...parameters,
                contentToEncrypt: this.parsedValue.toSchema().toBER(false),
            };
            await cmsEncrypted.encrypt(encryptParams);
            if (!cmsEncrypted.encryptedContentInfo.encryptedContent) {
                throw new Error("The filed `encryptedContent` in EncryptedContentInfo is empty");
            }
            this.encryptionAlgorithm = cmsEncrypted.encryptedContentInfo.contentEncryptionAlgorithm;
            this.encryptedData = cmsEncrypted.encryptedContentInfo.encryptedContent;
        }
    }
    PKCS8ShroudedKeyBag.CLASS_NAME = "PKCS8ShroudedKeyBag";

    const SECRET_TYPE_ID = "secretTypeId";
    const SECRET_VALUE = "secretValue";
    const CLEAR_PROPS$J = [
        SECRET_TYPE_ID,
        SECRET_VALUE,
    ];
    class SecretBag extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.secretTypeId = getParametersValue(parameters, SECRET_TYPE_ID, SecretBag.defaultValues(SECRET_TYPE_ID));
            this.secretValue = getParametersValue(parameters, SECRET_VALUE, SecretBag.defaultValues(SECRET_VALUE));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case SECRET_TYPE_ID:
                    return EMPTY_STRING;
                case SECRET_VALUE:
                    return (new Any());
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case SECRET_TYPE_ID:
                    return (memberValue === EMPTY_STRING);
                case SECRET_VALUE:
                    return (memberValue instanceof Any);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.id || "id") }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [new Any({ name: (names.value || "value") })]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$J);
            const asn1 = compareSchema(schema, schema, SecretBag.schema({
                names: {
                    id: SECRET_TYPE_ID,
                    value: SECRET_VALUE
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.secretTypeId = asn1.result.secretTypeId.valueBlock.toString();
            this.secretValue = asn1.result.secretValue;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    new ObjectIdentifier({ value: this.secretTypeId }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [this.secretValue.toSchema()]
                    })
                ]
            }));
        }
        toJSON() {
            return {
                secretTypeId: this.secretTypeId,
                secretValue: this.secretValue.toJSON()
            };
        }
    }
    SecretBag.CLASS_NAME = "SecretBag";

    class SafeBagValueFactory {
        static getItems() {
            if (!this.items) {
                this.items = {};
                SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.1", PrivateKeyInfo);
                SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.2", PKCS8ShroudedKeyBag);
                SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.3", CertBag);
                SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.4", CRLBag);
                SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.5", SecretBag);
                SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.6", SafeContents);
            }
            return this.items;
        }
        static register(id, type) {
            this.getItems()[id] = type;
        }
        static find(id) {
            return this.getItems()[id] || null;
        }
    }

    const BAG_ID = "bagId";
    const BAG_VALUE = "bagValue";
    const BAG_ATTRIBUTES = "bagAttributes";
    const CLEAR_PROPS$I = [
        BAG_ID,
        BAG_VALUE,
        BAG_ATTRIBUTES
    ];
    class SafeBag extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.bagId = getParametersValue(parameters, BAG_ID, SafeBag.defaultValues(BAG_ID));
            this.bagValue = getParametersValue(parameters, BAG_VALUE, SafeBag.defaultValues(BAG_VALUE));
            if (BAG_ATTRIBUTES in parameters) {
                this.bagAttributes = getParametersValue(parameters, BAG_ATTRIBUTES, SafeBag.defaultValues(BAG_ATTRIBUTES));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case BAG_ID:
                    return EMPTY_STRING;
                case BAG_VALUE:
                    return (new Any());
                case BAG_ATTRIBUTES:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case BAG_ID:
                    return (memberValue === EMPTY_STRING);
                case BAG_VALUE:
                    return (memberValue instanceof Any);
                case BAG_ATTRIBUTES:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.bagId || BAG_ID) }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [new Any({ name: (names.bagValue || BAG_VALUE) })]
                    }),
                    new Set$1({
                        optional: true,
                        value: [
                            new Repeated({
                                name: (names.bagAttributes || BAG_ATTRIBUTES),
                                value: Attribute.schema()
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$I);
            const asn1 = compareSchema(schema, schema, SafeBag.schema({
                names: {
                    bagId: BAG_ID,
                    bagValue: BAG_VALUE,
                    bagAttributes: BAG_ATTRIBUTES
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.bagId = asn1.result.bagId.valueBlock.toString();
            const bagType = SafeBagValueFactory.find(this.bagId);
            if (!bagType) {
                throw new Error(`Invalid BAG_ID for SafeBag: ${this.bagId}`);
            }
            this.bagValue = new bagType({ schema: asn1.result.bagValue });
            if (BAG_ATTRIBUTES in asn1.result) {
                this.bagAttributes = Array.from(asn1.result.bagAttributes, element => new Attribute({ schema: element }));
            }
        }
        toSchema() {
            const outputArray = [
                new ObjectIdentifier({ value: this.bagId }),
                new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [this.bagValue.toSchema()]
                })
            ];
            if (this.bagAttributes) {
                outputArray.push(new Set$1({
                    value: Array.from(this.bagAttributes, o => o.toSchema())
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const output = {
                bagId: this.bagId,
                bagValue: this.bagValue.toJSON()
            };
            if (this.bagAttributes) {
                output.bagAttributes = Array.from(this.bagAttributes, o => o.toJSON());
            }
            return output;
        }
    }
    SafeBag.CLASS_NAME = "SafeBag";

    const SAFE_BUGS = "safeBags";
    class SafeContents extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.safeBags = getParametersValue(parameters, SAFE_BUGS, SafeContents.defaultValues(SAFE_BUGS));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case SAFE_BUGS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case SAFE_BUGS:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.safeBags || EMPTY_STRING),
                        value: SafeBag.schema()
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, [
                SAFE_BUGS
            ]);
            const asn1 = compareSchema(schema, schema, SafeContents.schema({
                names: {
                    safeBags: SAFE_BUGS
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.safeBags = Array.from(asn1.result.safeBags, element => new SafeBag({ schema: element }));
        }
        toSchema() {
            return (new Sequence({
                value: Array.from(this.safeBags, o => o.toSchema())
            }));
        }
        toJSON() {
            return {
                safeBags: Array.from(this.safeBags, o => o.toJSON())
            };
        }
    }
    SafeContents.CLASS_NAME = "SafeContents";

    const OTHER_CERT_FORMAT = "otherCertFormat";
    const OTHER_CERT = "otherCert";
    const CLEAR_PROPS$H = [
        OTHER_CERT_FORMAT,
        OTHER_CERT
    ];
    class OtherCertificateFormat extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.otherCertFormat = getParametersValue(parameters, OTHER_CERT_FORMAT, OtherCertificateFormat.defaultValues(OTHER_CERT_FORMAT));
            this.otherCert = getParametersValue(parameters, OTHER_CERT, OtherCertificateFormat.defaultValues(OTHER_CERT));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case OTHER_CERT_FORMAT:
                    return EMPTY_STRING;
                case OTHER_CERT:
                    return new Any();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.otherCertFormat || OTHER_CERT_FORMAT) }),
                    new Any({ name: (names.otherCert || OTHER_CERT) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$H);
            const asn1 = compareSchema(schema, schema, OtherCertificateFormat.schema());
            AsnError.assertSchema(asn1, this.className);
            this.otherCertFormat = asn1.result.otherCertFormat.valueBlock.toString();
            this.otherCert = asn1.result.otherCert;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    new ObjectIdentifier({ value: this.otherCertFormat }),
                    this.otherCert
                ]
            }));
        }
        toJSON() {
            const res = {
                otherCertFormat: this.otherCertFormat
            };
            if (!(this.otherCert instanceof Any)) {
                res.otherCert = this.otherCert.toJSON();
            }
            return res;
        }
    }

    const CERTIFICATES$1 = "certificates";
    const CLEAR_PROPS$G = [
        CERTIFICATES$1,
    ];
    class CertificateSet extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.certificates = getParametersValue(parameters, CERTIFICATES$1, CertificateSet.defaultValues(CERTIFICATES$1));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case CERTIFICATES$1:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Set$1({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.certificates || CERTIFICATES$1),
                        value: new Choice({
                            value: [
                                Certificate.schema(),
                                new Constructed({
                                    idBlock: {
                                        tagClass: 3,
                                        tagNumber: 0
                                    },
                                    value: [
                                        new Any()
                                    ]
                                }),
                                new Constructed({
                                    idBlock: {
                                        tagClass: 3,
                                        tagNumber: 1
                                    },
                                    value: [
                                        new Sequence
                                    ]
                                }),
                                new Constructed({
                                    idBlock: {
                                        tagClass: 3,
                                        tagNumber: 2
                                    },
                                    value: AttributeCertificateV2.schema().valueBlock.value
                                }),
                                new Constructed({
                                    idBlock: {
                                        tagClass: 3,
                                        tagNumber: 3
                                    },
                                    value: OtherCertificateFormat.schema().valueBlock.value
                                })
                            ]
                        })
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$G);
            const asn1 = compareSchema(schema, schema, CertificateSet.schema());
            AsnError.assertSchema(asn1, this.className);
            this.certificates = Array.from(asn1.result.certificates || [], (element) => {
                const initialTagNumber = element.idBlock.tagNumber;
                if (element.idBlock.tagClass === 1)
                    return new Certificate({ schema: element });
                const elementSequence = new Sequence({
                    value: element.valueBlock.value
                });
                switch (initialTagNumber) {
                    case 1:
                        if (elementSequence.valueBlock.value[0].valueBlock.value[0].valueBlock.valueDec === 1) {
                            return new AttributeCertificateV2({ schema: elementSequence });
                        }
                        else {
                            return new AttributeCertificateV1({ schema: elementSequence });
                        }
                    case 2:
                        return new AttributeCertificateV2({ schema: elementSequence });
                    case 3:
                        return new OtherCertificateFormat({ schema: elementSequence });
                }
                return element;
            });
        }
        toSchema() {
            return (new Set$1({
                value: Array.from(this.certificates, element => {
                    switch (true) {
                        case (element instanceof Certificate):
                            return element.toSchema();
                        case (element instanceof AttributeCertificateV1):
                            return new Constructed({
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 1
                                },
                                value: element.toSchema().valueBlock.value
                            });
                        case (element instanceof AttributeCertificateV2):
                            return new Constructed({
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 2
                                },
                                value: element.toSchema().valueBlock.value
                            });
                        case (element instanceof OtherCertificateFormat):
                            return new Constructed({
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 3
                                },
                                value: element.toSchema().valueBlock.value
                            });
                    }
                    return element.toSchema();
                })
            }));
        }
        toJSON() {
            return {
                certificates: Array.from(this.certificates, o => o.toJSON())
            };
        }
    }
    CertificateSet.CLASS_NAME = "CertificateSet";

    const OTHER_REV_INFO_FORMAT = "otherRevInfoFormat";
    const OTHER_REV_INFO = "otherRevInfo";
    const CLEAR_PROPS$F = [
        OTHER_REV_INFO_FORMAT,
        OTHER_REV_INFO
    ];
    class OtherRevocationInfoFormat extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.otherRevInfoFormat = getParametersValue(parameters, OTHER_REV_INFO_FORMAT, OtherRevocationInfoFormat.defaultValues(OTHER_REV_INFO_FORMAT));
            this.otherRevInfo = getParametersValue(parameters, OTHER_REV_INFO, OtherRevocationInfoFormat.defaultValues(OTHER_REV_INFO));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case OTHER_REV_INFO_FORMAT:
                    return EMPTY_STRING;
                case OTHER_REV_INFO:
                    return new Any();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.otherRevInfoFormat || OTHER_REV_INFO_FORMAT) }),
                    new Any({ name: (names.otherRevInfo || OTHER_REV_INFO) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$F);
            const asn1 = compareSchema(schema, schema, OtherRevocationInfoFormat.schema());
            AsnError.assertSchema(asn1, this.className);
            this.otherRevInfoFormat = asn1.result.otherRevInfoFormat.valueBlock.toString();
            this.otherRevInfo = asn1.result.otherRevInfo;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    new ObjectIdentifier({ value: this.otherRevInfoFormat }),
                    this.otherRevInfo
                ]
            }));
        }
        toJSON() {
            const res = {
                otherRevInfoFormat: this.otherRevInfoFormat
            };
            if (!(this.otherRevInfo instanceof Any)) {
                res.otherRevInfo = this.otherRevInfo.toJSON();
            }
            return res;
        }
    }
    OtherRevocationInfoFormat.CLASS_NAME = "OtherRevocationInfoFormat";

    const CRLS$3 = "crls";
    const OTHER_REVOCATION_INFOS = "otherRevocationInfos";
    const CLEAR_PROPS$E = [
        CRLS$3
    ];
    class RevocationInfoChoices extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.crls = getParametersValue(parameters, CRLS$3, RevocationInfoChoices.defaultValues(CRLS$3));
            this.otherRevocationInfos = getParametersValue(parameters, OTHER_REVOCATION_INFOS, RevocationInfoChoices.defaultValues(OTHER_REVOCATION_INFOS));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case CRLS$3:
                    return [];
                case OTHER_REVOCATION_INFOS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Set$1({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.crls || EMPTY_STRING),
                        value: new Choice({
                            value: [
                                CertificateRevocationList.schema(),
                                new Constructed({
                                    idBlock: {
                                        tagClass: 3,
                                        tagNumber: 1
                                    },
                                    value: [
                                        new ObjectIdentifier(),
                                        new Any()
                                    ]
                                })
                            ]
                        })
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$E);
            const asn1 = compareSchema(schema, schema, RevocationInfoChoices.schema({
                names: {
                    crls: CRLS$3
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (asn1.result.crls) {
                for (const element of asn1.result.crls) {
                    if (element.idBlock.tagClass === 1)
                        this.crls.push(new CertificateRevocationList({ schema: element }));
                    else
                        this.otherRevocationInfos.push(new OtherRevocationInfoFormat({ schema: element }));
                }
            }
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(...Array.from(this.crls, o => o.toSchema()));
            outputArray.push(...Array.from(this.otherRevocationInfos, element => {
                const schema = element.toSchema();
                schema.idBlock.tagClass = 3;
                schema.idBlock.tagNumber = 1;
                return schema;
            }));
            return (new Set$1({
                value: outputArray
            }));
        }
        toJSON() {
            return {
                crls: Array.from(this.crls, o => o.toJSON()),
                otherRevocationInfos: Array.from(this.otherRevocationInfos, o => o.toJSON())
            };
        }
    }
    RevocationInfoChoices.CLASS_NAME = "RevocationInfoChoices";

    const CERTS$3 = "certs";
    const CRLS$2 = "crls";
    const CLEAR_PROPS$D = [
        CERTS$3,
        CRLS$2,
    ];
    class OriginatorInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.crls = getParametersValue(parameters, CRLS$2, OriginatorInfo.defaultValues(CRLS$2));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case CERTS$3:
                    return new CertificateSet();
                case CRLS$2:
                    return new RevocationInfoChoices();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case CERTS$3:
                    return (memberValue.certificates.length === 0);
                case CRLS$2:
                    return ((memberValue.crls.length === 0) && (memberValue.otherRevocationInfos.length === 0));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Constructed({
                        name: (names.certs || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: CertificateSet.schema().valueBlock.value
                    }),
                    new Constructed({
                        name: (names.crls || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: RevocationInfoChoices.schema().valueBlock.value
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$D);
            const asn1 = compareSchema(schema, schema, OriginatorInfo.schema({
                names: {
                    certs: CERTS$3,
                    crls: CRLS$2
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (CERTS$3 in asn1.result) {
                this.certs = new CertificateSet({
                    schema: new Set$1({
                        value: asn1.result.certs.valueBlock.value
                    })
                });
            }
            if (CRLS$2 in asn1.result) {
                this.crls = new RevocationInfoChoices({
                    schema: new Set$1({
                        value: asn1.result.crls.valueBlock.value
                    })
                });
            }
        }
        toSchema() {
            const sequenceValue = [];
            if (this.certs) {
                sequenceValue.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: this.certs.toSchema().valueBlock.value
                }));
            }
            if (this.crls) {
                sequenceValue.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: this.crls.toSchema().valueBlock.value
                }));
            }
            return (new Sequence({
                value: sequenceValue
            }));
        }
        toJSON() {
            const res = {};
            if (this.certs) {
                res.certs = this.certs.toJSON();
            }
            if (this.crls) {
                res.crls = this.crls.toJSON();
            }
            return res;
        }
    }
    OriginatorInfo.CLASS_NAME = "OriginatorInfo";

    const ISSUER = "issuer";
    const SERIAL_NUMBER$2 = "serialNumber";
    const CLEAR_PROPS$C = [
        ISSUER,
        SERIAL_NUMBER$2,
    ];
    class IssuerAndSerialNumber extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.issuer = getParametersValue(parameters, ISSUER, IssuerAndSerialNumber.defaultValues(ISSUER));
            this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$2, IssuerAndSerialNumber.defaultValues(SERIAL_NUMBER$2));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ISSUER:
                    return new RelativeDistinguishedNames();
                case SERIAL_NUMBER$2:
                    return new Integer();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    RelativeDistinguishedNames.schema(names.issuer || {}),
                    new Integer({ name: (names.serialNumber || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$C);
            const asn1 = compareSchema(schema, schema, IssuerAndSerialNumber.schema({
                names: {
                    issuer: {
                        names: {
                            blockName: ISSUER
                        }
                    },
                    serialNumber: SERIAL_NUMBER$2
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.issuer = new RelativeDistinguishedNames({ schema: asn1.result.issuer });
            this.serialNumber = asn1.result.serialNumber;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    this.issuer.toSchema(),
                    this.serialNumber
                ]
            }));
        }
        toJSON() {
            return {
                issuer: this.issuer.toJSON(),
                serialNumber: this.serialNumber.toJSON(),
            };
        }
    }
    IssuerAndSerialNumber.CLASS_NAME = "IssuerAndSerialNumber";

    const VARIANT$3 = "variant";
    const VALUE$3 = "value";
    const CLEAR_PROPS$B = [
        "blockName"
    ];
    class RecipientIdentifier extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.variant = getParametersValue(parameters, VARIANT$3, RecipientIdentifier.defaultValues(VARIANT$3));
            if (VALUE$3 in parameters) {
                this.value = getParametersValue(parameters, VALUE$3, RecipientIdentifier.defaultValues(VALUE$3));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VARIANT$3:
                    return (-1);
                case VALUE$3:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VARIANT$3:
                    return (memberValue === (-1));
                case VALUE$3:
                    return (Object.keys(memberValue).length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Choice({
                value: [
                    IssuerAndSerialNumber.schema({
                        names: {
                            blockName: (names.blockName || EMPTY_STRING)
                        }
                    }),
                    new Primitive({
                        name: (names.blockName || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        }
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$B);
            const asn1 = compareSchema(schema, schema, RecipientIdentifier.schema({
                names: {
                    blockName: "blockName"
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (asn1.result.blockName.idBlock.tagClass === 1) {
                this.variant = 1;
                this.value = new IssuerAndSerialNumber({ schema: asn1.result.blockName });
            }
            else {
                this.variant = 2;
                this.value = new OctetString({ valueHex: asn1.result.blockName.valueBlock.valueHex });
            }
        }
        toSchema() {
            switch (this.variant) {
                case 1:
                    if (!(this.value instanceof IssuerAndSerialNumber)) {
                        throw new Error("Incorrect type of RecipientIdentifier.value. It should be IssuerAndSerialNumber.");
                    }
                    return this.value.toSchema();
                case 2:
                    if (!(this.value instanceof OctetString)) {
                        throw new Error("Incorrect type of RecipientIdentifier.value. It should be ASN.1 OctetString.");
                    }
                    return new Primitive({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        valueHex: this.value.valueBlock.valueHexView
                    });
                default:
                    return new Any();
            }
        }
        toJSON() {
            const res = {
                variant: this.variant
            };
            if ((this.variant === 1 || this.variant === 2) && this.value) {
                res.value = this.value.toJSON();
            }
            return res;
        }
    }
    RecipientIdentifier.CLASS_NAME = "RecipientIdentifier";

    const VERSION$c = "version";
    const RID$1 = "rid";
    const KEY_ENCRYPTION_ALGORITHM$3 = "keyEncryptionAlgorithm";
    const ENCRYPTED_KEY$3 = "encryptedKey";
    const RECIPIENT_CERTIFICATE$1 = "recipientCertificate";
    const CLEAR_PROPS$A = [
        VERSION$c,
        RID$1,
        KEY_ENCRYPTION_ALGORITHM$3,
        ENCRYPTED_KEY$3,
    ];
    class KeyTransRecipientInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$c, KeyTransRecipientInfo.defaultValues(VERSION$c));
            this.rid = getParametersValue(parameters, RID$1, KeyTransRecipientInfo.defaultValues(RID$1));
            this.keyEncryptionAlgorithm = getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM$3, KeyTransRecipientInfo.defaultValues(KEY_ENCRYPTION_ALGORITHM$3));
            this.encryptedKey = getParametersValue(parameters, ENCRYPTED_KEY$3, KeyTransRecipientInfo.defaultValues(ENCRYPTED_KEY$3));
            this.recipientCertificate = getParametersValue(parameters, RECIPIENT_CERTIFICATE$1, KeyTransRecipientInfo.defaultValues(RECIPIENT_CERTIFICATE$1));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$c:
                    return (-1);
                case RID$1:
                    return {};
                case KEY_ENCRYPTION_ALGORITHM$3:
                    return new AlgorithmIdentifier();
                case ENCRYPTED_KEY$3:
                    return new OctetString();
                case RECIPIENT_CERTIFICATE$1:
                    return new Certificate();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VERSION$c:
                    return (memberValue === KeyTransRecipientInfo.defaultValues(VERSION$c));
                case RID$1:
                    return (Object.keys(memberValue).length === 0);
                case KEY_ENCRYPTION_ALGORITHM$3:
                case ENCRYPTED_KEY$3:
                    return memberValue.isEqual(KeyTransRecipientInfo.defaultValues(memberName));
                case RECIPIENT_CERTIFICATE$1:
                    return false;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.version || EMPTY_STRING) }),
                    RecipientIdentifier.schema(names.rid || {}),
                    AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
                    new OctetString({ name: (names.encryptedKey || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$A);
            const asn1 = compareSchema(schema, schema, KeyTransRecipientInfo.schema({
                names: {
                    version: VERSION$c,
                    rid: {
                        names: {
                            blockName: RID$1
                        }
                    },
                    keyEncryptionAlgorithm: {
                        names: {
                            blockName: KEY_ENCRYPTION_ALGORITHM$3
                        }
                    },
                    encryptedKey: ENCRYPTED_KEY$3
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result.version.valueBlock.valueDec;
            if (asn1.result.rid.idBlock.tagClass === 3) {
                this.rid = new OctetString({ valueHex: asn1.result.rid.valueBlock.valueHex });
            }
            else {
                this.rid = new IssuerAndSerialNumber({ schema: asn1.result.rid });
            }
            this.keyEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.keyEncryptionAlgorithm });
            this.encryptedKey = asn1.result.encryptedKey;
        }
        toSchema() {
            const outputArray = [];
            if (this.rid instanceof IssuerAndSerialNumber) {
                this.version = 0;
                outputArray.push(new Integer({ value: this.version }));
                outputArray.push(this.rid.toSchema());
            }
            else {
                this.version = 2;
                outputArray.push(new Integer({ value: this.version }));
                outputArray.push(new Primitive({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    valueHex: this.rid.valueBlock.valueHexView
                }));
            }
            outputArray.push(this.keyEncryptionAlgorithm.toSchema());
            outputArray.push(this.encryptedKey);
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            return {
                version: this.version,
                rid: this.rid.toJSON(),
                keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
                encryptedKey: this.encryptedKey.toJSON(),
            };
        }
    }
    KeyTransRecipientInfo.CLASS_NAME = "KeyTransRecipientInfo";

    const ALGORITHM = "algorithm";
    const PUBLIC_KEY = "publicKey";
    const CLEAR_PROPS$z = [
        ALGORITHM,
        PUBLIC_KEY
    ];
    class OriginatorPublicKey extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.algorithm = getParametersValue(parameters, ALGORITHM, OriginatorPublicKey.defaultValues(ALGORITHM));
            this.publicKey = getParametersValue(parameters, PUBLIC_KEY, OriginatorPublicKey.defaultValues(PUBLIC_KEY));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ALGORITHM:
                    return new AlgorithmIdentifier();
                case PUBLIC_KEY:
                    return new BitString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case ALGORITHM:
                case PUBLIC_KEY:
                    return (memberValue.isEqual(OriginatorPublicKey.defaultValues(memberName)));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    AlgorithmIdentifier.schema(names.algorithm || {}),
                    new BitString({ name: (names.publicKey || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$z);
            const asn1 = compareSchema(schema, schema, OriginatorPublicKey.schema({
                names: {
                    algorithm: {
                        names: {
                            blockName: ALGORITHM
                        }
                    },
                    publicKey: PUBLIC_KEY
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.algorithm = new AlgorithmIdentifier({ schema: asn1.result.algorithm });
            this.publicKey = asn1.result.publicKey;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    this.algorithm.toSchema(),
                    this.publicKey
                ]
            }));
        }
        toJSON() {
            return {
                algorithm: this.algorithm.toJSON(),
                publicKey: this.publicKey.toJSON(),
            };
        }
    }
    OriginatorPublicKey.CLASS_NAME = "OriginatorPublicKey";

    const VARIANT$2 = "variant";
    const VALUE$2 = "value";
    const CLEAR_PROPS$y = [
        "blockName",
    ];
    class OriginatorIdentifierOrKey extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.variant = getParametersValue(parameters, VARIANT$2, OriginatorIdentifierOrKey.defaultValues(VARIANT$2));
            if (VALUE$2 in parameters) {
                this.value = getParametersValue(parameters, VALUE$2, OriginatorIdentifierOrKey.defaultValues(VALUE$2));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VARIANT$2:
                    return (-1);
                case VALUE$2:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VARIANT$2:
                    return (memberValue === (-1));
                case VALUE$2:
                    return (Object.keys(memberValue).length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Choice({
                value: [
                    IssuerAndSerialNumber.schema({
                        names: {
                            blockName: (names.blockName || EMPTY_STRING)
                        }
                    }),
                    new Primitive({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        name: (names.blockName || EMPTY_STRING)
                    }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        name: (names.blockName || EMPTY_STRING),
                        value: OriginatorPublicKey.schema().valueBlock.value
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$y);
            const asn1 = compareSchema(schema, schema, OriginatorIdentifierOrKey.schema({
                names: {
                    blockName: "blockName"
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (asn1.result.blockName.idBlock.tagClass === 1) {
                this.variant = 1;
                this.value = new IssuerAndSerialNumber({ schema: asn1.result.blockName });
            }
            else {
                if (asn1.result.blockName.idBlock.tagNumber === 0) {
                    asn1.result.blockName.idBlock.tagClass = 1;
                    asn1.result.blockName.idBlock.tagNumber = 4;
                    this.variant = 2;
                    this.value = asn1.result.blockName;
                }
                else {
                    this.variant = 3;
                    this.value = new OriginatorPublicKey({
                        schema: new Sequence({
                            value: asn1.result.blockName.valueBlock.value
                        })
                    });
                }
            }
        }
        toSchema() {
            switch (this.variant) {
                case 1:
                    return this.value.toSchema();
                case 2:
                    this.value.idBlock.tagClass = 3;
                    this.value.idBlock.tagNumber = 0;
                    return this.value;
                case 3:
                    {
                        const _schema = this.value.toSchema();
                        _schema.idBlock.tagClass = 3;
                        _schema.idBlock.tagNumber = 1;
                        return _schema;
                    }
                default:
                    return new Any();
            }
        }
        toJSON() {
            const res = {
                variant: this.variant
            };
            if ((this.variant === 1) || (this.variant === 2) || (this.variant === 3)) {
                res.value = this.value.toJSON();
            }
            return res;
        }
    }
    OriginatorIdentifierOrKey.CLASS_NAME = "OriginatorIdentifierOrKey";

    const KEY_ATTR_ID = "keyAttrId";
    const KEY_ATTR = "keyAttr";
    const CLEAR_PROPS$x = [
        KEY_ATTR_ID,
        KEY_ATTR,
    ];
    class OtherKeyAttribute extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.keyAttrId = getParametersValue(parameters, KEY_ATTR_ID, OtherKeyAttribute.defaultValues(KEY_ATTR_ID));
            if (KEY_ATTR in parameters) {
                this.keyAttr = getParametersValue(parameters, KEY_ATTR, OtherKeyAttribute.defaultValues(KEY_ATTR));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case KEY_ATTR_ID:
                    return EMPTY_STRING;
                case KEY_ATTR:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case KEY_ATTR_ID:
                    return (typeof memberValue === "string" && memberValue === EMPTY_STRING);
                case KEY_ATTR:
                    return (Object.keys(memberValue).length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                optional: (names.optional || true),
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.keyAttrId || EMPTY_STRING) }),
                    new Any({
                        optional: true,
                        name: (names.keyAttr || EMPTY_STRING)
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$x);
            const asn1 = compareSchema(schema, schema, OtherKeyAttribute.schema({
                names: {
                    keyAttrId: KEY_ATTR_ID,
                    keyAttr: KEY_ATTR
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.keyAttrId = asn1.result.keyAttrId.valueBlock.toString();
            if (KEY_ATTR in asn1.result) {
                this.keyAttr = asn1.result.keyAttr;
            }
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new ObjectIdentifier({ value: this.keyAttrId }));
            if (KEY_ATTR in this) {
                outputArray.push(this.keyAttr);
            }
            return (new Sequence({
                value: outputArray,
            }));
        }
        toJSON() {
            const res = {
                keyAttrId: this.keyAttrId
            };
            if (KEY_ATTR in this) {
                res.keyAttr = this.keyAttr.toJSON();
            }
            return res;
        }
    }
    OtherKeyAttribute.CLASS_NAME = "OtherKeyAttribute";

    const SUBJECT_KEY_IDENTIFIER = "subjectKeyIdentifier";
    const DATE$1 = "date";
    const OTHER$1 = "other";
    const CLEAR_PROPS$w = [
        SUBJECT_KEY_IDENTIFIER,
        DATE$1,
        OTHER$1,
    ];
    class RecipientKeyIdentifier extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.subjectKeyIdentifier = getParametersValue(parameters, SUBJECT_KEY_IDENTIFIER, RecipientKeyIdentifier.defaultValues(SUBJECT_KEY_IDENTIFIER));
            if (DATE$1 in parameters) {
                this.date = getParametersValue(parameters, DATE$1, RecipientKeyIdentifier.defaultValues(DATE$1));
            }
            if (OTHER$1 in parameters) {
                this.other = getParametersValue(parameters, OTHER$1, RecipientKeyIdentifier.defaultValues(OTHER$1));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case SUBJECT_KEY_IDENTIFIER:
                    return new OctetString();
                case DATE$1:
                    return new GeneralizedTime();
                case OTHER$1:
                    return new OtherKeyAttribute();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case SUBJECT_KEY_IDENTIFIER:
                    return (memberValue.isEqual(RecipientKeyIdentifier.defaultValues(SUBJECT_KEY_IDENTIFIER)));
                case DATE$1:
                    return ((memberValue.year === 0) &&
                        (memberValue.month === 0) &&
                        (memberValue.day === 0) &&
                        (memberValue.hour === 0) &&
                        (memberValue.minute === 0) &&
                        (memberValue.second === 0) &&
                        (memberValue.millisecond === 0));
                case OTHER$1:
                    return ((memberValue.keyAttrId === EMPTY_STRING) && (("keyAttr" in memberValue) === false));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new OctetString({ name: (names.subjectKeyIdentifier || EMPTY_STRING) }),
                    new GeneralizedTime({
                        optional: true,
                        name: (names.date || EMPTY_STRING)
                    }),
                    OtherKeyAttribute.schema(names.other || {})
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$w);
            const asn1 = compareSchema(schema, schema, RecipientKeyIdentifier.schema({
                names: {
                    subjectKeyIdentifier: SUBJECT_KEY_IDENTIFIER,
                    date: DATE$1,
                    other: {
                        names: {
                            blockName: OTHER$1
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.subjectKeyIdentifier = asn1.result.subjectKeyIdentifier;
            if (DATE$1 in asn1.result)
                this.date = asn1.result.date;
            if (OTHER$1 in asn1.result)
                this.other = new OtherKeyAttribute({ schema: asn1.result.other });
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(this.subjectKeyIdentifier);
            if (this.date) {
                outputArray.push(this.date);
            }
            if (this.other) {
                outputArray.push(this.other.toSchema());
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                subjectKeyIdentifier: this.subjectKeyIdentifier.toJSON()
            };
            if (this.date) {
                res.date = this.date.toJSON();
            }
            if (this.other) {
                res.other = this.other.toJSON();
            }
            return res;
        }
    }
    RecipientKeyIdentifier.CLASS_NAME = "RecipientKeyIdentifier";

    const VARIANT$1 = "variant";
    const VALUE$1 = "value";
    const CLEAR_PROPS$v = [
        "blockName",
    ];
    class KeyAgreeRecipientIdentifier extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.variant = getParametersValue(parameters, VARIANT$1, KeyAgreeRecipientIdentifier.defaultValues(VARIANT$1));
            this.value = getParametersValue(parameters, VALUE$1, KeyAgreeRecipientIdentifier.defaultValues(VALUE$1));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VARIANT$1:
                    return (-1);
                case VALUE$1:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VARIANT$1:
                    return (memberValue === (-1));
                case VALUE$1:
                    return (Object.keys(memberValue).length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Choice({
                value: [
                    IssuerAndSerialNumber.schema(names.issuerAndSerialNumber || {
                        names: {
                            blockName: (names.blockName || EMPTY_STRING)
                        }
                    }),
                    new Constructed({
                        name: (names.blockName || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: RecipientKeyIdentifier.schema(names.rKeyId || {
                            names: {
                                blockName: (names.blockName || EMPTY_STRING)
                            }
                        }).valueBlock.value
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$v);
            const asn1 = compareSchema(schema, schema, KeyAgreeRecipientIdentifier.schema({
                names: {
                    blockName: "blockName"
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (asn1.result.blockName.idBlock.tagClass === 1) {
                this.variant = 1;
                this.value = new IssuerAndSerialNumber({ schema: asn1.result.blockName });
            }
            else {
                this.variant = 2;
                this.value = new RecipientKeyIdentifier({
                    schema: new Sequence({
                        value: asn1.result.blockName.valueBlock.value
                    })
                });
            }
        }
        toSchema() {
            switch (this.variant) {
                case 1:
                    return this.value.toSchema();
                case 2:
                    return new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: this.value.toSchema().valueBlock.value
                    });
                default:
                    return new Any();
            }
        }
        toJSON() {
            const res = {
                variant: this.variant,
            };
            if ((this.variant === 1) || (this.variant === 2)) {
                res.value = this.value.toJSON();
            }
            return res;
        }
    }
    KeyAgreeRecipientIdentifier.CLASS_NAME = "KeyAgreeRecipientIdentifier";

    const RID = "rid";
    const ENCRYPTED_KEY$2 = "encryptedKey";
    const CLEAR_PROPS$u = [
        RID,
        ENCRYPTED_KEY$2,
    ];
    class RecipientEncryptedKey extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.rid = getParametersValue(parameters, RID, RecipientEncryptedKey.defaultValues(RID));
            this.encryptedKey = getParametersValue(parameters, ENCRYPTED_KEY$2, RecipientEncryptedKey.defaultValues(ENCRYPTED_KEY$2));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case RID:
                    return new KeyAgreeRecipientIdentifier();
                case ENCRYPTED_KEY$2:
                    return new OctetString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case RID:
                    return ((memberValue.variant === (-1)) && (("value" in memberValue) === false));
                case ENCRYPTED_KEY$2:
                    return (memberValue.isEqual(RecipientEncryptedKey.defaultValues(ENCRYPTED_KEY$2)));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    KeyAgreeRecipientIdentifier.schema(names.rid || {}),
                    new OctetString({ name: (names.encryptedKey || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$u);
            const asn1 = compareSchema(schema, schema, RecipientEncryptedKey.schema({
                names: {
                    rid: {
                        names: {
                            blockName: RID
                        }
                    },
                    encryptedKey: ENCRYPTED_KEY$2
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.rid = new KeyAgreeRecipientIdentifier({ schema: asn1.result.rid });
            this.encryptedKey = asn1.result.encryptedKey;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    this.rid.toSchema(),
                    this.encryptedKey
                ]
            }));
        }
        toJSON() {
            return {
                rid: this.rid.toJSON(),
                encryptedKey: this.encryptedKey.toJSON(),
            };
        }
    }
    RecipientEncryptedKey.CLASS_NAME = "RecipientEncryptedKey";

    const ENCRYPTED_KEYS = "encryptedKeys";
    const RECIPIENT_ENCRYPTED_KEYS = "RecipientEncryptedKeys";
    const CLEAR_PROPS$t = [
        RECIPIENT_ENCRYPTED_KEYS,
    ];
    class RecipientEncryptedKeys extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.encryptedKeys = getParametersValue(parameters, ENCRYPTED_KEYS, RecipientEncryptedKeys.defaultValues(ENCRYPTED_KEYS));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ENCRYPTED_KEYS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case ENCRYPTED_KEYS:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.RecipientEncryptedKeys || EMPTY_STRING),
                        value: RecipientEncryptedKey.schema()
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$t);
            const asn1 = compareSchema(schema, schema, RecipientEncryptedKeys.schema({
                names: {
                    RecipientEncryptedKeys: RECIPIENT_ENCRYPTED_KEYS
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.encryptedKeys = Array.from(asn1.result.RecipientEncryptedKeys, element => new RecipientEncryptedKey({ schema: element }));
        }
        toSchema() {
            return (new Sequence({
                value: Array.from(this.encryptedKeys, o => o.toSchema())
            }));
        }
        toJSON() {
            return {
                encryptedKeys: Array.from(this.encryptedKeys, o => o.toJSON())
            };
        }
    }
    RecipientEncryptedKeys.CLASS_NAME = "RecipientEncryptedKeys";

    const VERSION$b = "version";
    const ORIGINATOR = "originator";
    const UKM = "ukm";
    const KEY_ENCRYPTION_ALGORITHM$2 = "keyEncryptionAlgorithm";
    const RECIPIENT_ENCRYPTED_KEY = "recipientEncryptedKeys";
    const RECIPIENT_CERTIFICATE = "recipientCertificate";
    const RECIPIENT_PUBLIC_KEY = "recipientPublicKey";
    const CLEAR_PROPS$s = [
        VERSION$b,
        ORIGINATOR,
        UKM,
        KEY_ENCRYPTION_ALGORITHM$2,
        RECIPIENT_ENCRYPTED_KEY,
    ];
    class KeyAgreeRecipientInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$b, KeyAgreeRecipientInfo.defaultValues(VERSION$b));
            this.originator = getParametersValue(parameters, ORIGINATOR, KeyAgreeRecipientInfo.defaultValues(ORIGINATOR));
            if (UKM in parameters) {
                this.ukm = getParametersValue(parameters, UKM, KeyAgreeRecipientInfo.defaultValues(UKM));
            }
            this.keyEncryptionAlgorithm = getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM$2, KeyAgreeRecipientInfo.defaultValues(KEY_ENCRYPTION_ALGORITHM$2));
            this.recipientEncryptedKeys = getParametersValue(parameters, RECIPIENT_ENCRYPTED_KEY, KeyAgreeRecipientInfo.defaultValues(RECIPIENT_ENCRYPTED_KEY));
            this.recipientCertificate = getParametersValue(parameters, RECIPIENT_CERTIFICATE, KeyAgreeRecipientInfo.defaultValues(RECIPIENT_CERTIFICATE));
            this.recipientPublicKey = getParametersValue(parameters, RECIPIENT_PUBLIC_KEY, KeyAgreeRecipientInfo.defaultValues(RECIPIENT_PUBLIC_KEY));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$b:
                    return 0;
                case ORIGINATOR:
                    return new OriginatorIdentifierOrKey();
                case UKM:
                    return new OctetString();
                case KEY_ENCRYPTION_ALGORITHM$2:
                    return new AlgorithmIdentifier();
                case RECIPIENT_ENCRYPTED_KEY:
                    return new RecipientEncryptedKeys();
                case RECIPIENT_CERTIFICATE:
                    return new Certificate();
                case RECIPIENT_PUBLIC_KEY:
                    return null;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VERSION$b:
                    return (memberValue === 0);
                case ORIGINATOR:
                    return ((memberValue.variant === (-1)) && (("value" in memberValue) === false));
                case UKM:
                    return (memberValue.isEqual(KeyAgreeRecipientInfo.defaultValues(UKM)));
                case KEY_ENCRYPTION_ALGORITHM$2:
                    return ((memberValue.algorithmId === EMPTY_STRING) && (("algorithmParams" in memberValue) === false));
                case RECIPIENT_ENCRYPTED_KEY:
                    return (memberValue.encryptedKeys.length === 0);
                case RECIPIENT_CERTIFICATE:
                    return false;
                case RECIPIENT_PUBLIC_KEY:
                    return false;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: names.blockName || EMPTY_STRING,
                value: [
                    new Integer({ name: names.version || EMPTY_STRING }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [
                            OriginatorIdentifierOrKey.schema(names.originator || {})
                        ]
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [new OctetString({ name: names.ukm || EMPTY_STRING })]
                    }),
                    AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
                    RecipientEncryptedKeys.schema(names.recipientEncryptedKeys || {})
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$s);
            const asn1 = compareSchema(schema, schema, KeyAgreeRecipientInfo.schema({
                names: {
                    version: VERSION$b,
                    originator: {
                        names: {
                            blockName: ORIGINATOR
                        }
                    },
                    ukm: UKM,
                    keyEncryptionAlgorithm: {
                        names: {
                            blockName: KEY_ENCRYPTION_ALGORITHM$2
                        }
                    },
                    recipientEncryptedKeys: {
                        names: {
                            blockName: RECIPIENT_ENCRYPTED_KEY
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result.version.valueBlock.valueDec;
            this.originator = new OriginatorIdentifierOrKey({ schema: asn1.result.originator });
            if (UKM in asn1.result)
                this.ukm = asn1.result.ukm;
            this.keyEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.keyEncryptionAlgorithm });
            this.recipientEncryptedKeys = new RecipientEncryptedKeys({ schema: asn1.result.recipientEncryptedKeys });
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new Integer({ value: this.version }));
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                },
                value: [this.originator.toSchema()]
            }));
            if (this.ukm) {
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [this.ukm]
                }));
            }
            outputArray.push(this.keyEncryptionAlgorithm.toSchema());
            outputArray.push(this.recipientEncryptedKeys.toSchema());
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                version: this.version,
                originator: this.originator.toJSON(),
                keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
                recipientEncryptedKeys: this.recipientEncryptedKeys.toJSON(),
            };
            if (this.ukm) {
                res.ukm = this.ukm.toJSON();
            }
            return res;
        }
    }
    KeyAgreeRecipientInfo.CLASS_NAME = "KeyAgreeRecipientInfo";

    const KEY_IDENTIFIER = "keyIdentifier";
    const DATE = "date";
    const OTHER = "other";
    const CLEAR_PROPS$r = [
        KEY_IDENTIFIER,
        DATE,
        OTHER,
    ];
    class KEKIdentifier extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.keyIdentifier = getParametersValue(parameters, KEY_IDENTIFIER, KEKIdentifier.defaultValues(KEY_IDENTIFIER));
            if (DATE in parameters) {
                this.date = getParametersValue(parameters, DATE, KEKIdentifier.defaultValues(DATE));
            }
            if (OTHER in parameters) {
                this.other = getParametersValue(parameters, OTHER, KEKIdentifier.defaultValues(OTHER));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case KEY_IDENTIFIER:
                    return new OctetString();
                case DATE:
                    return new GeneralizedTime();
                case OTHER:
                    return new OtherKeyAttribute();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case KEY_IDENTIFIER:
                    return (memberValue.isEqual(KEKIdentifier.defaultValues(KEY_IDENTIFIER)));
                case DATE:
                    return ((memberValue.year === 0) &&
                        (memberValue.month === 0) &&
                        (memberValue.day === 0) &&
                        (memberValue.hour === 0) &&
                        (memberValue.minute === 0) &&
                        (memberValue.second === 0) &&
                        (memberValue.millisecond === 0));
                case OTHER:
                    return ((memberValue.compareWithDefault("keyAttrId", memberValue.keyAttrId)) &&
                        (("keyAttr" in memberValue) === false));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new OctetString({ name: (names.keyIdentifier || EMPTY_STRING) }),
                    new GeneralizedTime({
                        optional: true,
                        name: (names.date || EMPTY_STRING)
                    }),
                    OtherKeyAttribute.schema(names.other || {})
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$r);
            const asn1 = compareSchema(schema, schema, KEKIdentifier.schema({
                names: {
                    keyIdentifier: KEY_IDENTIFIER,
                    date: DATE,
                    other: {
                        names: {
                            blockName: OTHER
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.keyIdentifier = asn1.result.keyIdentifier;
            if (DATE in asn1.result)
                this.date = asn1.result.date;
            if (OTHER in asn1.result)
                this.other = new OtherKeyAttribute({ schema: asn1.result.other });
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(this.keyIdentifier);
            if (this.date) {
                outputArray.push(this.date);
            }
            if (this.other) {
                outputArray.push(this.other.toSchema());
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                keyIdentifier: this.keyIdentifier.toJSON()
            };
            if (this.date) {
                res.date = this.date;
            }
            if (this.other) {
                res.other = this.other.toJSON();
            }
            return res;
        }
    }
    KEKIdentifier.CLASS_NAME = "KEKIdentifier";

    const VERSION$a = "version";
    const KEK_ID = "kekid";
    const KEY_ENCRYPTION_ALGORITHM$1 = "keyEncryptionAlgorithm";
    const ENCRYPTED_KEY$1 = "encryptedKey";
    const PER_DEFINED_KEK = "preDefinedKEK";
    const CLEAR_PROPS$q = [
        VERSION$a,
        KEK_ID,
        KEY_ENCRYPTION_ALGORITHM$1,
        ENCRYPTED_KEY$1,
    ];
    class KEKRecipientInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$a, KEKRecipientInfo.defaultValues(VERSION$a));
            this.kekid = getParametersValue(parameters, KEK_ID, KEKRecipientInfo.defaultValues(KEK_ID));
            this.keyEncryptionAlgorithm = getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM$1, KEKRecipientInfo.defaultValues(KEY_ENCRYPTION_ALGORITHM$1));
            this.encryptedKey = getParametersValue(parameters, ENCRYPTED_KEY$1, KEKRecipientInfo.defaultValues(ENCRYPTED_KEY$1));
            this.preDefinedKEK = getParametersValue(parameters, PER_DEFINED_KEK, KEKRecipientInfo.defaultValues(PER_DEFINED_KEK));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$a:
                    return 0;
                case KEK_ID:
                    return new KEKIdentifier();
                case KEY_ENCRYPTION_ALGORITHM$1:
                    return new AlgorithmIdentifier();
                case ENCRYPTED_KEY$1:
                    return new OctetString();
                case PER_DEFINED_KEK:
                    return EMPTY_BUFFER;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case "KEKRecipientInfo":
                    return (memberValue === KEKRecipientInfo.defaultValues(VERSION$a));
                case KEK_ID:
                    return ((memberValue.compareWithDefault("keyIdentifier", memberValue.keyIdentifier)) &&
                        (("date" in memberValue) === false) &&
                        (("other" in memberValue) === false));
                case KEY_ENCRYPTION_ALGORITHM$1:
                    return ((memberValue.algorithmId === EMPTY_STRING) && (("algorithmParams" in memberValue) === false));
                case ENCRYPTED_KEY$1:
                    return (memberValue.isEqual(KEKRecipientInfo.defaultValues(ENCRYPTED_KEY$1)));
                case PER_DEFINED_KEK:
                    return (memberValue.byteLength === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.version || EMPTY_STRING) }),
                    KEKIdentifier.schema(names.kekid || {}),
                    AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
                    new OctetString({ name: (names.encryptedKey || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$q);
            const asn1 = compareSchema(schema, schema, KEKRecipientInfo.schema({
                names: {
                    version: VERSION$a,
                    kekid: {
                        names: {
                            blockName: KEK_ID
                        }
                    },
                    keyEncryptionAlgorithm: {
                        names: {
                            blockName: KEY_ENCRYPTION_ALGORITHM$1
                        }
                    },
                    encryptedKey: ENCRYPTED_KEY$1
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result.version.valueBlock.valueDec;
            this.kekid = new KEKIdentifier({ schema: asn1.result.kekid });
            this.keyEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.keyEncryptionAlgorithm });
            this.encryptedKey = asn1.result.encryptedKey;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    new Integer({ value: this.version }),
                    this.kekid.toSchema(),
                    this.keyEncryptionAlgorithm.toSchema(),
                    this.encryptedKey
                ]
            }));
        }
        toJSON() {
            return {
                version: this.version,
                kekid: this.kekid.toJSON(),
                keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
                encryptedKey: this.encryptedKey.toJSON(),
            };
        }
    }
    KEKRecipientInfo.CLASS_NAME = "KEKRecipientInfo";

    const VERSION$9 = "version";
    const KEY_DERIVATION_ALGORITHM = "keyDerivationAlgorithm";
    const KEY_ENCRYPTION_ALGORITHM = "keyEncryptionAlgorithm";
    const ENCRYPTED_KEY = "encryptedKey";
    const PASSWORD = "password";
    const CLEAR_PROPS$p = [
        VERSION$9,
        KEY_DERIVATION_ALGORITHM,
        KEY_ENCRYPTION_ALGORITHM,
        ENCRYPTED_KEY
    ];
    class PasswordRecipientinfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$9, PasswordRecipientinfo.defaultValues(VERSION$9));
            if (KEY_DERIVATION_ALGORITHM in parameters) {
                this.keyDerivationAlgorithm = getParametersValue(parameters, KEY_DERIVATION_ALGORITHM, PasswordRecipientinfo.defaultValues(KEY_DERIVATION_ALGORITHM));
            }
            this.keyEncryptionAlgorithm = getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM, PasswordRecipientinfo.defaultValues(KEY_ENCRYPTION_ALGORITHM));
            this.encryptedKey = getParametersValue(parameters, ENCRYPTED_KEY, PasswordRecipientinfo.defaultValues(ENCRYPTED_KEY));
            this.password = getParametersValue(parameters, PASSWORD, PasswordRecipientinfo.defaultValues(PASSWORD));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$9:
                    return (-1);
                case KEY_DERIVATION_ALGORITHM:
                    return new AlgorithmIdentifier();
                case KEY_ENCRYPTION_ALGORITHM:
                    return new AlgorithmIdentifier();
                case ENCRYPTED_KEY:
                    return new OctetString();
                case PASSWORD:
                    return EMPTY_BUFFER;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VERSION$9:
                    return (memberValue === (-1));
                case KEY_DERIVATION_ALGORITHM:
                case KEY_ENCRYPTION_ALGORITHM:
                    return ((memberValue.algorithmId === EMPTY_STRING) && (("algorithmParams" in memberValue) === false));
                case ENCRYPTED_KEY:
                    return (memberValue.isEqual(PasswordRecipientinfo.defaultValues(ENCRYPTED_KEY)));
                case PASSWORD:
                    return (memberValue.byteLength === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.version || EMPTY_STRING) }),
                    new Constructed({
                        name: (names.keyDerivationAlgorithm || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: AlgorithmIdentifier.schema().valueBlock.value
                    }),
                    AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
                    new OctetString({ name: (names.encryptedKey || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$p);
            const asn1 = compareSchema(schema, schema, PasswordRecipientinfo.schema({
                names: {
                    version: VERSION$9,
                    keyDerivationAlgorithm: KEY_DERIVATION_ALGORITHM,
                    keyEncryptionAlgorithm: {
                        names: {
                            blockName: KEY_ENCRYPTION_ALGORITHM
                        }
                    },
                    encryptedKey: ENCRYPTED_KEY
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result.version.valueBlock.valueDec;
            if (KEY_DERIVATION_ALGORITHM in asn1.result) {
                this.keyDerivationAlgorithm = new AlgorithmIdentifier({
                    schema: new Sequence({
                        value: asn1.result.keyDerivationAlgorithm.valueBlock.value
                    })
                });
            }
            this.keyEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.keyEncryptionAlgorithm });
            this.encryptedKey = asn1.result.encryptedKey;
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new Integer({ value: this.version }));
            if (this.keyDerivationAlgorithm) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: this.keyDerivationAlgorithm.toSchema().valueBlock.value
                }));
            }
            outputArray.push(this.keyEncryptionAlgorithm.toSchema());
            outputArray.push(this.encryptedKey);
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                version: this.version,
                keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
                encryptedKey: this.encryptedKey.toJSON(),
            };
            if (this.keyDerivationAlgorithm) {
                res.keyDerivationAlgorithm = this.keyDerivationAlgorithm.toJSON();
            }
            return res;
        }
    }
    PasswordRecipientinfo.CLASS_NAME = "PasswordRecipientInfo";

    const ORI_TYPE = "oriType";
    const ORI_VALUE = "oriValue";
    const CLEAR_PROPS$o = [
        ORI_TYPE,
        ORI_VALUE
    ];
    class OtherRecipientInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.oriType = getParametersValue(parameters, ORI_TYPE, OtherRecipientInfo.defaultValues(ORI_TYPE));
            this.oriValue = getParametersValue(parameters, ORI_VALUE, OtherRecipientInfo.defaultValues(ORI_VALUE));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case ORI_TYPE:
                    return EMPTY_STRING;
                case ORI_VALUE:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case ORI_TYPE:
                    return (memberValue === EMPTY_STRING);
                case ORI_VALUE:
                    return (Object.keys(memberValue).length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.oriType || EMPTY_STRING) }),
                    new Any({ name: (names.oriValue || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$o);
            const asn1 = compareSchema(schema, schema, OtherRecipientInfo.schema({
                names: {
                    oriType: ORI_TYPE,
                    oriValue: ORI_VALUE
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.oriType = asn1.result.oriType.valueBlock.toString();
            this.oriValue = asn1.result.oriValue;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    new ObjectIdentifier({ value: this.oriType }),
                    this.oriValue
                ]
            }));
        }
        toJSON() {
            const res = {
                oriType: this.oriType
            };
            if (!OtherRecipientInfo.compareWithDefault(ORI_VALUE, this.oriValue)) {
                res.oriValue = this.oriValue.toJSON();
            }
            return res;
        }
    }
    OtherRecipientInfo.CLASS_NAME = "OtherRecipientInfo";

    const VARIANT = "variant";
    const VALUE = "value";
    const CLEAR_PROPS$n = [
        "blockName"
    ];
    class RecipientInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.variant = getParametersValue(parameters, VARIANT, RecipientInfo.defaultValues(VARIANT));
            if (VALUE in parameters) {
                this.value = getParametersValue(parameters, VALUE, RecipientInfo.defaultValues(VALUE));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VARIANT:
                    return (-1);
                case VALUE:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VARIANT:
                    return (memberValue === RecipientInfo.defaultValues(memberName));
                case VALUE:
                    return (Object.keys(memberValue).length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Choice({
                value: [
                    KeyTransRecipientInfo.schema({
                        names: {
                            blockName: (names.blockName || EMPTY_STRING)
                        }
                    }),
                    new Constructed({
                        name: (names.blockName || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: KeyAgreeRecipientInfo.schema().valueBlock.value
                    }),
                    new Constructed({
                        name: (names.blockName || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 2
                        },
                        value: KEKRecipientInfo.schema().valueBlock.value
                    }),
                    new Constructed({
                        name: (names.blockName || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 3
                        },
                        value: PasswordRecipientinfo.schema().valueBlock.value
                    }),
                    new Constructed({
                        name: (names.blockName || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 4
                        },
                        value: OtherRecipientInfo.schema().valueBlock.value
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$n);
            const asn1 = compareSchema(schema, schema, RecipientInfo.schema({
                names: {
                    blockName: "blockName"
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (asn1.result.blockName.idBlock.tagClass === 1) {
                this.variant = 1;
                this.value = new KeyTransRecipientInfo({ schema: asn1.result.blockName });
            }
            else {
                const blockSequence = new Sequence({
                    value: asn1.result.blockName.valueBlock.value
                });
                switch (asn1.result.blockName.idBlock.tagNumber) {
                    case 1:
                        this.variant = 2;
                        this.value = new KeyAgreeRecipientInfo({ schema: blockSequence });
                        break;
                    case 2:
                        this.variant = 3;
                        this.value = new KEKRecipientInfo({ schema: blockSequence });
                        break;
                    case 3:
                        this.variant = 4;
                        this.value = new PasswordRecipientinfo({ schema: blockSequence });
                        break;
                    case 4:
                        this.variant = 5;
                        this.value = new OtherRecipientInfo({ schema: blockSequence });
                        break;
                    default:
                        throw new Error("Incorrect structure of RecipientInfo block");
                }
            }
        }
        toSchema() {
            ParameterError.assertEmpty(this.value, "value", "RecipientInfo");
            const _schema = this.value.toSchema();
            switch (this.variant) {
                case 1:
                    return _schema;
                case 2:
                case 3:
                case 4:
                    _schema.idBlock.tagClass = 3;
                    _schema.idBlock.tagNumber = (this.variant - 1);
                    return _schema;
                default:
                    return new Any();
            }
        }
        toJSON() {
            const res = {
                variant: this.variant
            };
            if (this.value && (this.variant >= 1) && (this.variant <= 4)) {
                res.value = this.value.toJSON();
            }
            return res;
        }
    }
    RecipientInfo.CLASS_NAME = "RecipientInfo";

    const HASH_ALGORITHM$2 = "hashAlgorithm";
    const MASK_GEN_ALGORITHM = "maskGenAlgorithm";
    const P_SOURCE_ALGORITHM = "pSourceAlgorithm";
    const CLEAR_PROPS$m = [
        HASH_ALGORITHM$2,
        MASK_GEN_ALGORITHM,
        P_SOURCE_ALGORITHM
    ];
    class RSAESOAEPParams extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM$2, RSAESOAEPParams.defaultValues(HASH_ALGORITHM$2));
            this.maskGenAlgorithm = getParametersValue(parameters, MASK_GEN_ALGORITHM, RSAESOAEPParams.defaultValues(MASK_GEN_ALGORITHM));
            this.pSourceAlgorithm = getParametersValue(parameters, P_SOURCE_ALGORITHM, RSAESOAEPParams.defaultValues(P_SOURCE_ALGORITHM));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case HASH_ALGORITHM$2:
                    return new AlgorithmIdentifier({
                        algorithmId: "1.3.14.3.2.26",
                        algorithmParams: new Null()
                    });
                case MASK_GEN_ALGORITHM:
                    return new AlgorithmIdentifier({
                        algorithmId: "1.2.840.113549.1.1.8",
                        algorithmParams: (new AlgorithmIdentifier({
                            algorithmId: "1.3.14.3.2.26",
                            algorithmParams: new Null()
                        })).toSchema()
                    });
                case P_SOURCE_ALGORITHM:
                    return new AlgorithmIdentifier({
                        algorithmId: "1.2.840.113549.1.1.9",
                        algorithmParams: new OctetString({ valueHex: (new Uint8Array([0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d, 0x32, 0x55, 0xbf, 0xef, 0x95, 0x60, 0x18, 0x90, 0xaf, 0xd8, 0x07, 0x09])).buffer })
                    });
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        optional: true,
                        value: [AlgorithmIdentifier.schema(names.hashAlgorithm || {})]
                    }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        optional: true,
                        value: [AlgorithmIdentifier.schema(names.maskGenAlgorithm || {})]
                    }),
                    new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 2
                        },
                        optional: true,
                        value: [AlgorithmIdentifier.schema(names.pSourceAlgorithm || {})]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$m);
            const asn1 = compareSchema(schema, schema, RSAESOAEPParams.schema({
                names: {
                    hashAlgorithm: {
                        names: {
                            blockName: HASH_ALGORITHM$2
                        }
                    },
                    maskGenAlgorithm: {
                        names: {
                            blockName: MASK_GEN_ALGORITHM
                        }
                    },
                    pSourceAlgorithm: {
                        names: {
                            blockName: P_SOURCE_ALGORITHM
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            if (HASH_ALGORITHM$2 in asn1.result)
                this.hashAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.hashAlgorithm });
            if (MASK_GEN_ALGORITHM in asn1.result)
                this.maskGenAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.maskGenAlgorithm });
            if (P_SOURCE_ALGORITHM in asn1.result)
                this.pSourceAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.pSourceAlgorithm });
        }
        toSchema() {
            const outputArray = [];
            if (!this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues(HASH_ALGORITHM$2))) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [this.hashAlgorithm.toSchema()]
                }));
            }
            if (!this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues(MASK_GEN_ALGORITHM))) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: [this.maskGenAlgorithm.toSchema()]
                }));
            }
            if (!this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues(P_SOURCE_ALGORITHM))) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 2
                    },
                    value: [this.pSourceAlgorithm.toSchema()]
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {};
            if (!this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues(HASH_ALGORITHM$2))) {
                res.hashAlgorithm = this.hashAlgorithm.toJSON();
            }
            if (!this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues(MASK_GEN_ALGORITHM))) {
                res.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();
            }
            if (!this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues(P_SOURCE_ALGORITHM))) {
                res.pSourceAlgorithm = this.pSourceAlgorithm.toJSON();
            }
            return res;
        }
    }
    RSAESOAEPParams.CLASS_NAME = "RSAESOAEPParams";

    const KEY_INFO = "keyInfo";
    const ENTITY_U_INFO = "entityUInfo";
    const SUPP_PUB_INFO = "suppPubInfo";
    const CLEAR_PROPS$l = [
        KEY_INFO,
        ENTITY_U_INFO,
        SUPP_PUB_INFO
    ];
    class ECCCMSSharedInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.keyInfo = getParametersValue(parameters, KEY_INFO, ECCCMSSharedInfo.defaultValues(KEY_INFO));
            if (ENTITY_U_INFO in parameters) {
                this.entityUInfo = getParametersValue(parameters, ENTITY_U_INFO, ECCCMSSharedInfo.defaultValues(ENTITY_U_INFO));
            }
            this.suppPubInfo = getParametersValue(parameters, SUPP_PUB_INFO, ECCCMSSharedInfo.defaultValues(SUPP_PUB_INFO));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case KEY_INFO:
                    return new AlgorithmIdentifier();
                case ENTITY_U_INFO:
                    return new OctetString();
                case SUPP_PUB_INFO:
                    return new OctetString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case KEY_INFO:
                case ENTITY_U_INFO:
                case SUPP_PUB_INFO:
                    return (memberValue.isEqual(ECCCMSSharedInfo.defaultValues(memberName)));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    AlgorithmIdentifier.schema(names.keyInfo || {}),
                    new Constructed({
                        name: (names.entityUInfo || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        optional: true,
                        value: [new OctetString()]
                    }),
                    new Constructed({
                        name: (names.suppPubInfo || EMPTY_STRING),
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 2
                        },
                        value: [new OctetString()]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$l);
            const asn1 = compareSchema(schema, schema, ECCCMSSharedInfo.schema({
                names: {
                    keyInfo: {
                        names: {
                            blockName: KEY_INFO
                        }
                    },
                    entityUInfo: ENTITY_U_INFO,
                    suppPubInfo: SUPP_PUB_INFO
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.keyInfo = new AlgorithmIdentifier({ schema: asn1.result.keyInfo });
            if (ENTITY_U_INFO in asn1.result)
                this.entityUInfo = asn1.result.entityUInfo.valueBlock.value[0];
            this.suppPubInfo = asn1.result.suppPubInfo.valueBlock.value[0];
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(this.keyInfo.toSchema());
            if (this.entityUInfo) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [this.entityUInfo]
                }));
            }
            outputArray.push(new Constructed({
                idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                },
                value: [this.suppPubInfo]
            }));
            return new Sequence({
                value: outputArray
            });
        }
        toJSON() {
            const res = {
                keyInfo: this.keyInfo.toJSON(),
                suppPubInfo: this.suppPubInfo.toJSON(),
            };
            if (this.entityUInfo) {
                res.entityUInfo = this.entityUInfo.toJSON();
            }
            return res;
        }
    }
    ECCCMSSharedInfo.CLASS_NAME = "ECCCMSSharedInfo";

    const VERSION$8 = "version";
    const ORIGINATOR_INFO = "originatorInfo";
    const RECIPIENT_INFOS = "recipientInfos";
    const ENCRYPTED_CONTENT_INFO = "encryptedContentInfo";
    const UNPROTECTED_ATTRS = "unprotectedAttrs";
    const CLEAR_PROPS$k = [
        VERSION$8,
        ORIGINATOR_INFO,
        RECIPIENT_INFOS,
        ENCRYPTED_CONTENT_INFO,
        UNPROTECTED_ATTRS
    ];
    const defaultEncryptionParams = {
        kdfAlgorithm: "SHA-512",
        kekEncryptionLength: 256
    };
    const curveLengthByName = {
        "P-256": 256,
        "P-384": 384,
        "P-521": 528
    };
    class EnvelopedData extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$8, EnvelopedData.defaultValues(VERSION$8));
            if (ORIGINATOR_INFO in parameters) {
                this.originatorInfo = getParametersValue(parameters, ORIGINATOR_INFO, EnvelopedData.defaultValues(ORIGINATOR_INFO));
            }
            this.recipientInfos = getParametersValue(parameters, RECIPIENT_INFOS, EnvelopedData.defaultValues(RECIPIENT_INFOS));
            this.encryptedContentInfo = getParametersValue(parameters, ENCRYPTED_CONTENT_INFO, EnvelopedData.defaultValues(ENCRYPTED_CONTENT_INFO));
            if (UNPROTECTED_ATTRS in parameters) {
                this.unprotectedAttrs = getParametersValue(parameters, UNPROTECTED_ATTRS, EnvelopedData.defaultValues(UNPROTECTED_ATTRS));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$8:
                    return 0;
                case ORIGINATOR_INFO:
                    return new OriginatorInfo();
                case RECIPIENT_INFOS:
                    return [];
                case ENCRYPTED_CONTENT_INFO:
                    return new EncryptedContentInfo();
                case UNPROTECTED_ATTRS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VERSION$8:
                    return (memberValue === EnvelopedData.defaultValues(memberName));
                case ORIGINATOR_INFO:
                    return ((memberValue.certs.certificates.length === 0) && (memberValue.crls.crls.length === 0));
                case RECIPIENT_INFOS:
                case UNPROTECTED_ATTRS:
                    return (memberValue.length === 0);
                case ENCRYPTED_CONTENT_INFO:
                    return ((EncryptedContentInfo.compareWithDefault("contentType", memberValue.contentType)) &&
                        (EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm", memberValue.contentEncryptionAlgorithm) &&
                            (EncryptedContentInfo.compareWithDefault("encryptedContent", memberValue.encryptedContent))));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.version || EMPTY_STRING) }),
                    new Constructed({
                        name: (names.originatorInfo || EMPTY_STRING),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: OriginatorInfo.schema().valueBlock.value
                    }),
                    new Set$1({
                        value: [
                            new Repeated({
                                name: (names.recipientInfos || EMPTY_STRING),
                                value: RecipientInfo.schema()
                            })
                        ]
                    }),
                    EncryptedContentInfo.schema(names.encryptedContentInfo || {}),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [
                            new Repeated({
                                name: (names.unprotectedAttrs || EMPTY_STRING),
                                value: Attribute.schema()
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$k);
            const asn1 = compareSchema(schema, schema, EnvelopedData.schema({
                names: {
                    version: VERSION$8,
                    originatorInfo: ORIGINATOR_INFO,
                    recipientInfos: RECIPIENT_INFOS,
                    encryptedContentInfo: {
                        names: {
                            blockName: ENCRYPTED_CONTENT_INFO
                        }
                    },
                    unprotectedAttrs: UNPROTECTED_ATTRS
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result.version.valueBlock.valueDec;
            if (ORIGINATOR_INFO in asn1.result) {
                this.originatorInfo = new OriginatorInfo({
                    schema: new Sequence({
                        value: asn1.result.originatorInfo.valueBlock.value
                    })
                });
            }
            this.recipientInfos = Array.from(asn1.result.recipientInfos, o => new RecipientInfo({ schema: o }));
            this.encryptedContentInfo = new EncryptedContentInfo({ schema: asn1.result.encryptedContentInfo });
            if (UNPROTECTED_ATTRS in asn1.result)
                this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, o => new Attribute({ schema: o }));
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new Integer({ value: this.version }));
            if (this.originatorInfo) {
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: this.originatorInfo.toSchema().valueBlock.value
                }));
            }
            outputArray.push(new Set$1({
                value: Array.from(this.recipientInfos, o => o.toSchema())
            }));
            outputArray.push(this.encryptedContentInfo.toSchema());
            if (this.unprotectedAttrs) {
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: Array.from(this.unprotectedAttrs, o => o.toSchema())
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                version: this.version,
                recipientInfos: Array.from(this.recipientInfos, o => o.toJSON()),
                encryptedContentInfo: this.encryptedContentInfo.toJSON(),
            };
            if (this.originatorInfo)
                res.originatorInfo = this.originatorInfo.toJSON();
            if (this.unprotectedAttrs)
                res.unprotectedAttrs = Array.from(this.unprotectedAttrs, o => o.toJSON());
            return res;
        }
        addRecipientByCertificate(certificate, parameters, variant, crypto = getCrypto(true)) {
            const encryptionParameters = Object.assign({ useOAEP: true, oaepHashAlgorithm: "SHA-512" }, defaultEncryptionParams, parameters || {});
            if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549") !== (-1))
                variant = 1;
            else {
                if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045") !== (-1))
                    variant = 2;
                else
                    throw new Error(`Unknown type of certificate's public key: ${certificate.subjectPublicKeyInfo.algorithm.algorithmId}`);
            }
            switch (variant) {
                case 1:
                    {
                        let algorithmId;
                        let algorithmParams;
                        if (encryptionParameters.useOAEP === true) {
                            algorithmId = crypto.getOIDByAlgorithm({
                                name: "RSA-OAEP"
                            }, true, "keyEncryptionAlgorithm");
                            const hashOID = crypto.getOIDByAlgorithm({
                                name: encryptionParameters.oaepHashAlgorithm
                            }, true, "RSAES-OAEP-params");
                            const hashAlgorithm = new AlgorithmIdentifier({
                                algorithmId: hashOID,
                                algorithmParams: new Null()
                            });
                            const rsaOAEPParams = new RSAESOAEPParams({
                                hashAlgorithm,
                                maskGenAlgorithm: new AlgorithmIdentifier({
                                    algorithmId: "1.2.840.113549.1.1.8",
                                    algorithmParams: hashAlgorithm.toSchema()
                                })
                            });
                            algorithmParams = rsaOAEPParams.toSchema();
                        }
                        else {
                            algorithmId = crypto.getOIDByAlgorithm({
                                name: "RSAES-PKCS1-v1_5"
                            });
                            if (algorithmId === EMPTY_STRING)
                                throw new Error("Can not find OID for RSAES-PKCS1-v1_5");
                            algorithmParams = new Null();
                        }
                        const keyInfo = new KeyTransRecipientInfo({
                            version: 0,
                            rid: new IssuerAndSerialNumber({
                                issuer: certificate.issuer,
                                serialNumber: certificate.serialNumber
                            }),
                            keyEncryptionAlgorithm: new AlgorithmIdentifier({
                                algorithmId,
                                algorithmParams
                            }),
                            recipientCertificate: certificate,
                        });
                        this.recipientInfos.push(new RecipientInfo({
                            variant: 1,
                            value: keyInfo
                        }));
                    }
                    break;
                case 2:
                    {
                        const recipientIdentifier = new KeyAgreeRecipientIdentifier({
                            variant: 1,
                            value: new IssuerAndSerialNumber({
                                issuer: certificate.issuer,
                                serialNumber: certificate.serialNumber
                            })
                        });
                        this._addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, { recipientCertificate: certificate }, crypto);
                    }
                    break;
                default:
                    throw new Error(`Unknown "variant" value: ${variant}`);
            }
            return true;
        }
        addRecipientByPreDefinedData(preDefinedData, parameters = {}, variant, crypto = getCrypto(true)) {
            ArgumentError.assert(preDefinedData, "preDefinedData", "ArrayBuffer");
            if (!preDefinedData.byteLength) {
                throw new Error("Pre-defined data could have zero length");
            }
            if (!parameters.keyIdentifier) {
                const keyIdentifierBuffer = new ArrayBuffer(16);
                const keyIdentifierView = new Uint8Array(keyIdentifierBuffer);
                crypto.getRandomValues(keyIdentifierView);
                parameters.keyIdentifier = keyIdentifierBuffer;
            }
            if (!parameters.hmacHashAlgorithm)
                parameters.hmacHashAlgorithm = "SHA-512";
            if (parameters.iterationCount === undefined) {
                parameters.iterationCount = 2048;
            }
            if (!parameters.keyEncryptionAlgorithm) {
                parameters.keyEncryptionAlgorithm = {
                    name: "AES-KW",
                    length: 256
                };
            }
            if (!parameters.keyEncryptionAlgorithmParams)
                parameters.keyEncryptionAlgorithmParams = new Null();
            switch (variant) {
                case 1:
                    {
                        const kekOID = crypto.getOIDByAlgorithm(parameters.keyEncryptionAlgorithm, true, "keyEncryptionAlgorithm");
                        const keyInfo = new KEKRecipientInfo({
                            version: 4,
                            kekid: new KEKIdentifier({
                                keyIdentifier: new OctetString({ valueHex: parameters.keyIdentifier })
                            }),
                            keyEncryptionAlgorithm: new AlgorithmIdentifier({
                                algorithmId: kekOID,
                                algorithmParams: parameters.keyEncryptionAlgorithmParams
                            }),
                            preDefinedKEK: preDefinedData
                        });
                        this.recipientInfos.push(new RecipientInfo({
                            variant: 3,
                            value: keyInfo
                        }));
                    }
                    break;
                case 2:
                    {
                        const pbkdf2OID = crypto.getOIDByAlgorithm({ name: "PBKDF2" }, true, "keyDerivationAlgorithm");
                        const saltBuffer = new ArrayBuffer(64);
                        const saltView = new Uint8Array(saltBuffer);
                        crypto.getRandomValues(saltView);
                        const hmacOID = crypto.getOIDByAlgorithm({
                            name: "HMAC",
                            hash: {
                                name: parameters.hmacHashAlgorithm
                            }
                        }, true, "hmacHashAlgorithm");
                        const pbkdf2Params = new PBKDF2Params({
                            salt: new OctetString({ valueHex: saltBuffer }),
                            iterationCount: parameters.iterationCount,
                            prf: new AlgorithmIdentifier({
                                algorithmId: hmacOID,
                                algorithmParams: new Null()
                            })
                        });
                        const kekOID = crypto.getOIDByAlgorithm(parameters.keyEncryptionAlgorithm, true, "keyEncryptionAlgorithm");
                        const keyInfo = new PasswordRecipientinfo({
                            version: 0,
                            keyDerivationAlgorithm: new AlgorithmIdentifier({
                                algorithmId: pbkdf2OID,
                                algorithmParams: pbkdf2Params.toSchema()
                            }),
                            keyEncryptionAlgorithm: new AlgorithmIdentifier({
                                algorithmId: kekOID,
                                algorithmParams: parameters.keyEncryptionAlgorithmParams
                            }),
                            password: preDefinedData
                        });
                        this.recipientInfos.push(new RecipientInfo({
                            variant: 4,
                            value: keyInfo
                        }));
                    }
                    break;
                default:
                    throw new Error(`Unknown value for "variant": ${variant}`);
            }
        }
        addRecipientByKeyIdentifier(key, keyId, parameters, crypto = getCrypto(true)) {
            const encryptionParameters = Object.assign({}, defaultEncryptionParams, parameters || {});
            const recipientIdentifier = new KeyAgreeRecipientIdentifier({
                variant: 2,
                value: new RecipientKeyIdentifier({
                    subjectKeyIdentifier: new OctetString({ valueHex: keyId }),
                })
            });
            this._addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, { recipientPublicKey: key }, crypto);
        }
        _addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, extraRecipientInfoParams, crypto = getCrypto(true)) {
            const encryptedKey = new RecipientEncryptedKey({
                rid: recipientIdentifier
            });
            const aesKWoid = crypto.getOIDByAlgorithm({
                name: "AES-KW",
                length: encryptionParameters.kekEncryptionLength
            }, true, "keyEncryptionAlgorithm");
            const aesKW = new AlgorithmIdentifier({
                algorithmId: aesKWoid,
            });
            const ecdhOID = crypto.getOIDByAlgorithm({
                name: "ECDH",
                kdf: encryptionParameters.kdfAlgorithm
            }, true, "KeyAgreeRecipientInfo");
            const ukmBuffer = new ArrayBuffer(64);
            const ukmView = new Uint8Array(ukmBuffer);
            crypto.getRandomValues(ukmView);
            const recipientInfoParams = {
                version: 3,
                ukm: new OctetString({ valueHex: ukmBuffer }),
                keyEncryptionAlgorithm: new AlgorithmIdentifier({
                    algorithmId: ecdhOID,
                    algorithmParams: aesKW.toSchema()
                }),
                recipientEncryptedKeys: new RecipientEncryptedKeys({
                    encryptedKeys: [encryptedKey]
                })
            };
            const keyInfo = new KeyAgreeRecipientInfo(Object.assign(recipientInfoParams, extraRecipientInfoParams));
            this.recipientInfos.push(new RecipientInfo({
                variant: 2,
                value: keyInfo
            }));
        }
        async encrypt(contentEncryptionAlgorithm, contentToEncrypt, crypto = getCrypto(true)) {
            const ivBuffer = new ArrayBuffer(16);
            const ivView = new Uint8Array(ivBuffer);
            crypto.getRandomValues(ivView);
            const contentView = new Uint8Array(contentToEncrypt);
            const contentEncryptionOID = crypto.getOIDByAlgorithm(contentEncryptionAlgorithm, true, "contentEncryptionAlgorithm");
            const sessionKey = await crypto.generateKey(contentEncryptionAlgorithm, true, ["encrypt"]);
            const encryptedContent = await crypto.encrypt({
                name: contentEncryptionAlgorithm.name,
                iv: ivView
            }, sessionKey, contentView);
            const exportedSessionKey = await crypto.exportKey("raw", sessionKey);
            this.version = 2;
            this.encryptedContentInfo = new EncryptedContentInfo({
                contentType: "1.2.840.113549.1.7.1",
                contentEncryptionAlgorithm: new AlgorithmIdentifier({
                    algorithmId: contentEncryptionOID,
                    algorithmParams: new OctetString({ valueHex: ivBuffer })
                }),
                encryptedContent: new OctetString({ valueHex: encryptedContent })
            });
            const SubKeyAgreeRecipientInfo = async (index) => {
                const recipientInfo = this.recipientInfos[index].value;
                let recipientCurve;
                let recipientPublicKey;
                if (recipientInfo.recipientPublicKey) {
                    recipientCurve = recipientInfo.recipientPublicKey.algorithm.namedCurve;
                    recipientPublicKey = recipientInfo.recipientPublicKey;
                }
                else if (recipientInfo.recipientCertificate) {
                    const curveObject = recipientInfo.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;
                    if (curveObject.constructor.blockName() !== ObjectIdentifier.blockName())
                        throw new Error(`Incorrect "recipientCertificate" for index ${index}`);
                    const curveOID = curveObject.valueBlock.toString();
                    switch (curveOID) {
                        case "1.2.840.10045.3.1.7":
                            recipientCurve = "P-256";
                            break;
                        case "1.3.132.0.34":
                            recipientCurve = "P-384";
                            break;
                        case "1.3.132.0.35":
                            recipientCurve = "P-521";
                            break;
                        default:
                            throw new Error(`Incorrect curve OID for index ${index}`);
                    }
                    recipientPublicKey = await recipientInfo.recipientCertificate.getPublicKey({
                        algorithm: {
                            algorithm: {
                                name: "ECDH",
                                namedCurve: recipientCurve
                            },
                            usages: []
                        }
                    }, crypto);
                }
                else {
                    throw new Error("Unsupported RecipientInfo");
                }
                const recipientCurveLength = curveLengthByName[recipientCurve];
                const ecdhKeys = await crypto.generateKey({ name: "ECDH", namedCurve: recipientCurve }, true, ["deriveBits"]);
                const exportedECDHPublicKey = await crypto.exportKey("spki", ecdhKeys.publicKey);
                const derivedBits = await crypto.deriveBits({
                    name: "ECDH",
                    public: recipientPublicKey
                }, ecdhKeys.privateKey, recipientCurveLength);
                const aesKWAlgorithm = new AlgorithmIdentifier({ schema: recipientInfo.keyEncryptionAlgorithm.algorithmParams });
                const kwAlgorithm = crypto.getAlgorithmByOID(aesKWAlgorithm.algorithmId, true, "aesKWAlgorithm");
                let kwLength = kwAlgorithm.length;
                const kwLengthBuffer = new ArrayBuffer(4);
                const kwLengthView = new Uint8Array(kwLengthBuffer);
                for (let j = 3; j >= 0; j--) {
                    kwLengthView[j] = kwLength;
                    kwLength >>= 8;
                }
                const eccInfo = new ECCCMSSharedInfo({
                    keyInfo: new AlgorithmIdentifier({
                        algorithmId: aesKWAlgorithm.algorithmId
                    }),
                    entityUInfo: recipientInfo.ukm,
                    suppPubInfo: new OctetString({ valueHex: kwLengthBuffer })
                });
                const encodedInfo = eccInfo.toSchema().toBER(false);
                const ecdhAlgorithm = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "ecdhAlgorithm");
                const derivedKeyRaw = await kdf(ecdhAlgorithm.kdf, derivedBits, kwAlgorithm.length, encodedInfo, crypto);
                const awsKW = await crypto.importKey("raw", derivedKeyRaw, { name: "AES-KW" }, true, ["wrapKey"]);
                const wrappedKey = await crypto.wrapKey("raw", sessionKey, awsKW, { name: "AES-KW" });
                const originator = new OriginatorIdentifierOrKey();
                originator.variant = 3;
                originator.value = OriginatorPublicKey.fromBER(exportedECDHPublicKey);
                recipientInfo.originator = originator;
                recipientInfo.recipientEncryptedKeys.encryptedKeys[0].encryptedKey = new OctetString({ valueHex: wrappedKey });
                return { ecdhPrivateKey: ecdhKeys.privateKey };
            };
            const SubKeyTransRecipientInfo = async (index) => {
                const recipientInfo = this.recipientInfos[index].value;
                const algorithmParameters = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "keyEncryptionAlgorithm");
                if (algorithmParameters.name === "RSA-OAEP") {
                    const schema = recipientInfo.keyEncryptionAlgorithm.algorithmParams;
                    const rsaOAEPParams = new RSAESOAEPParams({ schema });
                    algorithmParameters.hash = crypto.getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);
                    if (("name" in algorithmParameters.hash) === false)
                        throw new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
                }
                try {
                    const publicKey = await recipientInfo.recipientCertificate.getPublicKey({
                        algorithm: {
                            algorithm: algorithmParameters,
                            usages: ["encrypt", "wrapKey"]
                        }
                    }, crypto);
                    const encryptedKey = await crypto.encrypt(publicKey.algorithm, publicKey, exportedSessionKey);
                    recipientInfo.encryptedKey = new OctetString({ valueHex: encryptedKey });
                }
                catch {
                }
            };
            const SubKEKRecipientInfo = async (index) => {
                const recipientInfo = this.recipientInfos[index].value;
                const kekAlgorithm = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "kekAlgorithm");
                const kekKey = await crypto.importKey("raw", new Uint8Array(recipientInfo.preDefinedKEK), kekAlgorithm, true, ["wrapKey"]);
                const wrappedKey = await crypto.wrapKey("raw", sessionKey, kekKey, kekAlgorithm);
                recipientInfo.encryptedKey = new OctetString({ valueHex: wrappedKey });
            };
            const SubPasswordRecipientinfo = async (index) => {
                const recipientInfo = this.recipientInfos[index].value;
                let pbkdf2Params;
                if (!recipientInfo.keyDerivationAlgorithm)
                    throw new Error("Please append encoded \"keyDerivationAlgorithm\"");
                if (!recipientInfo.keyDerivationAlgorithm.algorithmParams)
                    throw new Error("Incorrectly encoded \"keyDerivationAlgorithm\"");
                try {
                    pbkdf2Params = new PBKDF2Params({ schema: recipientInfo.keyDerivationAlgorithm.algorithmParams });
                }
                catch (ex) {
                    throw new Error("Incorrectly encoded \"keyDerivationAlgorithm\"");
                }
                const passwordView = new Uint8Array(recipientInfo.password);
                const derivationKey = await crypto.importKey("raw", passwordView, "PBKDF2", false, ["deriveKey"]);
                const kekAlgorithm = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "kekAlgorithm");
                let hmacHashAlgorithm = "SHA-1";
                if (pbkdf2Params.prf) {
                    const prfAlgorithm = crypto.getAlgorithmByOID(pbkdf2Params.prf.algorithmId, true, "prfAlgorithm");
                    hmacHashAlgorithm = prfAlgorithm.hash.name;
                }
                const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
                const iterations = pbkdf2Params.iterationCount;
                const derivedKey = await crypto.deriveKey({
                    name: "PBKDF2",
                    hash: {
                        name: hmacHashAlgorithm
                    },
                    salt: saltView,
                    iterations
                }, derivationKey, kekAlgorithm, true, ["wrapKey"]);
                const wrappedKey = await crypto.wrapKey("raw", sessionKey, derivedKey, kekAlgorithm);
                recipientInfo.encryptedKey = new OctetString({ valueHex: wrappedKey });
            };
            const res = [];
            for (let i = 0; i < this.recipientInfos.length; i++) {
                switch (this.recipientInfos[i].variant) {
                    case 1:
                        res.push(await SubKeyTransRecipientInfo(i));
                        break;
                    case 2:
                        res.push(await SubKeyAgreeRecipientInfo(i));
                        break;
                    case 3:
                        res.push(await SubKEKRecipientInfo(i));
                        break;
                    case 4:
                        res.push(await SubPasswordRecipientinfo(i));
                        break;
                    default:
                        throw new Error(`Unknown recipient type in array with index ${i}`);
                }
            }
            return res;
        }
        async decrypt(recipientIndex, parameters, crypto = getCrypto(true)) {
            const decryptionParameters = parameters || {};
            if ((recipientIndex + 1) > this.recipientInfos.length) {
                throw new Error(`Maximum value for "index" is: ${this.recipientInfos.length - 1}`);
            }
            const SubKeyAgreeRecipientInfo = async (index) => {
                const recipientInfo = this.recipientInfos[index].value;
                let curveOID;
                let recipientCurve;
                let recipientCurveLength;
                const originator = recipientInfo.originator;
                if (decryptionParameters.recipientCertificate) {
                    const curveObject = decryptionParameters.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;
                    if (curveObject.constructor.blockName() !== ObjectIdentifier.blockName()) {
                        throw new Error(`Incorrect "recipientCertificate" for index ${index}`);
                    }
                    curveOID = curveObject.valueBlock.toString();
                }
                else if (originator.value.algorithm.algorithmParams) {
                    const curveObject = originator.value.algorithm.algorithmParams;
                    if (curveObject.constructor.blockName() !== ObjectIdentifier.blockName()) {
                        throw new Error(`Incorrect originator for index ${index}`);
                    }
                    curveOID = curveObject.valueBlock.toString();
                }
                else {
                    throw new Error("Parameter \"recipientCertificate\" is mandatory for \"KeyAgreeRecipientInfo\" if algorithm params are missing from originator");
                }
                if (!decryptionParameters.recipientPrivateKey)
                    throw new Error("Parameter \"recipientPrivateKey\" is mandatory for \"KeyAgreeRecipientInfo\"");
                switch (curveOID) {
                    case "1.2.840.10045.3.1.7":
                        recipientCurve = "P-256";
                        recipientCurveLength = 256;
                        break;
                    case "1.3.132.0.34":
                        recipientCurve = "P-384";
                        recipientCurveLength = 384;
                        break;
                    case "1.3.132.0.35":
                        recipientCurve = "P-521";
                        recipientCurveLength = 528;
                        break;
                    default:
                        throw new Error(`Incorrect curve OID for index ${index}`);
                }
                const ecdhPrivateKey = await crypto.importKey("pkcs8", decryptionParameters.recipientPrivateKey, {
                    name: "ECDH",
                    namedCurve: recipientCurve
                }, true, ["deriveBits"]);
                if (("algorithmParams" in originator.value.algorithm) === false)
                    originator.value.algorithm.algorithmParams = new ObjectIdentifier({ value: curveOID });
                const buffer = originator.value.toSchema().toBER(false);
                const ecdhPublicKey = await crypto.importKey("spki", buffer, {
                    name: "ECDH",
                    namedCurve: recipientCurve
                }, true, []);
                const sharedSecret = await crypto.deriveBits({
                    name: "ECDH",
                    public: ecdhPublicKey
                }, ecdhPrivateKey, recipientCurveLength);
                async function applyKDF(includeAlgorithmParams) {
                    includeAlgorithmParams = includeAlgorithmParams || false;
                    const aesKWAlgorithm = new AlgorithmIdentifier({ schema: recipientInfo.keyEncryptionAlgorithm.algorithmParams });
                    const kwAlgorithm = crypto.getAlgorithmByOID(aesKWAlgorithm.algorithmId, true, "kwAlgorithm");
                    let kwLength = kwAlgorithm.length;
                    const kwLengthBuffer = new ArrayBuffer(4);
                    const kwLengthView = new Uint8Array(kwLengthBuffer);
                    for (let j = 3; j >= 0; j--) {
                        kwLengthView[j] = kwLength;
                        kwLength >>= 8;
                    }
                    const keyInfoAlgorithm = {
                        algorithmId: aesKWAlgorithm.algorithmId
                    };
                    if (includeAlgorithmParams) {
                        keyInfoAlgorithm.algorithmParams = new Null();
                    }
                    const eccInfo = new ECCCMSSharedInfo({
                        keyInfo: new AlgorithmIdentifier(keyInfoAlgorithm),
                        entityUInfo: recipientInfo.ukm,
                        suppPubInfo: new OctetString({ valueHex: kwLengthBuffer })
                    });
                    const encodedInfo = eccInfo.toSchema().toBER(false);
                    const ecdhAlgorithm = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "ecdhAlgorithm");
                    if (!ecdhAlgorithm.name) {
                        throw new Error(`Incorrect OID for key encryption algorithm: ${recipientInfo.keyEncryptionAlgorithm.algorithmId}`);
                    }
                    return kdf(ecdhAlgorithm.kdf, sharedSecret, kwAlgorithm.length, encodedInfo, crypto);
                }
                const kdfResult = await applyKDF();
                const importAesKwKey = async (kdfResult) => {
                    return crypto.importKey("raw", kdfResult, { name: "AES-KW" }, true, ["unwrapKey"]);
                };
                const aesKwKey = await importAesKwKey(kdfResult);
                const unwrapSessionKey = async (aesKwKey) => {
                    const algorithmId = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
                    const contentEncryptionAlgorithm = crypto.getAlgorithmByOID(algorithmId, true, "contentEncryptionAlgorithm");
                    return crypto.unwrapKey("raw", recipientInfo.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHexView, aesKwKey, { name: "AES-KW" }, contentEncryptionAlgorithm, true, ["decrypt"]);
                };
                try {
                    return await unwrapSessionKey(aesKwKey);
                }
                catch {
                    const kdfResult = await applyKDF(true);
                    const aesKwKey = await importAesKwKey(kdfResult);
                    return unwrapSessionKey(aesKwKey);
                }
            };
            const SubKeyTransRecipientInfo = async (index) => {
                const recipientInfo = this.recipientInfos[index].value;
                if (!decryptionParameters.recipientPrivateKey) {
                    throw new Error("Parameter \"recipientPrivateKey\" is mandatory for \"KeyTransRecipientInfo\"");
                }
                const algorithmParameters = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "keyEncryptionAlgorithm");
                if (algorithmParameters.name === "RSA-OAEP") {
                    const schema = recipientInfo.keyEncryptionAlgorithm.algorithmParams;
                    const rsaOAEPParams = new RSAESOAEPParams({ schema });
                    algorithmParameters.hash = crypto.getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);
                    if (("name" in algorithmParameters.hash) === false)
                        throw new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
                }
                const privateKey = await crypto.importKey("pkcs8", decryptionParameters.recipientPrivateKey, algorithmParameters, true, ["decrypt"]);
                const sessionKey = await crypto.decrypt(privateKey.algorithm, privateKey, recipientInfo.encryptedKey.valueBlock.valueHexView);
                const algorithmId = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
                const contentEncryptionAlgorithm = crypto.getAlgorithmByOID(algorithmId, true, "contentEncryptionAlgorithm");
                if (("name" in contentEncryptionAlgorithm) === false)
                    throw new Error(`Incorrect "contentEncryptionAlgorithm": ${algorithmId}`);
                return crypto.importKey("raw", sessionKey, contentEncryptionAlgorithm, true, ["decrypt"]);
            };
            const SubKEKRecipientInfo = async (index) => {
                const recipientInfo = this.recipientInfos[index].value;
                if (!decryptionParameters.preDefinedData)
                    throw new Error("Parameter \"preDefinedData\" is mandatory for \"KEKRecipientInfo\"");
                const kekAlgorithm = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "kekAlgorithm");
                const importedKey = await crypto.importKey("raw", decryptionParameters.preDefinedData, kekAlgorithm, true, ["unwrapKey"]);
                const algorithmId = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
                const contentEncryptionAlgorithm = crypto.getAlgorithmByOID(algorithmId, true, "contentEncryptionAlgorithm");
                if (!contentEncryptionAlgorithm.name) {
                    throw new Error(`Incorrect "contentEncryptionAlgorithm": ${algorithmId}`);
                }
                return crypto.unwrapKey("raw", recipientInfo.encryptedKey.valueBlock.valueHexView, importedKey, kekAlgorithm, contentEncryptionAlgorithm, true, ["decrypt"]);
            };
            const SubPasswordRecipientinfo = async (index) => {
                const recipientInfo = this.recipientInfos[index].value;
                let pbkdf2Params;
                if (!decryptionParameters.preDefinedData) {
                    throw new Error("Parameter \"preDefinedData\" is mandatory for \"KEKRecipientInfo\"");
                }
                if (!recipientInfo.keyDerivationAlgorithm) {
                    throw new Error("Please append encoded \"keyDerivationAlgorithm\"");
                }
                if (!recipientInfo.keyDerivationAlgorithm.algorithmParams) {
                    throw new Error("Incorrectly encoded \"keyDerivationAlgorithm\"");
                }
                try {
                    pbkdf2Params = new PBKDF2Params({ schema: recipientInfo.keyDerivationAlgorithm.algorithmParams });
                }
                catch (ex) {
                    throw new Error("Incorrectly encoded \"keyDerivationAlgorithm\"");
                }
                const pbkdf2Key = await crypto.importKey("raw", decryptionParameters.preDefinedData, "PBKDF2", false, ["deriveKey"]);
                const kekAlgorithm = crypto.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "keyEncryptionAlgorithm");
                const hmacHashAlgorithm = pbkdf2Params.prf
                    ? crypto.getAlgorithmByOID(pbkdf2Params.prf.algorithmId, true, "prfAlgorithm").hash.name
                    : "SHA-1";
                const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
                const iterations = pbkdf2Params.iterationCount;
                const kekKey = await crypto.deriveKey({
                    name: "PBKDF2",
                    hash: {
                        name: hmacHashAlgorithm
                    },
                    salt: saltView,
                    iterations
                }, pbkdf2Key, kekAlgorithm, true, ["unwrapKey"]);
                const algorithmId = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
                const contentEncryptionAlgorithm = crypto.getAlgorithmByOID(algorithmId, true, "contentEncryptionAlgorithm");
                return crypto.unwrapKey("raw", recipientInfo.encryptedKey.valueBlock.valueHexView, kekKey, kekAlgorithm, contentEncryptionAlgorithm, true, ["decrypt"]);
            };
            let unwrappedKey;
            switch (this.recipientInfos[recipientIndex].variant) {
                case 1:
                    unwrappedKey = await SubKeyTransRecipientInfo(recipientIndex);
                    break;
                case 2:
                    unwrappedKey = await SubKeyAgreeRecipientInfo(recipientIndex);
                    break;
                case 3:
                    unwrappedKey = await SubKEKRecipientInfo(recipientIndex);
                    break;
                case 4:
                    unwrappedKey = await SubPasswordRecipientinfo(recipientIndex);
                    break;
                default:
                    throw new Error(`Unknown recipient type in array with index ${recipientIndex}`);
            }
            const algorithmId = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
            const contentEncryptionAlgorithm = crypto.getAlgorithmByOID(algorithmId, true, "contentEncryptionAlgorithm");
            const ivBuffer = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex;
            const ivView = new Uint8Array(ivBuffer);
            if (!this.encryptedContentInfo.encryptedContent) {
                throw new Error("Required property `encryptedContent` is empty");
            }
            const dataBuffer = this.encryptedContentInfo.getEncryptedContent();
            return crypto.decrypt({
                name: contentEncryptionAlgorithm.name,
                iv: ivView
            }, unwrappedKey, dataBuffer);
        }
    }
    EnvelopedData.CLASS_NAME = "EnvelopedData";

    const SAFE_CONTENTS = "safeContents";
    const PARSED_VALUE$1 = "parsedValue";
    const CONTENT_INFOS = "contentInfos";
    class AuthenticatedSafe extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.safeContents = getParametersValue(parameters, SAFE_CONTENTS, AuthenticatedSafe.defaultValues(SAFE_CONTENTS));
            if (PARSED_VALUE$1 in parameters) {
                this.parsedValue = getParametersValue(parameters, PARSED_VALUE$1, AuthenticatedSafe.defaultValues(PARSED_VALUE$1));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case SAFE_CONTENTS:
                    return [];
                case PARSED_VALUE$1:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case SAFE_CONTENTS:
                    return (memberValue.length === 0);
                case PARSED_VALUE$1:
                    return ((memberValue instanceof Object) && (Object.keys(memberValue).length === 0));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Repeated({
                        name: (names.contentInfos || EMPTY_STRING),
                        value: ContentInfo.schema()
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, [
                CONTENT_INFOS
            ]);
            const asn1 = compareSchema(schema, schema, AuthenticatedSafe.schema({
                names: {
                    contentInfos: CONTENT_INFOS
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.safeContents = Array.from(asn1.result.contentInfos, element => new ContentInfo({ schema: element }));
        }
        toSchema() {
            return (new Sequence({
                value: Array.from(this.safeContents, o => o.toSchema())
            }));
        }
        toJSON() {
            return {
                safeContents: Array.from(this.safeContents, o => o.toJSON())
            };
        }
        async parseInternalValues(parameters, crypto = getCrypto(true)) {
            ParameterError.assert(parameters, SAFE_CONTENTS);
            ArgumentError.assert(parameters.safeContents, SAFE_CONTENTS, "Array");
            if (parameters.safeContents.length !== this.safeContents.length) {
                throw new ArgumentError("Length of \"parameters.safeContents\" must be equal to \"this.safeContents.length\"");
            }
            this.parsedValue = {
                safeContents: [],
            };
            for (const [index, content] of this.safeContents.entries()) {
                const safeContent = parameters.safeContents[index];
                const errorTarget = `parameters.safeContents[${index}]`;
                switch (content.contentType) {
                    case id_ContentType_Data:
                        {
                            ArgumentError.assert(content.content, "this.safeContents[j].content", OctetString);
                            const authSafeContent = content.content.getValue();
                            this.parsedValue.safeContents.push({
                                privacyMode: 0,
                                value: SafeContents.fromBER(authSafeContent)
                            });
                        }
                        break;
                    case id_ContentType_EnvelopedData:
                        {
                            const cmsEnveloped = new EnvelopedData({ schema: content.content });
                            ParameterError.assert(errorTarget, safeContent, "recipientCertificate", "recipientKey");
                            const envelopedData = safeContent;
                            const recipientCertificate = envelopedData.recipientCertificate;
                            const recipientKey = envelopedData.recipientKey;
                            const decrypted = await cmsEnveloped.decrypt(0, {
                                recipientCertificate,
                                recipientPrivateKey: recipientKey
                            }, crypto);
                            this.parsedValue.safeContents.push({
                                privacyMode: 2,
                                value: SafeContents.fromBER(decrypted),
                            });
                        }
                        break;
                    case id_ContentType_EncryptedData:
                        {
                            const cmsEncrypted = new EncryptedData({ schema: content.content });
                            ParameterError.assert(errorTarget, safeContent, "password");
                            const password = safeContent.password;
                            const decrypted = await cmsEncrypted.decrypt({
                                password
                            }, crypto);
                            this.parsedValue.safeContents.push({
                                privacyMode: 1,
                                value: SafeContents.fromBER(decrypted),
                            });
                        }
                        break;
                    default:
                        throw new Error(`Unknown "contentType" for AuthenticatedSafe: " ${content.contentType}`);
                }
            }
        }
        async makeInternalValues(parameters, crypto = getCrypto(true)) {
            if (!(this.parsedValue)) {
                throw new Error("Please run \"parseValues\" first or add \"parsedValue\" manually");
            }
            ArgumentError.assert(this.parsedValue, "this.parsedValue", "object");
            ArgumentError.assert(this.parsedValue.safeContents, "this.parsedValue.safeContents", "Array");
            ArgumentError.assert(parameters, "parameters", "object");
            ParameterError.assert(parameters, "safeContents");
            ArgumentError.assert(parameters.safeContents, "parameters.safeContents", "Array");
            if (parameters.safeContents.length !== this.parsedValue.safeContents.length) {
                throw new ArgumentError("Length of \"parameters.safeContents\" must be equal to \"this.parsedValue.safeContents\"");
            }
            this.safeContents = [];
            for (const [index, content] of this.parsedValue.safeContents.entries()) {
                ParameterError.assert("content", content, "privacyMode", "value");
                ArgumentError.assert(content.value, "content.value", SafeContents);
                switch (content.privacyMode) {
                    case 0:
                        {
                            const contentBuffer = content.value.toSchema().toBER(false);
                            this.safeContents.push(new ContentInfo({
                                contentType: "1.2.840.113549.1.7.1",
                                content: new OctetString({ valueHex: contentBuffer })
                            }));
                        }
                        break;
                    case 1:
                        {
                            const cmsEncrypted = new EncryptedData();
                            const currentParameters = parameters.safeContents[index];
                            currentParameters.contentToEncrypt = content.value.toSchema().toBER(false);
                            await cmsEncrypted.encrypt(currentParameters);
                            this.safeContents.push(new ContentInfo({
                                contentType: "1.2.840.113549.1.7.6",
                                content: cmsEncrypted.toSchema()
                            }));
                        }
                        break;
                    case 2:
                        {
                            const cmsEnveloped = new EnvelopedData();
                            const contentToEncrypt = content.value.toSchema().toBER(false);
                            const safeContent = parameters.safeContents[index];
                            ParameterError.assert(`parameters.safeContents[${index}]`, safeContent, "encryptingCertificate", "encryptionAlgorithm");
                            switch (true) {
                                case (safeContent.encryptionAlgorithm.name.toLowerCase() === "aes-cbc"):
                                case (safeContent.encryptionAlgorithm.name.toLowerCase() === "aes-gcm"):
                                    break;
                                default:
                                    throw new Error(`Incorrect parameter "encryptionAlgorithm" in "parameters.safeContents[i]": ${safeContent.encryptionAlgorithm}`);
                            }
                            switch (true) {
                                case (safeContent.encryptionAlgorithm.length === 128):
                                case (safeContent.encryptionAlgorithm.length === 192):
                                case (safeContent.encryptionAlgorithm.length === 256):
                                    break;
                                default:
                                    throw new Error(`Incorrect parameter "encryptionAlgorithm.length" in "parameters.safeContents[i]": ${safeContent.encryptionAlgorithm.length}`);
                            }
                            const encryptionAlgorithm = safeContent.encryptionAlgorithm;
                            cmsEnveloped.addRecipientByCertificate(safeContent.encryptingCertificate, {}, undefined, crypto);
                            await cmsEnveloped.encrypt(encryptionAlgorithm, contentToEncrypt, crypto);
                            this.safeContents.push(new ContentInfo({
                                contentType: "1.2.840.113549.1.7.3",
                                content: cmsEnveloped.toSchema()
                            }));
                        }
                        break;
                    default:
                        throw new Error(`Incorrect value for "content.privacyMode": ${content.privacyMode}`);
                }
            }
            return this;
        }
    }
    AuthenticatedSafe.CLASS_NAME = "AuthenticatedSafe";

    const HASH_ALGORITHM$1 = "hashAlgorithm";
    const ISSUER_NAME_HASH = "issuerNameHash";
    const ISSUER_KEY_HASH = "issuerKeyHash";
    const SERIAL_NUMBER$1 = "serialNumber";
    const CLEAR_PROPS$j = [
        HASH_ALGORITHM$1,
        ISSUER_NAME_HASH,
        ISSUER_KEY_HASH,
        SERIAL_NUMBER$1,
    ];
    class CertID extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM$1, CertID.defaultValues(HASH_ALGORITHM$1));
            this.issuerNameHash = getParametersValue(parameters, ISSUER_NAME_HASH, CertID.defaultValues(ISSUER_NAME_HASH));
            this.issuerKeyHash = getParametersValue(parameters, ISSUER_KEY_HASH, CertID.defaultValues(ISSUER_KEY_HASH));
            this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER$1, CertID.defaultValues(SERIAL_NUMBER$1));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static async create(certificate, parameters, crypto = getCrypto(true)) {
            const certID = new CertID();
            await certID.createForCertificate(certificate, parameters, crypto);
            return certID;
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case HASH_ALGORITHM$1:
                    return new AlgorithmIdentifier();
                case ISSUER_NAME_HASH:
                case ISSUER_KEY_HASH:
                    return new OctetString();
                case SERIAL_NUMBER$1:
                    return new Integer();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case HASH_ALGORITHM$1:
                    return ((memberValue.algorithmId === EMPTY_STRING) && (("algorithmParams" in memberValue) === false));
                case ISSUER_NAME_HASH:
                case ISSUER_KEY_HASH:
                case SERIAL_NUMBER$1:
                    return (memberValue.isEqual(CertID.defaultValues(SERIAL_NUMBER$1)));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    AlgorithmIdentifier.schema(names.hashAlgorithmObject || {
                        names: {
                            blockName: (names.hashAlgorithm || EMPTY_STRING)
                        }
                    }),
                    new OctetString({ name: (names.issuerNameHash || EMPTY_STRING) }),
                    new OctetString({ name: (names.issuerKeyHash || EMPTY_STRING) }),
                    new Integer({ name: (names.serialNumber || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$j);
            const asn1 = compareSchema(schema, schema, CertID.schema({
                names: {
                    hashAlgorithm: HASH_ALGORITHM$1,
                    issuerNameHash: ISSUER_NAME_HASH,
                    issuerKeyHash: ISSUER_KEY_HASH,
                    serialNumber: SERIAL_NUMBER$1
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.hashAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.hashAlgorithm });
            this.issuerNameHash = asn1.result.issuerNameHash;
            this.issuerKeyHash = asn1.result.issuerKeyHash;
            this.serialNumber = asn1.result.serialNumber;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    this.hashAlgorithm.toSchema(),
                    this.issuerNameHash,
                    this.issuerKeyHash,
                    this.serialNumber
                ]
            }));
        }
        toJSON() {
            return {
                hashAlgorithm: this.hashAlgorithm.toJSON(),
                issuerNameHash: this.issuerNameHash.toJSON(),
                issuerKeyHash: this.issuerKeyHash.toJSON(),
                serialNumber: this.serialNumber.toJSON(),
            };
        }
        isEqual(certificateID) {
            if (this.hashAlgorithm.algorithmId !== certificateID.hashAlgorithm.algorithmId) {
                return false;
            }
            if (!BufferSourceConverter_1.isEqual(this.issuerNameHash.valueBlock.valueHexView, certificateID.issuerNameHash.valueBlock.valueHexView)) {
                return false;
            }
            if (!BufferSourceConverter_1.isEqual(this.issuerKeyHash.valueBlock.valueHexView, certificateID.issuerKeyHash.valueBlock.valueHexView)) {
                return false;
            }
            if (!this.serialNumber.isEqual(certificateID.serialNumber)) {
                return false;
            }
            return true;
        }
        async createForCertificate(certificate, parameters, crypto = getCrypto(true)) {
            ParameterError.assert(parameters, HASH_ALGORITHM$1, "issuerCertificate");
            const hashOID = crypto.getOIDByAlgorithm({ name: parameters.hashAlgorithm }, true, "hashAlgorithm");
            this.hashAlgorithm = new AlgorithmIdentifier({
                algorithmId: hashOID,
                algorithmParams: new Null()
            });
            const issuerCertificate = parameters.issuerCertificate;
            this.serialNumber = certificate.serialNumber;
            const hashIssuerName = await crypto.digest({ name: parameters.hashAlgorithm }, issuerCertificate.subject.toSchema().toBER(false));
            this.issuerNameHash = new OctetString({ valueHex: hashIssuerName });
            const issuerKeyBuffer = issuerCertificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView;
            const hashIssuerKey = await crypto.digest({ name: parameters.hashAlgorithm }, issuerKeyBuffer);
            this.issuerKeyHash = new OctetString({ valueHex: hashIssuerKey });
        }
    }
    CertID.CLASS_NAME = "CertID";

    const CERT_ID = "certID";
    const CERT_STATUS = "certStatus";
    const THIS_UPDATE = "thisUpdate";
    const NEXT_UPDATE = "nextUpdate";
    const SINGLE_EXTENSIONS = "singleExtensions";
    const CLEAR_PROPS$i = [
        CERT_ID,
        CERT_STATUS,
        THIS_UPDATE,
        NEXT_UPDATE,
        SINGLE_EXTENSIONS,
    ];
    class SingleResponse extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.certID = getParametersValue(parameters, CERT_ID, SingleResponse.defaultValues(CERT_ID));
            this.certStatus = getParametersValue(parameters, CERT_STATUS, SingleResponse.defaultValues(CERT_STATUS));
            this.thisUpdate = getParametersValue(parameters, THIS_UPDATE, SingleResponse.defaultValues(THIS_UPDATE));
            if (NEXT_UPDATE in parameters) {
                this.nextUpdate = getParametersValue(parameters, NEXT_UPDATE, SingleResponse.defaultValues(NEXT_UPDATE));
            }
            if (SINGLE_EXTENSIONS in parameters) {
                this.singleExtensions = getParametersValue(parameters, SINGLE_EXTENSIONS, SingleResponse.defaultValues(SINGLE_EXTENSIONS));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case CERT_ID:
                    return new CertID();
                case CERT_STATUS:
                    return {};
                case THIS_UPDATE:
                case NEXT_UPDATE:
                    return new Date(0, 0, 0);
                case SINGLE_EXTENSIONS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case CERT_ID:
                    return ((CertID.compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm)) &&
                        (CertID.compareWithDefault("issuerNameHash", memberValue.issuerNameHash)) &&
                        (CertID.compareWithDefault("issuerKeyHash", memberValue.issuerKeyHash)) &&
                        (CertID.compareWithDefault("serialNumber", memberValue.serialNumber)));
                case CERT_STATUS:
                    return (Object.keys(memberValue).length === 0);
                case THIS_UPDATE:
                case NEXT_UPDATE:
                    return (memberValue === SingleResponse.defaultValues(memberName));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    CertID.schema(names.certID || {}),
                    new Choice({
                        value: [
                            new Primitive({
                                name: (names.certStatus || EMPTY_STRING),
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 0
                                },
                            }),
                            new Constructed({
                                name: (names.certStatus || EMPTY_STRING),
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 1
                                },
                                value: [
                                    new GeneralizedTime(),
                                    new Constructed({
                                        optional: true,
                                        idBlock: {
                                            tagClass: 3,
                                            tagNumber: 0
                                        },
                                        value: [new Enumerated()]
                                    })
                                ]
                            }),
                            new Primitive({
                                name: (names.certStatus || EMPTY_STRING),
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 2
                                },
                                lenBlock: { length: 1 }
                            })
                        ]
                    }),
                    new GeneralizedTime({ name: (names.thisUpdate || EMPTY_STRING) }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [new GeneralizedTime({ name: (names.nextUpdate || EMPTY_STRING) })]
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [Extensions.schema(names.singleExtensions || {})]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$i);
            const asn1 = compareSchema(schema, schema, SingleResponse.schema({
                names: {
                    certID: {
                        names: {
                            blockName: CERT_ID
                        }
                    },
                    certStatus: CERT_STATUS,
                    thisUpdate: THIS_UPDATE,
                    nextUpdate: NEXT_UPDATE,
                    singleExtensions: {
                        names: {
                            blockName: SINGLE_EXTENSIONS
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.certID = new CertID({ schema: asn1.result.certID });
            this.certStatus = asn1.result.certStatus;
            this.thisUpdate = asn1.result.thisUpdate.toDate();
            if (NEXT_UPDATE in asn1.result)
                this.nextUpdate = asn1.result.nextUpdate.toDate();
            if (SINGLE_EXTENSIONS in asn1.result)
                this.singleExtensions = Array.from(asn1.result.singleExtensions.valueBlock.value, element => new Extension({ schema: element }));
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(this.certID.toSchema());
            outputArray.push(this.certStatus);
            outputArray.push(new GeneralizedTime({ valueDate: this.thisUpdate }));
            if (this.nextUpdate) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [new GeneralizedTime({ valueDate: this.nextUpdate })]
                }));
            }
            if (this.singleExtensions) {
                outputArray.push(new Sequence({
                    value: Array.from(this.singleExtensions, o => o.toSchema())
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                certID: this.certID.toJSON(),
                certStatus: this.certStatus.toJSON(),
                thisUpdate: this.thisUpdate
            };
            if (this.nextUpdate) {
                res.nextUpdate = this.nextUpdate;
            }
            if (this.singleExtensions) {
                res.singleExtensions = Array.from(this.singleExtensions, o => o.toJSON());
            }
            return res;
        }
    }
    SingleResponse.CLASS_NAME = "SingleResponse";

    const TBS$2 = "tbs";
    const VERSION$7 = "version";
    const RESPONDER_ID = "responderID";
    const PRODUCED_AT = "producedAt";
    const RESPONSES = "responses";
    const RESPONSE_EXTENSIONS = "responseExtensions";
    const RESPONSE_DATA = "ResponseData";
    const RESPONSE_DATA_VERSION = `${RESPONSE_DATA}.${VERSION$7}`;
    const RESPONSE_DATA_RESPONDER_ID = `${RESPONSE_DATA}.${RESPONDER_ID}`;
    const RESPONSE_DATA_PRODUCED_AT = `${RESPONSE_DATA}.${PRODUCED_AT}`;
    const RESPONSE_DATA_RESPONSES = `${RESPONSE_DATA}.${RESPONSES}`;
    const RESPONSE_DATA_RESPONSE_EXTENSIONS = `${RESPONSE_DATA}.${RESPONSE_EXTENSIONS}`;
    const CLEAR_PROPS$h = [
        RESPONSE_DATA,
        RESPONSE_DATA_VERSION,
        RESPONSE_DATA_RESPONDER_ID,
        RESPONSE_DATA_PRODUCED_AT,
        RESPONSE_DATA_RESPONSES,
        RESPONSE_DATA_RESPONSE_EXTENSIONS
    ];
    class ResponseData extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.tbsView = new Uint8Array(getParametersValue(parameters, TBS$2, ResponseData.defaultValues(TBS$2)));
            if (VERSION$7 in parameters) {
                this.version = getParametersValue(parameters, VERSION$7, ResponseData.defaultValues(VERSION$7));
            }
            this.responderID = getParametersValue(parameters, RESPONDER_ID, ResponseData.defaultValues(RESPONDER_ID));
            this.producedAt = getParametersValue(parameters, PRODUCED_AT, ResponseData.defaultValues(PRODUCED_AT));
            this.responses = getParametersValue(parameters, RESPONSES, ResponseData.defaultValues(RESPONSES));
            if (RESPONSE_EXTENSIONS in parameters) {
                this.responseExtensions = getParametersValue(parameters, RESPONSE_EXTENSIONS, ResponseData.defaultValues(RESPONSE_EXTENSIONS));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        get tbs() {
            return BufferSourceConverter_1.toArrayBuffer(this.tbsView);
        }
        set tbs(value) {
            this.tbsView = new Uint8Array(value);
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$7:
                    return 0;
                case TBS$2:
                    return EMPTY_BUFFER;
                case RESPONDER_ID:
                    return {};
                case PRODUCED_AT:
                    return new Date(0, 0, 0);
                case RESPONSES:
                case RESPONSE_EXTENSIONS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case TBS$2:
                    return (memberValue.byteLength === 0);
                case RESPONDER_ID:
                    return (Object.keys(memberValue).length === 0);
                case PRODUCED_AT:
                    return (memberValue === ResponseData.defaultValues(memberName));
                case RESPONSES:
                case RESPONSE_EXTENSIONS:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || RESPONSE_DATA),
                value: [
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [new Integer({ name: (names.version || RESPONSE_DATA_VERSION) })]
                    }),
                    new Choice({
                        value: [
                            new Constructed({
                                name: (names.responderID || RESPONSE_DATA_RESPONDER_ID),
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 1
                                },
                                value: [RelativeDistinguishedNames.schema(names.ResponseDataByName || {
                                        names: {
                                            blockName: "ResponseData.byName"
                                        }
                                    })]
                            }),
                            new Constructed({
                                name: (names.responderID || RESPONSE_DATA_RESPONDER_ID),
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: 2
                                },
                                value: [new OctetString({ name: (names.ResponseDataByKey || "ResponseData.byKey") })]
                            })
                        ]
                    }),
                    new GeneralizedTime({ name: (names.producedAt || RESPONSE_DATA_PRODUCED_AT) }),
                    new Sequence({
                        value: [
                            new Repeated({
                                name: RESPONSE_DATA_RESPONSES,
                                value: SingleResponse.schema(names.response || {})
                            })
                        ]
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [Extensions.schema(names.extensions || {
                                names: {
                                    blockName: RESPONSE_DATA_RESPONSE_EXTENSIONS
                                }
                            })]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$h);
            const asn1 = compareSchema(schema, schema, ResponseData.schema());
            AsnError.assertSchema(asn1, this.className);
            this.tbsView = asn1.result.ResponseData.valueBeforeDecodeView;
            if (RESPONSE_DATA_VERSION in asn1.result)
                this.version = asn1.result[RESPONSE_DATA_VERSION].valueBlock.valueDec;
            if (asn1.result[RESPONSE_DATA_RESPONDER_ID].idBlock.tagNumber === 1)
                this.responderID = new RelativeDistinguishedNames({ schema: asn1.result[RESPONSE_DATA_RESPONDER_ID].valueBlock.value[0] });
            else
                this.responderID = asn1.result[RESPONSE_DATA_RESPONDER_ID].valueBlock.value[0];
            this.producedAt = asn1.result[RESPONSE_DATA_PRODUCED_AT].toDate();
            this.responses = Array.from(asn1.result[RESPONSE_DATA_RESPONSES], element => new SingleResponse({ schema: element }));
            if (RESPONSE_DATA_RESPONSE_EXTENSIONS in asn1.result)
                this.responseExtensions = Array.from(asn1.result[RESPONSE_DATA_RESPONSE_EXTENSIONS].valueBlock.value, element => new Extension({ schema: element }));
        }
        toSchema(encodeFlag = false) {
            let tbsSchema;
            if (encodeFlag === false) {
                if (!this.tbsView.byteLength) {
                    return ResponseData.schema();
                }
                const asn1 = fromBER(this.tbsView);
                AsnError.assert(asn1, "TBS Response Data");
                tbsSchema = asn1.result;
            }
            else {
                const outputArray = [];
                if (VERSION$7 in this) {
                    outputArray.push(new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [new Integer({ value: this.version })]
                    }));
                }
                if (this.responderID instanceof RelativeDistinguishedNames) {
                    outputArray.push(new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [this.responderID.toSchema()]
                    }));
                }
                else {
                    outputArray.push(new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 2
                        },
                        value: [this.responderID]
                    }));
                }
                outputArray.push(new GeneralizedTime({ valueDate: this.producedAt }));
                outputArray.push(new Sequence({
                    value: Array.from(this.responses, o => o.toSchema())
                }));
                if (this.responseExtensions) {
                    outputArray.push(new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [new Sequence({
                                value: Array.from(this.responseExtensions, o => o.toSchema())
                            })]
                    }));
                }
                tbsSchema = new Sequence({
                    value: outputArray
                });
            }
            return tbsSchema;
        }
        toJSON() {
            const res = {};
            if (VERSION$7 in this) {
                res.version = this.version;
            }
            if (this.responderID) {
                res.responderID = this.responderID;
            }
            if (this.producedAt) {
                res.producedAt = this.producedAt;
            }
            if (this.responses) {
                res.responses = Array.from(this.responses, o => o.toJSON());
            }
            if (this.responseExtensions) {
                res.responseExtensions = Array.from(this.responseExtensions, o => o.toJSON());
            }
            return res;
        }
    }
    ResponseData.CLASS_NAME = "ResponseData";

    const TRUSTED_CERTS = "trustedCerts";
    const CERTS$2 = "certs";
    const CRLS$1 = "crls";
    const OCSPS$1 = "ocsps";
    const CHECK_DATE = "checkDate";
    const FIND_ORIGIN = "findOrigin";
    const FIND_ISSUER = "findIssuer";
    class CertificateChainValidationEngine {
        constructor(parameters = {}) {
            this.trustedCerts = getParametersValue(parameters, TRUSTED_CERTS, this.defaultValues(TRUSTED_CERTS));
            this.certs = getParametersValue(parameters, CERTS$2, this.defaultValues(CERTS$2));
            this.crls = getParametersValue(parameters, CRLS$1, this.defaultValues(CRLS$1));
            this.ocsps = getParametersValue(parameters, OCSPS$1, this.defaultValues(OCSPS$1));
            this.checkDate = getParametersValue(parameters, CHECK_DATE, this.defaultValues(CHECK_DATE));
            this.findOrigin = getParametersValue(parameters, FIND_ORIGIN, this.defaultValues(FIND_ORIGIN));
            this.findIssuer = getParametersValue(parameters, FIND_ISSUER, this.defaultValues(FIND_ISSUER));
        }
        static defaultFindOrigin(certificate, validationEngine) {
            if (certificate.tbsView.byteLength === 0) {
                certificate.tbsView = new Uint8Array(certificate.encodeTBS().toBER());
            }
            for (const localCert of validationEngine.certs) {
                if (localCert.tbsView.byteLength === 0) {
                    localCert.tbsView = new Uint8Array(localCert.encodeTBS().toBER());
                }
                if (BufferSourceConverter_1.isEqual(certificate.tbsView, localCert.tbsView))
                    return "Intermediate Certificates";
            }
            for (const trustedCert of validationEngine.trustedCerts) {
                if (trustedCert.tbsView.byteLength === 0)
                    trustedCert.tbsView = new Uint8Array(trustedCert.encodeTBS().toBER());
                if (BufferSourceConverter_1.isEqual(certificate.tbsView, trustedCert.tbsView))
                    return "Trusted Certificates";
            }
            return "Unknown";
        }
        async defaultFindIssuer(certificate, validationEngine, crypto = getCrypto(true)) {
            const result = [];
            let keyIdentifier = null;
            let authorityCertIssuer = null;
            let authorityCertSerialNumber = null;
            if (certificate.subject.isEqual(certificate.issuer)) {
                try {
                    const verificationResult = await certificate.verify(undefined, crypto);
                    if (verificationResult) {
                        return [certificate];
                    }
                }
                catch (ex) {
                }
            }
            if (certificate.extensions) {
                for (const extension of certificate.extensions) {
                    if (extension.extnID === id_AuthorityKeyIdentifier && extension.parsedValue instanceof AuthorityKeyIdentifier) {
                        if (extension.parsedValue.keyIdentifier) {
                            keyIdentifier = extension.parsedValue.keyIdentifier;
                        }
                        else {
                            if (extension.parsedValue.authorityCertIssuer) {
                                authorityCertIssuer = extension.parsedValue.authorityCertIssuer;
                            }
                            if (extension.parsedValue.authorityCertSerialNumber) {
                                authorityCertSerialNumber = extension.parsedValue.authorityCertSerialNumber;
                            }
                        }
                        break;
                    }
                }
            }
            function checkCertificate(possibleIssuer) {
                if (keyIdentifier !== null) {
                    if (possibleIssuer.extensions) {
                        let extensionFound = false;
                        for (const extension of possibleIssuer.extensions) {
                            if (extension.extnID === id_SubjectKeyIdentifier && extension.parsedValue) {
                                extensionFound = true;
                                if (BufferSourceConverter_1.isEqual(extension.parsedValue.valueBlock.valueHex, keyIdentifier.valueBlock.valueHexView)) {
                                    result.push(possibleIssuer);
                                }
                                break;
                            }
                        }
                        if (extensionFound) {
                            return;
                        }
                    }
                }
                let authorityCertSerialNumberEqual = false;
                if (authorityCertSerialNumber !== null)
                    authorityCertSerialNumberEqual = possibleIssuer.serialNumber.isEqual(authorityCertSerialNumber);
                if (authorityCertIssuer !== null) {
                    if (possibleIssuer.subject.isEqual(authorityCertIssuer)) {
                        if (authorityCertSerialNumberEqual)
                            result.push(possibleIssuer);
                    }
                }
                else {
                    if (certificate.issuer.isEqual(possibleIssuer.subject))
                        result.push(possibleIssuer);
                }
            }
            for (const trustedCert of validationEngine.trustedCerts) {
                checkCertificate(trustedCert);
            }
            for (const intermediateCert of validationEngine.certs) {
                checkCertificate(intermediateCert);
            }
            for (let i = 0; i < result.length; i++) {
                try {
                    const verificationResult = await certificate.verify(result[i], crypto);
                    if (verificationResult === false)
                        result.splice(i, 1);
                }
                catch (ex) {
                    result.splice(i, 1);
                }
            }
            return result;
        }
        defaultValues(memberName) {
            switch (memberName) {
                case TRUSTED_CERTS:
                    return [];
                case CERTS$2:
                    return [];
                case CRLS$1:
                    return [];
                case OCSPS$1:
                    return [];
                case CHECK_DATE:
                    return new Date();
                case FIND_ORIGIN:
                    return CertificateChainValidationEngine.defaultFindOrigin;
                case FIND_ISSUER:
                    return this.defaultFindIssuer;
                default:
                    throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${memberName}`);
            }
        }
        async sort(passedWhenNotRevValues = false, crypto = getCrypto(true)) {
            const localCerts = [];
            const buildPath = async (certificate) => {
                const result = [];
                function checkUnique(array) {
                    let unique = true;
                    for (let i = 0; i < array.length; i++) {
                        for (let j = 0; j < array.length; j++) {
                            if (j === i)
                                continue;
                            if (array[i] === array[j]) {
                                unique = false;
                                break;
                            }
                        }
                        if (!unique)
                            break;
                    }
                    return unique;
                }
                const findIssuerResult = await this.findIssuer(certificate, this);
                if (findIssuerResult.length === 0) {
                    throw new Error("No valid certificate paths found");
                }
                for (let i = 0; i < findIssuerResult.length; i++) {
                    if (BufferSourceConverter_1.isEqual(findIssuerResult[i].tbsView, certificate.tbsView)) {
                        result.push([findIssuerResult[i]]);
                        continue;
                    }
                    const buildPathResult = await buildPath(findIssuerResult[i]);
                    for (let j = 0; j < buildPathResult.length; j++) {
                        const copy = buildPathResult[j].slice();
                        copy.splice(0, 0, findIssuerResult[i]);
                        if (checkUnique(copy))
                            result.push(copy);
                        else
                            result.push(buildPathResult[j]);
                    }
                }
                return result;
            };
            const findCRL = async (certificate) => {
                const issuerCertificates = [];
                const crls = [];
                const crlsAndCertificates = [];
                issuerCertificates.push(...localCerts.filter(element => certificate.issuer.isEqual(element.subject)));
                if (issuerCertificates.length === 0) {
                    return {
                        status: 1,
                        statusMessage: "No certificate's issuers"
                    };
                }
                crls.push(...this.crls.filter(o => o.issuer.isEqual(certificate.issuer)));
                if (crls.length === 0) {
                    return {
                        status: 2,
                        statusMessage: "No CRLs for specific certificate issuer"
                    };
                }
                for (let i = 0; i < crls.length; i++) {
                    const crl = crls[i];
                    if (crl.nextUpdate && crl.nextUpdate.value < this.checkDate) {
                        continue;
                    }
                    for (let j = 0; j < issuerCertificates.length; j++) {
                        try {
                            const result = await crls[i].verify({ issuerCertificate: issuerCertificates[j] }, crypto);
                            if (result) {
                                crlsAndCertificates.push({
                                    crl: crls[i],
                                    certificate: issuerCertificates[j]
                                });
                                break;
                            }
                        }
                        catch (ex) {
                        }
                    }
                }
                if (crlsAndCertificates.length) {
                    return {
                        status: 0,
                        statusMessage: EMPTY_STRING,
                        result: crlsAndCertificates
                    };
                }
                return {
                    status: 3,
                    statusMessage: "No valid CRLs found"
                };
            };
            const findOCSP = async (certificate, issuerCertificate) => {
                const hashAlgorithm = crypto.getAlgorithmByOID(certificate.signatureAlgorithm.algorithmId);
                if (!hashAlgorithm.name) {
                    return 1;
                }
                if (!hashAlgorithm.hash) {
                    return 1;
                }
                for (let i = 0; i < this.ocsps.length; i++) {
                    const ocsp = this.ocsps[i];
                    const result = await ocsp.getCertificateStatus(certificate, issuerCertificate, crypto);
                    if (result.isForCertificate) {
                        if (result.status === 0)
                            return 0;
                        return 1;
                    }
                }
                return 2;
            };
            async function checkForCA(certificate, needToCheckCRL = false) {
                let isCA = false;
                let mustBeCA = false;
                let keyUsagePresent = false;
                let cRLSign = false;
                if (certificate.extensions) {
                    for (let j = 0; j < certificate.extensions.length; j++) {
                        const extension = certificate.extensions[j];
                        if (extension.critical && !extension.parsedValue) {
                            return {
                                result: false,
                                resultCode: 6,
                                resultMessage: `Unable to parse critical certificate extension: ${extension.extnID}`
                            };
                        }
                        if (extension.extnID === id_KeyUsage) {
                            keyUsagePresent = true;
                            const view = new Uint8Array(extension.parsedValue.valueBlock.valueHex);
                            if ((view[0] & 0x04) === 0x04)
                                mustBeCA = true;
                            if ((view[0] & 0x02) === 0x02)
                                cRLSign = true;
                        }
                        if (extension.extnID === id_BasicConstraints) {
                            if ("cA" in extension.parsedValue) {
                                if (extension.parsedValue.cA === true)
                                    isCA = true;
                            }
                        }
                    }
                    if ((mustBeCA === true) && (isCA === false)) {
                        return {
                            result: false,
                            resultCode: 3,
                            resultMessage: "Unable to build certificate chain - using \"keyCertSign\" flag set without BasicConstraints"
                        };
                    }
                    if ((keyUsagePresent === true) && (isCA === true) && (mustBeCA === false)) {
                        return {
                            result: false,
                            resultCode: 4,
                            resultMessage: "Unable to build certificate chain - \"keyCertSign\" flag was not set"
                        };
                    }
                    if ((isCA === true) && (keyUsagePresent === true) && ((needToCheckCRL) && (cRLSign === false))) {
                        return {
                            result: false,
                            resultCode: 5,
                            resultMessage: "Unable to build certificate chain - intermediate certificate must have \"cRLSign\" key usage flag"
                        };
                    }
                }
                if (isCA === false) {
                    return {
                        result: false,
                        resultCode: 7,
                        resultMessage: "Unable to build certificate chain - more than one possible end-user certificate"
                    };
                }
                return {
                    result: true,
                    resultCode: 0,
                    resultMessage: EMPTY_STRING
                };
            }
            const basicCheck = async (path, checkDate) => {
                for (let i = 0; i < path.length; i++) {
                    if ((path[i].notBefore.value > checkDate) ||
                        (path[i].notAfter.value < checkDate)) {
                        return {
                            result: false,
                            resultCode: 8,
                            resultMessage: "The certificate is either not yet valid or expired"
                        };
                    }
                }
                if (path.length < 2) {
                    return {
                        result: false,
                        resultCode: 9,
                        resultMessage: "Too short certificate path"
                    };
                }
                for (let i = (path.length - 2); i >= 0; i--) {
                    if (path[i].issuer.isEqual(path[i].subject) === false) {
                        if (path[i].issuer.isEqual(path[i + 1].subject) === false) {
                            return {
                                result: false,
                                resultCode: 10,
                                resultMessage: "Incorrect name chaining"
                            };
                        }
                    }
                }
                if ((this.crls.length !== 0) || (this.ocsps.length !== 0)) {
                    for (let i = 0; i < (path.length - 1); i++) {
                        let ocspResult = 2;
                        let crlResult = {
                            status: 0,
                            statusMessage: EMPTY_STRING
                        };
                        if (this.ocsps.length !== 0) {
                            ocspResult = await findOCSP(path[i], path[i + 1]);
                            switch (ocspResult) {
                                case 0:
                                    continue;
                                case 1:
                                    return {
                                        result: false,
                                        resultCode: 12,
                                        resultMessage: "One of certificates was revoked via OCSP response"
                                    };
                            }
                        }
                        if (this.crls.length !== 0) {
                            crlResult = await findCRL(path[i]);
                            if (crlResult.status === 0 && crlResult.result) {
                                for (let j = 0; j < crlResult.result.length; j++) {
                                    const isCertificateRevoked = crlResult.result[j].crl.isCertificateRevoked(path[i]);
                                    if (isCertificateRevoked) {
                                        return {
                                            result: false,
                                            resultCode: 12,
                                            resultMessage: "One of certificates had been revoked"
                                        };
                                    }
                                    const isCertificateCA = await checkForCA(crlResult.result[j].certificate, true);
                                    if (isCertificateCA.result === false) {
                                        return {
                                            result: false,
                                            resultCode: 13,
                                            resultMessage: "CRL issuer certificate is not a CA certificate or does not have crlSign flag"
                                        };
                                    }
                                }
                            }
                            else {
                                if (passedWhenNotRevValues === false) {
                                    throw {
                                        result: false,
                                        resultCode: 11,
                                        resultMessage: `No revocation values found for one of certificates: ${crlResult.statusMessage}`
                                    };
                                }
                            }
                        }
                        else {
                            if (ocspResult === 2) {
                                return {
                                    result: false,
                                    resultCode: 11,
                                    resultMessage: "No revocation values found for one of certificates"
                                };
                            }
                        }
                        if ((ocspResult === 2) && (crlResult.status === 2) && passedWhenNotRevValues) {
                            const issuerCertificate = path[i + 1];
                            let extensionFound = false;
                            if (issuerCertificate.extensions) {
                                for (const extension of issuerCertificate.extensions) {
                                    switch (extension.extnID) {
                                        case id_CRLDistributionPoints:
                                        case id_FreshestCRL:
                                        case id_AuthorityInfoAccess:
                                            extensionFound = true;
                                            break;
                                    }
                                }
                            }
                            if (extensionFound) {
                                throw {
                                    result: false,
                                    resultCode: 11,
                                    resultMessage: `No revocation values found for one of certificates: ${crlResult.statusMessage}`
                                };
                            }
                        }
                    }
                }
                for (const [i, cert] of path.entries()) {
                    if (!i) {
                        continue;
                    }
                    const result = await checkForCA(cert);
                    if (!result.result) {
                        return {
                            result: false,
                            resultCode: 14,
                            resultMessage: "One of intermediate certificates is not a CA certificate"
                        };
                    }
                }
                return {
                    result: true
                };
            };
            localCerts.push(...this.trustedCerts);
            localCerts.push(...this.certs);
            for (let i = 0; i < localCerts.length; i++) {
                for (let j = 0; j < localCerts.length; j++) {
                    if (i === j)
                        continue;
                    if (BufferSourceConverter_1.isEqual(localCerts[i].tbsView, localCerts[j].tbsView)) {
                        localCerts.splice(j, 1);
                        i = 0;
                        break;
                    }
                }
            }
            let result;
            const certificatePath = [localCerts[localCerts.length - 1]];
            result = await buildPath(localCerts[localCerts.length - 1]);
            if (result.length === 0) {
                throw {
                    result: false,
                    resultCode: 60,
                    resultMessage: "Unable to find certificate path"
                };
            }
            for (let i = 0; i < result.length; i++) {
                let found = false;
                for (let j = 0; j < (result[i]).length; j++) {
                    const certificate = (result[i])[j];
                    for (let k = 0; k < this.trustedCerts.length; k++) {
                        if (BufferSourceConverter_1.isEqual(certificate.tbsView, this.trustedCerts[k].tbsView)) {
                            found = true;
                            break;
                        }
                    }
                    if (found)
                        break;
                }
                if (!found) {
                    result.splice(i, 1);
                    i = 0;
                }
            }
            if (result.length === 0) {
                throw {
                    result: false,
                    resultCode: 97,
                    resultMessage: "No valid certificate paths found"
                };
            }
            let shortestLength = result[0].length;
            let shortestIndex = 0;
            for (let i = 0; i < result.length; i++) {
                if (result[i].length < shortestLength) {
                    shortestLength = result[i].length;
                    shortestIndex = i;
                }
            }
            for (let i = 0; i < result[shortestIndex].length; i++)
                certificatePath.push((result[shortestIndex])[i]);
            result = await basicCheck(certificatePath, this.checkDate);
            if (result.result === false)
                throw result;
            return certificatePath;
        }
        async verify(parameters = {}, crypto = getCrypto(true)) {
            function compareDNSName(name, constraint) {
                const namePrepared = stringPrep(name);
                const constraintPrepared = stringPrep(constraint);
                const nameSplitted = namePrepared.split(".");
                const constraintSplitted = constraintPrepared.split(".");
                const nameLen = nameSplitted.length;
                const constrLen = constraintSplitted.length;
                if ((nameLen === 0) || (constrLen === 0) || (nameLen < constrLen)) {
                    return false;
                }
                for (let i = 0; i < nameLen; i++) {
                    if (nameSplitted[i].length === 0) {
                        return false;
                    }
                }
                for (let i = 0; i < constrLen; i++) {
                    if (constraintSplitted[i].length === 0) {
                        if (i === 0) {
                            if (constrLen === 1) {
                                return false;
                            }
                            continue;
                        }
                        return false;
                    }
                }
                for (let i = 0; i < constrLen; i++) {
                    if (constraintSplitted[constrLen - 1 - i].length === 0) {
                        continue;
                    }
                    if (nameSplitted[nameLen - 1 - i].localeCompare(constraintSplitted[constrLen - 1 - i]) !== 0) {
                        return false;
                    }
                }
                return true;
            }
            function compareRFC822Name(name, constraint) {
                const namePrepared = stringPrep(name);
                const constraintPrepared = stringPrep(constraint);
                const nameSplitted = namePrepared.split("@");
                const constraintSplitted = constraintPrepared.split("@");
                if ((nameSplitted.length === 0) || (constraintSplitted.length === 0) || (nameSplitted.length < constraintSplitted.length))
                    return false;
                if (constraintSplitted.length === 1) {
                    const result = compareDNSName(nameSplitted[1], constraintSplitted[0]);
                    if (result) {
                        const ns = nameSplitted[1].split(".");
                        const cs = constraintSplitted[0].split(".");
                        if (cs[0].length === 0)
                            return true;
                        return ns.length === cs.length;
                    }
                    return false;
                }
                return (namePrepared.localeCompare(constraintPrepared) === 0);
            }
            function compareUniformResourceIdentifier(name, constraint) {
                let namePrepared = stringPrep(name);
                const constraintPrepared = stringPrep(constraint);
                const ns = namePrepared.split("/");
                const cs = constraintPrepared.split("/");
                if (cs.length > 1)
                    return false;
                if (ns.length > 1) {
                    for (let i = 0; i < ns.length; i++) {
                        if ((ns[i].length > 0) && (ns[i].charAt(ns[i].length - 1) !== ":")) {
                            const nsPort = ns[i].split(":");
                            namePrepared = nsPort[0];
                            break;
                        }
                    }
                }
                const result = compareDNSName(namePrepared, constraintPrepared);
                if (result) {
                    const nameSplitted = namePrepared.split(".");
                    const constraintSplitted = constraintPrepared.split(".");
                    if (constraintSplitted[0].length === 0)
                        return true;
                    return nameSplitted.length === constraintSplitted.length;
                }
                return false;
            }
            function compareIPAddress(name, constraint) {
                const nameView = name.valueBlock.valueHexView;
                const constraintView = constraint.valueBlock.valueHexView;
                if ((nameView.length === 4) && (constraintView.length === 8)) {
                    for (let i = 0; i < 4; i++) {
                        if ((nameView[i] ^ constraintView[i]) & constraintView[i + 4])
                            return false;
                    }
                    return true;
                }
                if ((nameView.length === 16) && (constraintView.length === 32)) {
                    for (let i = 0; i < 16; i++) {
                        if ((nameView[i] ^ constraintView[i]) & constraintView[i + 16])
                            return false;
                    }
                    return true;
                }
                return false;
            }
            function compareDirectoryName(name, constraint) {
                if ((name.typesAndValues.length === 0) || (constraint.typesAndValues.length === 0))
                    return true;
                if (name.typesAndValues.length < constraint.typesAndValues.length)
                    return false;
                let result = true;
                let nameStart = 0;
                for (let i = 0; i < constraint.typesAndValues.length; i++) {
                    let localResult = false;
                    for (let j = nameStart; j < name.typesAndValues.length; j++) {
                        localResult = name.typesAndValues[j].isEqual(constraint.typesAndValues[i]);
                        if (name.typesAndValues[j].type === constraint.typesAndValues[i].type)
                            result = result && localResult;
                        if (localResult === true) {
                            if ((nameStart === 0) || (nameStart === j)) {
                                nameStart = j + 1;
                                break;
                            }
                            else
                                return false;
                        }
                    }
                    if (localResult === false)
                        return false;
                }
                return (nameStart === 0) ? false : result;
            }
            try {
                if (this.certs.length === 0)
                    throw new Error("Empty certificate array");
                const passedWhenNotRevValues = parameters.passedWhenNotRevValues || false;
                const initialPolicySet = parameters.initialPolicySet || [id_AnyPolicy];
                const initialExplicitPolicy = parameters.initialExplicitPolicy || false;
                const initialPolicyMappingInhibit = parameters.initialPolicyMappingInhibit || false;
                const initialInhibitPolicy = parameters.initialInhibitPolicy || false;
                const initialPermittedSubtreesSet = parameters.initialPermittedSubtreesSet || [];
                const initialExcludedSubtreesSet = parameters.initialExcludedSubtreesSet || [];
                const initialRequiredNameForms = parameters.initialRequiredNameForms || [];
                let explicitPolicyIndicator = initialExplicitPolicy;
                let policyMappingInhibitIndicator = initialPolicyMappingInhibit;
                let inhibitAnyPolicyIndicator = initialInhibitPolicy;
                const pendingConstraints = [
                    false,
                    false,
                    false,
                ];
                let explicitPolicyPending = 0;
                let policyMappingInhibitPending = 0;
                let inhibitAnyPolicyPending = 0;
                let permittedSubtrees = initialPermittedSubtreesSet;
                let excludedSubtrees = initialExcludedSubtreesSet;
                const requiredNameForms = initialRequiredNameForms;
                let pathDepth = 1;
                this.certs = await this.sort(passedWhenNotRevValues, crypto);
                const allPolicies = [];
                allPolicies.push(id_AnyPolicy);
                const policiesAndCerts = [];
                const anyPolicyArray = new Array(this.certs.length - 1);
                for (let ii = 0; ii < (this.certs.length - 1); ii++)
                    anyPolicyArray[ii] = true;
                policiesAndCerts.push(anyPolicyArray);
                const policyMappings = new Array(this.certs.length - 1);
                const certPolicies = new Array(this.certs.length - 1);
                let explicitPolicyStart = (explicitPolicyIndicator) ? (this.certs.length - 1) : (-1);
                for (let i = (this.certs.length - 2); i >= 0; i--, pathDepth++) {
                    const cert = this.certs[i];
                    if (cert.extensions) {
                        for (let j = 0; j < cert.extensions.length; j++) {
                            const extension = cert.extensions[j];
                            if (extension.extnID === id_CertificatePolicies) {
                                certPolicies[i] = extension.parsedValue;
                                for (let s = 0; s < allPolicies.length; s++) {
                                    if (allPolicies[s] === id_AnyPolicy) {
                                        delete (policiesAndCerts[s])[i];
                                        break;
                                    }
                                }
                                for (let k = 0; k < extension.parsedValue.certificatePolicies.length; k++) {
                                    let policyIndex = (-1);
                                    const policyId = extension.parsedValue.certificatePolicies[k].policyIdentifier;
                                    for (let s = 0; s < allPolicies.length; s++) {
                                        if (policyId === allPolicies[s]) {
                                            policyIndex = s;
                                            break;
                                        }
                                    }
                                    if (policyIndex === (-1)) {
                                        allPolicies.push(policyId);
                                        const certArray = new Array(this.certs.length - 1);
                                        certArray[i] = true;
                                        policiesAndCerts.push(certArray);
                                    }
                                    else
                                        (policiesAndCerts[policyIndex])[i] = true;
                                }
                            }
                            if (extension.extnID === id_PolicyMappings) {
                                if (policyMappingInhibitIndicator) {
                                    return {
                                        result: false,
                                        resultCode: 98,
                                        resultMessage: "Policy mapping prohibited"
                                    };
                                }
                                policyMappings[i] = extension.parsedValue;
                            }
                            if (extension.extnID === id_PolicyConstraints) {
                                if (explicitPolicyIndicator === false) {
                                    if (extension.parsedValue.requireExplicitPolicy === 0) {
                                        explicitPolicyIndicator = true;
                                        explicitPolicyStart = i;
                                    }
                                    else {
                                        if (pendingConstraints[0] === false) {
                                            pendingConstraints[0] = true;
                                            explicitPolicyPending = extension.parsedValue.requireExplicitPolicy;
                                        }
                                        else
                                            explicitPolicyPending = (explicitPolicyPending > extension.parsedValue.requireExplicitPolicy) ? extension.parsedValue.requireExplicitPolicy : explicitPolicyPending;
                                    }
                                    if (extension.parsedValue.inhibitPolicyMapping === 0)
                                        policyMappingInhibitIndicator = true;
                                    else {
                                        if (pendingConstraints[1] === false) {
                                            pendingConstraints[1] = true;
                                            policyMappingInhibitPending = extension.parsedValue.inhibitPolicyMapping + 1;
                                        }
                                        else
                                            policyMappingInhibitPending = (policyMappingInhibitPending > (extension.parsedValue.inhibitPolicyMapping + 1)) ? (extension.parsedValue.inhibitPolicyMapping + 1) : policyMappingInhibitPending;
                                    }
                                }
                            }
                            if (extension.extnID === id_InhibitAnyPolicy) {
                                if (inhibitAnyPolicyIndicator === false) {
                                    if (extension.parsedValue.valueBlock.valueDec === 0)
                                        inhibitAnyPolicyIndicator = true;
                                    else {
                                        if (pendingConstraints[2] === false) {
                                            pendingConstraints[2] = true;
                                            inhibitAnyPolicyPending = extension.parsedValue.valueBlock.valueDec;
                                        }
                                        else
                                            inhibitAnyPolicyPending = (inhibitAnyPolicyPending > extension.parsedValue.valueBlock.valueDec) ? extension.parsedValue.valueBlock.valueDec : inhibitAnyPolicyPending;
                                    }
                                }
                            }
                        }
                        if (inhibitAnyPolicyIndicator === true) {
                            let policyIndex = (-1);
                            for (let searchAnyPolicy = 0; searchAnyPolicy < allPolicies.length; searchAnyPolicy++) {
                                if (allPolicies[searchAnyPolicy] === id_AnyPolicy) {
                                    policyIndex = searchAnyPolicy;
                                    break;
                                }
                            }
                            if (policyIndex !== (-1))
                                delete (policiesAndCerts[0])[i];
                        }
                        if (explicitPolicyIndicator === false) {
                            if (pendingConstraints[0] === true) {
                                explicitPolicyPending--;
                                if (explicitPolicyPending === 0) {
                                    explicitPolicyIndicator = true;
                                    explicitPolicyStart = i;
                                    pendingConstraints[0] = false;
                                }
                            }
                        }
                        if (policyMappingInhibitIndicator === false) {
                            if (pendingConstraints[1] === true) {
                                policyMappingInhibitPending--;
                                if (policyMappingInhibitPending === 0) {
                                    policyMappingInhibitIndicator = true;
                                    pendingConstraints[1] = false;
                                }
                            }
                        }
                        if (inhibitAnyPolicyIndicator === false) {
                            if (pendingConstraints[2] === true) {
                                inhibitAnyPolicyPending--;
                                if (inhibitAnyPolicyPending === 0) {
                                    inhibitAnyPolicyIndicator = true;
                                    pendingConstraints[2] = false;
                                }
                            }
                        }
                    }
                }
                for (let i = 0; i < (this.certs.length - 1); i++) {
                    if ((i < (this.certs.length - 2)) && (typeof policyMappings[i + 1] !== "undefined")) {
                        for (let k = 0; k < policyMappings[i + 1].mappings.length; k++) {
                            if ((policyMappings[i + 1].mappings[k].issuerDomainPolicy === id_AnyPolicy) || (policyMappings[i + 1].mappings[k].subjectDomainPolicy === id_AnyPolicy)) {
                                return {
                                    result: false,
                                    resultCode: 99,
                                    resultMessage: "The \"anyPolicy\" should not be a part of policy mapping scheme"
                                };
                            }
                            let issuerDomainPolicyIndex = (-1);
                            let subjectDomainPolicyIndex = (-1);
                            for (let n = 0; n < allPolicies.length; n++) {
                                if (allPolicies[n] === policyMappings[i + 1].mappings[k].issuerDomainPolicy)
                                    issuerDomainPolicyIndex = n;
                                if (allPolicies[n] === policyMappings[i + 1].mappings[k].subjectDomainPolicy)
                                    subjectDomainPolicyIndex = n;
                            }
                            if (typeof (policiesAndCerts[issuerDomainPolicyIndex])[i] !== "undefined")
                                delete (policiesAndCerts[issuerDomainPolicyIndex])[i];
                            for (let j = 0; j < certPolicies[i].certificatePolicies.length; j++) {
                                if (policyMappings[i + 1].mappings[k].subjectDomainPolicy === certPolicies[i].certificatePolicies[j].policyIdentifier) {
                                    if ((issuerDomainPolicyIndex !== (-1)) && (subjectDomainPolicyIndex !== (-1))) {
                                        for (let m = 0; m <= i; m++) {
                                            if (typeof (policiesAndCerts[subjectDomainPolicyIndex])[m] !== "undefined") {
                                                (policiesAndCerts[issuerDomainPolicyIndex])[m] = true;
                                                delete (policiesAndCerts[subjectDomainPolicyIndex])[m];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                for (let i = 0; i < allPolicies.length; i++) {
                    if (allPolicies[i] === id_AnyPolicy) {
                        for (let j = 0; j < explicitPolicyStart; j++)
                            delete (policiesAndCerts[i])[j];
                    }
                }
                const authConstrPolicies = [];
                for (let i = 0; i < policiesAndCerts.length; i++) {
                    let found = true;
                    for (let j = 0; j < (this.certs.length - 1); j++) {
                        let anyPolicyFound = false;
                        if ((j < explicitPolicyStart) && (allPolicies[i] === id_AnyPolicy) && (allPolicies.length > 1)) {
                            found = false;
                            break;
                        }
                        if (typeof (policiesAndCerts[i])[j] === "undefined") {
                            if (j >= explicitPolicyStart) {
                                for (let k = 0; k < allPolicies.length; k++) {
                                    if (allPolicies[k] === id_AnyPolicy) {
                                        if ((policiesAndCerts[k])[j] === true)
                                            anyPolicyFound = true;
                                        break;
                                    }
                                }
                            }
                            if (!anyPolicyFound) {
                                found = false;
                                break;
                            }
                        }
                    }
                    if (found === true)
                        authConstrPolicies.push(allPolicies[i]);
                }
                let userConstrPolicies = [];
                if ((initialPolicySet.length === 1) && (initialPolicySet[0] === id_AnyPolicy) && (explicitPolicyIndicator === false))
                    userConstrPolicies = initialPolicySet;
                else {
                    if ((authConstrPolicies.length === 1) && (authConstrPolicies[0] === id_AnyPolicy))
                        userConstrPolicies = initialPolicySet;
                    else {
                        for (let i = 0; i < authConstrPolicies.length; i++) {
                            for (let j = 0; j < initialPolicySet.length; j++) {
                                if ((initialPolicySet[j] === authConstrPolicies[i]) || (initialPolicySet[j] === id_AnyPolicy)) {
                                    userConstrPolicies.push(authConstrPolicies[i]);
                                    break;
                                }
                            }
                        }
                    }
                }
                const policyResult = {
                    result: (userConstrPolicies.length > 0),
                    resultCode: 0,
                    resultMessage: (userConstrPolicies.length > 0) ? EMPTY_STRING : "Zero \"userConstrPolicies\" array, no intersections with \"authConstrPolicies\"",
                    authConstrPolicies,
                    userConstrPolicies,
                    explicitPolicyIndicator,
                    policyMappings,
                    certificatePath: this.certs
                };
                if (userConstrPolicies.length === 0)
                    return policyResult;
                if (policyResult.result === false)
                    return policyResult;
                pathDepth = 1;
                for (let i = (this.certs.length - 2); i >= 0; i--, pathDepth++) {
                    const cert = this.certs[i];
                    let subjectAltNames = [];
                    let certPermittedSubtrees = [];
                    let certExcludedSubtrees = [];
                    if (cert.extensions) {
                        for (let j = 0; j < cert.extensions.length; j++) {
                            const extension = cert.extensions[j];
                            if (extension.extnID === id_NameConstraints) {
                                if ("permittedSubtrees" in extension.parsedValue)
                                    certPermittedSubtrees = certPermittedSubtrees.concat(extension.parsedValue.permittedSubtrees);
                                if ("excludedSubtrees" in extension.parsedValue)
                                    certExcludedSubtrees = certExcludedSubtrees.concat(extension.parsedValue.excludedSubtrees);
                            }
                            if (extension.extnID === id_SubjectAltName)
                                subjectAltNames = subjectAltNames.concat(extension.parsedValue.altNames);
                        }
                    }
                    let formFound = (requiredNameForms.length <= 0);
                    for (let j = 0; j < requiredNameForms.length; j++) {
                        switch (requiredNameForms[j].base.type) {
                            case 4:
                                {
                                    if (requiredNameForms[j].base.value.typesAndValues.length !== cert.subject.typesAndValues.length)
                                        continue;
                                    formFound = true;
                                    for (let k = 0; k < cert.subject.typesAndValues.length; k++) {
                                        if (cert.subject.typesAndValues[k].type !== requiredNameForms[j].base.value.typesAndValues[k].type) {
                                            formFound = false;
                                            break;
                                        }
                                    }
                                    if (formFound === true)
                                        break;
                                }
                                break;
                            default:
                        }
                    }
                    if (formFound === false) {
                        policyResult.result = false;
                        policyResult.resultCode = 21;
                        policyResult.resultMessage = "No necessary name form found";
                        throw policyResult;
                    }
                    const constrGroups = [
                        [],
                        [],
                        [],
                        [],
                        [],
                    ];
                    for (let j = 0; j < permittedSubtrees.length; j++) {
                        switch (permittedSubtrees[j].base.type) {
                            case 1:
                                constrGroups[0].push(permittedSubtrees[j]);
                                break;
                            case 2:
                                constrGroups[1].push(permittedSubtrees[j]);
                                break;
                            case 4:
                                constrGroups[2].push(permittedSubtrees[j]);
                                break;
                            case 6:
                                constrGroups[3].push(permittedSubtrees[j]);
                                break;
                            case 7:
                                constrGroups[4].push(permittedSubtrees[j]);
                                break;
                            default:
                        }
                    }
                    for (let p = 0; p < 5; p++) {
                        let groupPermitted = false;
                        let valueExists = false;
                        const group = constrGroups[p];
                        for (let j = 0; j < group.length; j++) {
                            switch (p) {
                                case 0:
                                    if (subjectAltNames.length > 0) {
                                        for (let k = 0; k < subjectAltNames.length; k++) {
                                            if (subjectAltNames[k].type === 1) {
                                                valueExists = true;
                                                groupPermitted = groupPermitted || compareRFC822Name(subjectAltNames[k].value, group[j].base.value);
                                            }
                                        }
                                    }
                                    else {
                                        for (let k = 0; k < cert.subject.typesAndValues.length; k++) {
                                            if ((cert.subject.typesAndValues[k].type === "1.2.840.113549.1.9.1") ||
                                                (cert.subject.typesAndValues[k].type === "0.9.2342.19200300.100.1.3")) {
                                                valueExists = true;
                                                groupPermitted = groupPermitted || compareRFC822Name(cert.subject.typesAndValues[k].value.valueBlock.value, group[j].base.value);
                                            }
                                        }
                                    }
                                    break;
                                case 1:
                                    if (subjectAltNames.length > 0) {
                                        for (let k = 0; k < subjectAltNames.length; k++) {
                                            if (subjectAltNames[k].type === 2) {
                                                valueExists = true;
                                                groupPermitted = groupPermitted || compareDNSName(subjectAltNames[k].value, group[j].base.value);
                                            }
                                        }
                                    }
                                    break;
                                case 2:
                                    valueExists = true;
                                    groupPermitted = compareDirectoryName(cert.subject, group[j].base.value);
                                    break;
                                case 3:
                                    if (subjectAltNames.length > 0) {
                                        for (let k = 0; k < subjectAltNames.length; k++) {
                                            if (subjectAltNames[k].type === 6) {
                                                valueExists = true;
                                                groupPermitted = groupPermitted || compareUniformResourceIdentifier(subjectAltNames[k].value, group[j].base.value);
                                            }
                                        }
                                    }
                                    break;
                                case 4:
                                    if (subjectAltNames.length > 0) {
                                        for (let k = 0; k < subjectAltNames.length; k++) {
                                            if (subjectAltNames[k].type === 7) {
                                                valueExists = true;
                                                groupPermitted = groupPermitted || compareIPAddress(subjectAltNames[k].value, group[j].base.value);
                                            }
                                        }
                                    }
                                    break;
                                default:
                            }
                            if (groupPermitted)
                                break;
                        }
                        if ((groupPermitted === false) && (group.length > 0) && valueExists) {
                            policyResult.result = false;
                            policyResult.resultCode = 41;
                            policyResult.resultMessage = "Failed to meet \"permitted sub-trees\" name constraint";
                            throw policyResult;
                        }
                    }
                    let excluded = false;
                    for (let j = 0; j < excludedSubtrees.length; j++) {
                        switch (excludedSubtrees[j].base.type) {
                            case 1:
                                if (subjectAltNames.length >= 0) {
                                    for (let k = 0; k < subjectAltNames.length; k++) {
                                        if (subjectAltNames[k].type === 1)
                                            excluded = excluded || compareRFC822Name(subjectAltNames[k].value, excludedSubtrees[j].base.value);
                                    }
                                }
                                else {
                                    for (let k = 0; k < cert.subject.typesAndValues.length; k++) {
                                        if ((cert.subject.typesAndValues[k].type === "1.2.840.113549.1.9.1") ||
                                            (cert.subject.typesAndValues[k].type === "0.9.2342.19200300.100.1.3"))
                                            excluded = excluded || compareRFC822Name(cert.subject.typesAndValues[k].value.valueBlock.value, excludedSubtrees[j].base.value);
                                    }
                                }
                                break;
                            case 2:
                                if (subjectAltNames.length > 0) {
                                    for (let k = 0; k < subjectAltNames.length; k++) {
                                        if (subjectAltNames[k].type === 2)
                                            excluded = excluded || compareDNSName(subjectAltNames[k].value, excludedSubtrees[j].base.value);
                                    }
                                }
                                break;
                            case 4:
                                excluded = excluded || compareDirectoryName(cert.subject, excludedSubtrees[j].base.value);
                                break;
                            case 6:
                                if (subjectAltNames.length > 0) {
                                    for (let k = 0; k < subjectAltNames.length; k++) {
                                        if (subjectAltNames[k].type === 6)
                                            excluded = excluded || compareUniformResourceIdentifier(subjectAltNames[k].value, excludedSubtrees[j].base.value);
                                    }
                                }
                                break;
                            case 7:
                                if (subjectAltNames.length > 0) {
                                    for (let k = 0; k < subjectAltNames.length; k++) {
                                        if (subjectAltNames[k].type === 7)
                                            excluded = excluded || compareIPAddress(subjectAltNames[k].value, excludedSubtrees[j].base.value);
                                    }
                                }
                                break;
                            default:
                        }
                        if (excluded)
                            break;
                    }
                    if (excluded === true) {
                        policyResult.result = false;
                        policyResult.resultCode = 42;
                        policyResult.resultMessage = "Failed to meet \"excluded sub-trees\" name constraint";
                        throw policyResult;
                    }
                    permittedSubtrees = permittedSubtrees.concat(certPermittedSubtrees);
                    excludedSubtrees = excludedSubtrees.concat(certExcludedSubtrees);
                }
                return policyResult;
            }
            catch (error) {
                if (error instanceof Object) {
                    if ("resultMessage" in error)
                        return error;
                    if ("message" in error) {
                        return {
                            result: false,
                            resultCode: -1,
                            resultMessage: error.message
                        };
                    }
                }
                return {
                    result: false,
                    resultCode: -1,
                    resultMessage: error,
                };
            }
        }
    }

    const TBS_RESPONSE_DATA = "tbsResponseData";
    const SIGNATURE_ALGORITHM$3 = "signatureAlgorithm";
    const SIGNATURE$2 = "signature";
    const CERTS$1 = "certs";
    const BASIC_OCSP_RESPONSE = "BasicOCSPResponse";
    const BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA = `${BASIC_OCSP_RESPONSE}.${TBS_RESPONSE_DATA}`;
    const BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM = `${BASIC_OCSP_RESPONSE}.${SIGNATURE_ALGORITHM$3}`;
    const BASIC_OCSP_RESPONSE_SIGNATURE = `${BASIC_OCSP_RESPONSE}.${SIGNATURE$2}`;
    const BASIC_OCSP_RESPONSE_CERTS = `${BASIC_OCSP_RESPONSE}.${CERTS$1}`;
    const CLEAR_PROPS$g = [
        BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA,
        BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM,
        BASIC_OCSP_RESPONSE_SIGNATURE,
        BASIC_OCSP_RESPONSE_CERTS
    ];
    class BasicOCSPResponse extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.tbsResponseData = getParametersValue(parameters, TBS_RESPONSE_DATA, BasicOCSPResponse.defaultValues(TBS_RESPONSE_DATA));
            this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$3, BasicOCSPResponse.defaultValues(SIGNATURE_ALGORITHM$3));
            this.signature = getParametersValue(parameters, SIGNATURE$2, BasicOCSPResponse.defaultValues(SIGNATURE$2));
            if (CERTS$1 in parameters) {
                this.certs = getParametersValue(parameters, CERTS$1, BasicOCSPResponse.defaultValues(CERTS$1));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TBS_RESPONSE_DATA:
                    return new ResponseData();
                case SIGNATURE_ALGORITHM$3:
                    return new AlgorithmIdentifier();
                case SIGNATURE$2:
                    return new BitString();
                case CERTS$1:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case "type":
                    {
                        let comparisonResult = ((ResponseData.compareWithDefault("tbs", memberValue.tbs)) &&
                            (ResponseData.compareWithDefault("responderID", memberValue.responderID)) &&
                            (ResponseData.compareWithDefault("producedAt", memberValue.producedAt)) &&
                            (ResponseData.compareWithDefault("responses", memberValue.responses)));
                        if ("responseExtensions" in memberValue)
                            comparisonResult = comparisonResult && (ResponseData.compareWithDefault("responseExtensions", memberValue.responseExtensions));
                        return comparisonResult;
                    }
                case SIGNATURE_ALGORITHM$3:
                    return ((memberValue.algorithmId === EMPTY_STRING) && (("algorithmParams" in memberValue) === false));
                case SIGNATURE$2:
                    return (memberValue.isEqual(BasicOCSPResponse.defaultValues(memberName)));
                case CERTS$1:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || BASIC_OCSP_RESPONSE),
                value: [
                    ResponseData.schema(names.tbsResponseData || {
                        names: {
                            blockName: BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA
                        }
                    }),
                    AlgorithmIdentifier.schema(names.signatureAlgorithm || {
                        names: {
                            blockName: BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM
                        }
                    }),
                    new BitString({ name: (names.signature || BASIC_OCSP_RESPONSE_SIGNATURE) }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [
                            new Sequence({
                                value: [new Repeated({
                                        name: BASIC_OCSP_RESPONSE_CERTS,
                                        value: Certificate.schema(names.certs || {})
                                    })]
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$g);
            const asn1 = compareSchema(schema, schema, BasicOCSPResponse.schema());
            AsnError.assertSchema(asn1, this.className);
            this.tbsResponseData = new ResponseData({ schema: asn1.result[BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA] });
            this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result[BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM] });
            this.signature = asn1.result[BASIC_OCSP_RESPONSE_SIGNATURE];
            if (BASIC_OCSP_RESPONSE_CERTS in asn1.result) {
                this.certs = Array.from(asn1.result[BASIC_OCSP_RESPONSE_CERTS], element => new Certificate({ schema: element }));
            }
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(this.tbsResponseData.toSchema());
            outputArray.push(this.signatureAlgorithm.toSchema());
            outputArray.push(this.signature);
            if (this.certs) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Sequence({
                            value: Array.from(this.certs, o => o.toSchema())
                        })
                    ]
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                tbsResponseData: this.tbsResponseData.toJSON(),
                signatureAlgorithm: this.signatureAlgorithm.toJSON(),
                signature: this.signature.toJSON(),
            };
            if (this.certs) {
                res.certs = Array.from(this.certs, o => o.toJSON());
            }
            return res;
        }
        async getCertificateStatus(certificate, issuerCertificate, crypto = getCrypto(true)) {
            const result = {
                isForCertificate: false,
                status: 2
            };
            const hashesObject = {};
            const certIDs = [];
            for (const response of this.tbsResponseData.responses) {
                const hashAlgorithm = crypto.getAlgorithmByOID(response.certID.hashAlgorithm.algorithmId, true, "CertID.hashAlgorithm");
                if (!hashesObject[hashAlgorithm.name]) {
                    hashesObject[hashAlgorithm.name] = 1;
                    const certID = new CertID();
                    certIDs.push(certID);
                    await certID.createForCertificate(certificate, {
                        hashAlgorithm: hashAlgorithm.name,
                        issuerCertificate
                    }, crypto);
                }
            }
            for (const response of this.tbsResponseData.responses) {
                for (const id of certIDs) {
                    if (response.certID.isEqual(id)) {
                        result.isForCertificate = true;
                        try {
                            switch (response.certStatus.idBlock.isConstructed) {
                                case true:
                                    if (response.certStatus.idBlock.tagNumber === 1)
                                        result.status = 1;
                                    break;
                                case false:
                                    switch (response.certStatus.idBlock.tagNumber) {
                                        case 0:
                                            result.status = 0;
                                            break;
                                        case 2:
                                            result.status = 2;
                                            break;
                                        default:
                                    }
                                    break;
                                default:
                            }
                        }
                        catch (ex) {
                        }
                        return result;
                    }
                }
            }
            return result;
        }
        async sign(privateKey, hashAlgorithm = "SHA-1", crypto = getCrypto(true)) {
            if (!privateKey) {
                throw new Error("Need to provide a private key for signing");
            }
            const signatureParams = await crypto.getSignatureParameters(privateKey, hashAlgorithm);
            const algorithm = signatureParams.parameters.algorithm;
            if (!("name" in algorithm)) {
                throw new Error("Empty algorithm");
            }
            this.signatureAlgorithm = signatureParams.signatureAlgorithm;
            this.tbsResponseData.tbsView = new Uint8Array(this.tbsResponseData.toSchema(true).toBER());
            const signature = await crypto.signWithPrivateKey(this.tbsResponseData.tbsView, privateKey, { algorithm });
            this.signature = new BitString({ valueHex: signature });
        }
        async verify(params = {}, crypto = getCrypto(true)) {
            let signerCert = null;
            let certIndex = -1;
            const trustedCerts = params.trustedCerts || [];
            if (!this.certs) {
                throw new Error("No certificates attached to the BasicOCSPResponse");
            }
            switch (true) {
                case (this.tbsResponseData.responderID instanceof RelativeDistinguishedNames):
                    for (const [index, certificate] of this.certs.entries()) {
                        if (certificate.subject.isEqual(this.tbsResponseData.responderID)) {
                            certIndex = index;
                            break;
                        }
                    }
                    break;
                case (this.tbsResponseData.responderID instanceof OctetString):
                    for (const [index, cert] of this.certs.entries()) {
                        const hash = await crypto.digest({ name: "sha-1" }, cert.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);
                        if (isEqualBuffer(hash, this.tbsResponseData.responderID.valueBlock.valueHex)) {
                            certIndex = index;
                            break;
                        }
                    }
                    break;
                default:
                    throw new Error("Wrong value for responderID");
            }
            if (certIndex === (-1))
                throw new Error("Correct certificate was not found in OCSP response");
            signerCert = this.certs[certIndex];
            const additionalCerts = [signerCert];
            for (const cert of this.certs) {
                const caCert = await checkCA(cert, signerCert);
                if (caCert) {
                    additionalCerts.push(caCert);
                }
            }
            const certChain = new CertificateChainValidationEngine({
                certs: additionalCerts,
                trustedCerts,
            });
            const verificationResult = await certChain.verify({}, crypto);
            if (!verificationResult.result) {
                throw new Error("Validation of signer's certificate failed");
            }
            return crypto.verifyWithPublicKey(this.tbsResponseData.tbsView, this.signature, this.certs[certIndex].subjectPublicKeyInfo, this.signatureAlgorithm);
        }
    }
    BasicOCSPResponse.CLASS_NAME = "BasicOCSPResponse";

    const TBS$1 = "tbs";
    const VERSION$6 = "version";
    const SUBJECT = "subject";
    const SPKI = "subjectPublicKeyInfo";
    const ATTRIBUTES$1 = "attributes";
    const SIGNATURE_ALGORITHM$2 = "signatureAlgorithm";
    const SIGNATURE_VALUE = "signatureValue";
    const CSR_INFO = "CertificationRequestInfo";
    const CSR_INFO_VERSION = `${CSR_INFO}.version`;
    const CSR_INFO_SUBJECT = `${CSR_INFO}.subject`;
    const CSR_INFO_SPKI = `${CSR_INFO}.subjectPublicKeyInfo`;
    const CSR_INFO_ATTRS = `${CSR_INFO}.attributes`;
    const CLEAR_PROPS$f = [
        CSR_INFO,
        CSR_INFO_VERSION,
        CSR_INFO_SUBJECT,
        CSR_INFO_SPKI,
        CSR_INFO_ATTRS,
        SIGNATURE_ALGORITHM$2,
        SIGNATURE_VALUE
    ];
    function CertificationRequestInfo(parameters = {}) {
        const names = getParametersValue(parameters, "names", {});
        return (new Sequence({
            name: (names.CertificationRequestInfo || CSR_INFO),
            value: [
                new Integer({ name: (names.CertificationRequestInfoVersion || CSR_INFO_VERSION) }),
                RelativeDistinguishedNames.schema(names.subject || {
                    names: {
                        blockName: CSR_INFO_SUBJECT
                    }
                }),
                PublicKeyInfo.schema({
                    names: {
                        blockName: CSR_INFO_SPKI
                    }
                }),
                new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Repeated({
                            optional: true,
                            name: (names.CertificationRequestInfoAttributes || CSR_INFO_ATTRS),
                            value: Attribute.schema(names.attributes || {})
                        })
                    ]
                })
            ]
        }));
    }
    class CertificationRequest extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.tbsView = new Uint8Array(getParametersValue(parameters, TBS$1, CertificationRequest.defaultValues(TBS$1)));
            this.version = getParametersValue(parameters, VERSION$6, CertificationRequest.defaultValues(VERSION$6));
            this.subject = getParametersValue(parameters, SUBJECT, CertificationRequest.defaultValues(SUBJECT));
            this.subjectPublicKeyInfo = getParametersValue(parameters, SPKI, CertificationRequest.defaultValues(SPKI));
            if (ATTRIBUTES$1 in parameters) {
                this.attributes = getParametersValue(parameters, ATTRIBUTES$1, CertificationRequest.defaultValues(ATTRIBUTES$1));
            }
            this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$2, CertificationRequest.defaultValues(SIGNATURE_ALGORITHM$2));
            this.signatureValue = getParametersValue(parameters, SIGNATURE_VALUE, CertificationRequest.defaultValues(SIGNATURE_VALUE));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        get tbs() {
            return BufferSourceConverter_1.toArrayBuffer(this.tbsView);
        }
        set tbs(value) {
            this.tbsView = new Uint8Array(value);
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TBS$1:
                    return EMPTY_BUFFER;
                case VERSION$6:
                    return 0;
                case SUBJECT:
                    return new RelativeDistinguishedNames();
                case SPKI:
                    return new PublicKeyInfo();
                case ATTRIBUTES$1:
                    return [];
                case SIGNATURE_ALGORITHM$2:
                    return new AlgorithmIdentifier();
                case SIGNATURE_VALUE:
                    return new BitString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                value: [
                    CertificationRequestInfo(names.certificationRequestInfo || {}),
                    new Sequence({
                        name: (names.signatureAlgorithm || SIGNATURE_ALGORITHM$2),
                        value: [
                            new ObjectIdentifier(),
                            new Any({ optional: true })
                        ]
                    }),
                    new BitString({ name: (names.signatureValue || SIGNATURE_VALUE) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$f);
            const asn1 = compareSchema(schema, schema, CertificationRequest.schema());
            AsnError.assertSchema(asn1, this.className);
            this.tbsView = asn1.result.CertificationRequestInfo.valueBeforeDecodeView;
            this.version = asn1.result[CSR_INFO_VERSION].valueBlock.valueDec;
            this.subject = new RelativeDistinguishedNames({ schema: asn1.result[CSR_INFO_SUBJECT] });
            this.subjectPublicKeyInfo = new PublicKeyInfo({ schema: asn1.result[CSR_INFO_SPKI] });
            if (CSR_INFO_ATTRS in asn1.result) {
                this.attributes = Array.from(asn1.result[CSR_INFO_ATTRS], element => new Attribute({ schema: element }));
            }
            this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
            this.signatureValue = asn1.result.signatureValue;
        }
        encodeTBS() {
            const outputArray = [
                new Integer({ value: this.version }),
                this.subject.toSchema(),
                this.subjectPublicKeyInfo.toSchema()
            ];
            if (ATTRIBUTES$1 in this) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: Array.from(this.attributes || [], o => o.toSchema())
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toSchema(encodeFlag = false) {
            let tbsSchema;
            if (encodeFlag === false) {
                if (this.tbsView.byteLength === 0) {
                    return CertificationRequest.schema();
                }
                const asn1 = fromBER(this.tbsView);
                AsnError.assert(asn1, "PKCS#10 Certificate Request");
                tbsSchema = asn1.result;
            }
            else {
                tbsSchema = this.encodeTBS();
            }
            return (new Sequence({
                value: [
                    tbsSchema,
                    this.signatureAlgorithm.toSchema(),
                    this.signatureValue
                ]
            }));
        }
        toJSON() {
            const object = {
                tbs: Convert_1.ToHex(this.tbsView),
                version: this.version,
                subject: this.subject.toJSON(),
                subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
                signatureAlgorithm: this.signatureAlgorithm.toJSON(),
                signatureValue: this.signatureValue.toJSON(),
            };
            if (ATTRIBUTES$1 in this) {
                object.attributes = Array.from(this.attributes || [], o => o.toJSON());
            }
            return object;
        }
        async sign(privateKey, hashAlgorithm = "SHA-1", crypto = getCrypto(true)) {
            if (!privateKey) {
                throw new Error("Need to provide a private key for signing");
            }
            const signatureParams = await crypto.getSignatureParameters(privateKey, hashAlgorithm);
            const parameters = signatureParams.parameters;
            this.signatureAlgorithm = signatureParams.signatureAlgorithm;
            this.tbsView = new Uint8Array(this.encodeTBS().toBER());
            const signature = await crypto.signWithPrivateKey(this.tbsView, privateKey, parameters);
            this.signatureValue = new BitString({ valueHex: signature });
        }
        async verify(crypto = getCrypto(true)) {
            return crypto.verifyWithPublicKey(this.tbsView, this.signatureValue, this.subjectPublicKeyInfo, this.signatureAlgorithm);
        }
        async getPublicKey(parameters, crypto = getCrypto(true)) {
            return crypto.getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);
        }
    }
    CertificationRequest.CLASS_NAME = "CertificationRequest";

    const DIGEST_ALGORITHM$1 = "digestAlgorithm";
    const DIGEST = "digest";
    const CLEAR_PROPS$e = [
        DIGEST_ALGORITHM$1,
        DIGEST
    ];
    class DigestInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.digestAlgorithm = getParametersValue(parameters, DIGEST_ALGORITHM$1, DigestInfo.defaultValues(DIGEST_ALGORITHM$1));
            this.digest = getParametersValue(parameters, DIGEST, DigestInfo.defaultValues(DIGEST));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case DIGEST_ALGORITHM$1:
                    return new AlgorithmIdentifier();
                case DIGEST:
                    return new OctetString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case DIGEST_ALGORITHM$1:
                    return ((AlgorithmIdentifier.compareWithDefault("algorithmId", memberValue.algorithmId)) &&
                        (("algorithmParams" in memberValue) === false));
                case DIGEST:
                    return (memberValue.isEqual(DigestInfo.defaultValues(memberName)));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    AlgorithmIdentifier.schema(names.digestAlgorithm || {
                        names: {
                            blockName: DIGEST_ALGORITHM$1
                        }
                    }),
                    new OctetString({ name: (names.digest || DIGEST) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$e);
            const asn1 = compareSchema(schema, schema, DigestInfo.schema({
                names: {
                    digestAlgorithm: {
                        names: {
                            blockName: DIGEST_ALGORITHM$1
                        }
                    },
                    digest: DIGEST
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.digestAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.digestAlgorithm });
            this.digest = asn1.result.digest;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    this.digestAlgorithm.toSchema(),
                    this.digest
                ]
            }));
        }
        toJSON() {
            return {
                digestAlgorithm: this.digestAlgorithm.toJSON(),
                digest: this.digest.toJSON(),
            };
        }
    }
    DigestInfo.CLASS_NAME = "DigestInfo";

    const E_CONTENT_TYPE = "eContentType";
    const E_CONTENT = "eContent";
    const CLEAR_PROPS$d = [
        E_CONTENT_TYPE,
        E_CONTENT,
    ];
    class EncapsulatedContentInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.eContentType = getParametersValue(parameters, E_CONTENT_TYPE, EncapsulatedContentInfo.defaultValues(E_CONTENT_TYPE));
            if (E_CONTENT in parameters) {
                this.eContent = getParametersValue(parameters, E_CONTENT, EncapsulatedContentInfo.defaultValues(E_CONTENT));
                if ((this.eContent.idBlock.tagClass === 1) &&
                    (this.eContent.idBlock.tagNumber === 4)) {
                    if (this.eContent.idBlock.isConstructed === false) {
                        const constrString = new OctetString({
                            idBlock: { isConstructed: true },
                            isConstructed: true
                        });
                        let offset = 0;
                        const viewHex = this.eContent.valueBlock.valueHexView.slice().buffer;
                        let length = viewHex.byteLength;
                        while (length > 0) {
                            const pieceView = new Uint8Array(viewHex, offset, ((offset + 65536) > viewHex.byteLength) ? (viewHex.byteLength - offset) : 65536);
                            const _array = new ArrayBuffer(pieceView.length);
                            const _view = new Uint8Array(_array);
                            for (let i = 0; i < _view.length; i++) {
                                _view[i] = pieceView[i];
                            }
                            constrString.valueBlock.value.push(new OctetString({ valueHex: _array }));
                            length -= pieceView.length;
                            offset += pieceView.length;
                        }
                        this.eContent = constrString;
                    }
                }
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case E_CONTENT_TYPE:
                    return EMPTY_STRING;
                case E_CONTENT:
                    return new OctetString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case E_CONTENT_TYPE:
                    return (memberValue === EMPTY_STRING);
                case E_CONTENT:
                    {
                        if ((memberValue.idBlock.tagClass === 1) && (memberValue.idBlock.tagNumber === 4))
                            return (memberValue.isEqual(EncapsulatedContentInfo.defaultValues(E_CONTENT)));
                        return false;
                    }
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.eContentType || EMPTY_STRING) }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [
                            new Any({ name: (names.eContent || EMPTY_STRING) })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$d);
            const asn1 = compareSchema(schema, schema, EncapsulatedContentInfo.schema({
                names: {
                    eContentType: E_CONTENT_TYPE,
                    eContent: E_CONTENT
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.eContentType = asn1.result.eContentType.valueBlock.toString();
            if (E_CONTENT in asn1.result)
                this.eContent = asn1.result.eContent;
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new ObjectIdentifier({ value: this.eContentType }));
            if (this.eContent) {
                if (EncapsulatedContentInfo.compareWithDefault(E_CONTENT, this.eContent) === false) {
                    outputArray.push(new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [this.eContent]
                    }));
                }
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                eContentType: this.eContentType
            };
            if (this.eContent && EncapsulatedContentInfo.compareWithDefault(E_CONTENT, this.eContent) === false) {
                res.eContent = this.eContent.toJSON();
            }
            return res;
        }
    }
    EncapsulatedContentInfo.CLASS_NAME = "EncapsulatedContentInfo";

    const MAC = "mac";
    const MAC_SALT = "macSalt";
    const ITERATIONS = "iterations";
    const CLEAR_PROPS$c = [
        MAC,
        MAC_SALT,
        ITERATIONS
    ];
    class MacData extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.mac = getParametersValue(parameters, MAC, MacData.defaultValues(MAC));
            this.macSalt = getParametersValue(parameters, MAC_SALT, MacData.defaultValues(MAC_SALT));
            if (ITERATIONS in parameters) {
                this.iterations = getParametersValue(parameters, ITERATIONS, MacData.defaultValues(ITERATIONS));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case MAC:
                    return new DigestInfo();
                case MAC_SALT:
                    return new OctetString();
                case ITERATIONS:
                    return 1;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case MAC:
                    return ((DigestInfo.compareWithDefault("digestAlgorithm", memberValue.digestAlgorithm)) &&
                        (DigestInfo.compareWithDefault("digest", memberValue.digest)));
                case MAC_SALT:
                    return (memberValue.isEqual(MacData.defaultValues(memberName)));
                case ITERATIONS:
                    return (memberValue === MacData.defaultValues(memberName));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                optional: (names.optional || true),
                value: [
                    DigestInfo.schema(names.mac || {
                        names: {
                            blockName: MAC
                        }
                    }),
                    new OctetString({ name: (names.macSalt || MAC_SALT) }),
                    new Integer({
                        optional: true,
                        name: (names.iterations || ITERATIONS)
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$c);
            const asn1 = compareSchema(schema, schema, MacData.schema({
                names: {
                    mac: {
                        names: {
                            blockName: MAC
                        }
                    },
                    macSalt: MAC_SALT,
                    iterations: ITERATIONS
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.mac = new DigestInfo({ schema: asn1.result.mac });
            this.macSalt = asn1.result.macSalt;
            if (ITERATIONS in asn1.result)
                this.iterations = asn1.result.iterations.valueBlock.valueDec;
        }
        toSchema() {
            const outputArray = [
                this.mac.toSchema(),
                this.macSalt
            ];
            if (this.iterations !== undefined) {
                outputArray.push(new Integer({ value: this.iterations }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                mac: this.mac.toJSON(),
                macSalt: this.macSalt.toJSON(),
            };
            if (this.iterations !== undefined) {
                res.iterations = this.iterations;
            }
            return res;
        }
    }
    MacData.CLASS_NAME = "MacData";

    const HASH_ALGORITHM = "hashAlgorithm";
    const HASHED_MESSAGE = "hashedMessage";
    const CLEAR_PROPS$b = [
        HASH_ALGORITHM,
        HASHED_MESSAGE,
    ];
    class MessageImprint extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.hashAlgorithm = getParametersValue(parameters, HASH_ALGORITHM, MessageImprint.defaultValues(HASH_ALGORITHM));
            this.hashedMessage = getParametersValue(parameters, HASHED_MESSAGE, MessageImprint.defaultValues(HASHED_MESSAGE));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static async create(hashAlgorithm, message, crypto = getCrypto(true)) {
            const hashAlgorithmOID = crypto.getOIDByAlgorithm({ name: hashAlgorithm }, true, "hashAlgorithm");
            const hashedMessage = await crypto.digest(hashAlgorithm, message);
            const res = new MessageImprint({
                hashAlgorithm: new AlgorithmIdentifier({
                    algorithmId: hashAlgorithmOID,
                    algorithmParams: new Null(),
                }),
                hashedMessage: new OctetString({ valueHex: hashedMessage })
            });
            return res;
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case HASH_ALGORITHM:
                    return new AlgorithmIdentifier();
                case HASHED_MESSAGE:
                    return new OctetString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case HASH_ALGORITHM:
                    return ((memberValue.algorithmId === EMPTY_STRING) && (("algorithmParams" in memberValue) === false));
                case HASHED_MESSAGE:
                    return (memberValue.isEqual(MessageImprint.defaultValues(memberName)) === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    AlgorithmIdentifier.schema(names.hashAlgorithm || {}),
                    new OctetString({ name: (names.hashedMessage || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$b);
            const asn1 = compareSchema(schema, schema, MessageImprint.schema({
                names: {
                    hashAlgorithm: {
                        names: {
                            blockName: HASH_ALGORITHM
                        }
                    },
                    hashedMessage: HASHED_MESSAGE
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.hashAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.hashAlgorithm });
            this.hashedMessage = asn1.result.hashedMessage;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    this.hashAlgorithm.toSchema(),
                    this.hashedMessage
                ]
            }));
        }
        toJSON() {
            return {
                hashAlgorithm: this.hashAlgorithm.toJSON(),
                hashedMessage: this.hashedMessage.toJSON(),
            };
        }
    }
    MessageImprint.CLASS_NAME = "MessageImprint";

    const REQ_CERT = "reqCert";
    const SINGLE_REQUEST_EXTENSIONS = "singleRequestExtensions";
    const CLEAR_PROPS$a = [
        REQ_CERT,
        SINGLE_REQUEST_EXTENSIONS,
    ];
    class Request extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.reqCert = getParametersValue(parameters, REQ_CERT, Request.defaultValues(REQ_CERT));
            if (SINGLE_REQUEST_EXTENSIONS in parameters) {
                this.singleRequestExtensions = getParametersValue(parameters, SINGLE_REQUEST_EXTENSIONS, Request.defaultValues(SINGLE_REQUEST_EXTENSIONS));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case REQ_CERT:
                    return new CertID();
                case SINGLE_REQUEST_EXTENSIONS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case REQ_CERT:
                    return (memberValue.isEqual(Request.defaultValues(memberName)));
                case SINGLE_REQUEST_EXTENSIONS:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    CertID.schema(names.reqCert || {}),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [Extension.schema(names.extensions || {
                                names: {
                                    blockName: (names.singleRequestExtensions || EMPTY_STRING)
                                }
                            })]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$a);
            const asn1 = compareSchema(schema, schema, Request.schema({
                names: {
                    reqCert: {
                        names: {
                            blockName: REQ_CERT
                        }
                    },
                    extensions: {
                        names: {
                            blockName: SINGLE_REQUEST_EXTENSIONS
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.reqCert = new CertID({ schema: asn1.result.reqCert });
            if (SINGLE_REQUEST_EXTENSIONS in asn1.result) {
                this.singleRequestExtensions = Array.from(asn1.result.singleRequestExtensions.valueBlock.value, element => new Extension({ schema: element }));
            }
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(this.reqCert.toSchema());
            if (this.singleRequestExtensions) {
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Sequence({
                            value: Array.from(this.singleRequestExtensions, o => o.toSchema())
                        })
                    ]
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                reqCert: this.reqCert.toJSON()
            };
            if (this.singleRequestExtensions) {
                res.singleRequestExtensions = Array.from(this.singleRequestExtensions, o => o.toJSON());
            }
            return res;
        }
    }
    Request.CLASS_NAME = "Request";

    const TBS = "tbs";
    const VERSION$5 = "version";
    const REQUESTOR_NAME = "requestorName";
    const REQUEST_LIST = "requestList";
    const REQUEST_EXTENSIONS = "requestExtensions";
    const TBS_REQUEST$1 = "TBSRequest";
    const TBS_REQUEST_VERSION = `${TBS_REQUEST$1}.${VERSION$5}`;
    const TBS_REQUEST_REQUESTOR_NAME = `${TBS_REQUEST$1}.${REQUESTOR_NAME}`;
    const TBS_REQUEST_REQUESTS = `${TBS_REQUEST$1}.requests`;
    const TBS_REQUEST_REQUEST_EXTENSIONS = `${TBS_REQUEST$1}.${REQUEST_EXTENSIONS}`;
    const CLEAR_PROPS$9 = [
        TBS_REQUEST$1,
        TBS_REQUEST_VERSION,
        TBS_REQUEST_REQUESTOR_NAME,
        TBS_REQUEST_REQUESTS,
        TBS_REQUEST_REQUEST_EXTENSIONS
    ];
    class TBSRequest extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.tbsView = new Uint8Array(getParametersValue(parameters, TBS, TBSRequest.defaultValues(TBS)));
            if (VERSION$5 in parameters) {
                this.version = getParametersValue(parameters, VERSION$5, TBSRequest.defaultValues(VERSION$5));
            }
            if (REQUESTOR_NAME in parameters) {
                this.requestorName = getParametersValue(parameters, REQUESTOR_NAME, TBSRequest.defaultValues(REQUESTOR_NAME));
            }
            this.requestList = getParametersValue(parameters, REQUEST_LIST, TBSRequest.defaultValues(REQUEST_LIST));
            if (REQUEST_EXTENSIONS in parameters) {
                this.requestExtensions = getParametersValue(parameters, REQUEST_EXTENSIONS, TBSRequest.defaultValues(REQUEST_EXTENSIONS));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        get tbs() {
            return BufferSourceConverter_1.toArrayBuffer(this.tbsView);
        }
        set tbs(value) {
            this.tbsView = new Uint8Array(value);
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TBS:
                    return EMPTY_BUFFER;
                case VERSION$5:
                    return 0;
                case REQUESTOR_NAME:
                    return new GeneralName();
                case REQUEST_LIST:
                case REQUEST_EXTENSIONS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case TBS:
                    return (memberValue.byteLength === 0);
                case VERSION$5:
                    return (memberValue === TBSRequest.defaultValues(memberName));
                case REQUESTOR_NAME:
                    return ((memberValue.type === GeneralName.defaultValues("type")) && (Object.keys(memberValue.value).length === 0));
                case REQUEST_LIST:
                case REQUEST_EXTENSIONS:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || TBS_REQUEST$1),
                value: [
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [new Integer({ name: (names.TBSRequestVersion || TBS_REQUEST_VERSION) })]
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [GeneralName.schema(names.requestorName || {
                                names: {
                                    blockName: TBS_REQUEST_REQUESTOR_NAME
                                }
                            })]
                    }),
                    new Sequence({
                        name: (names.requestList || "TBSRequest.requestList"),
                        value: [
                            new Repeated({
                                name: (names.requests || TBS_REQUEST_REQUESTS),
                                value: Request.schema(names.requestNames || {})
                            })
                        ]
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 2
                        },
                        value: [Extensions.schema(names.extensions || {
                                names: {
                                    blockName: (names.requestExtensions || TBS_REQUEST_REQUEST_EXTENSIONS)
                                }
                            })]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$9);
            const asn1 = compareSchema(schema, schema, TBSRequest.schema());
            AsnError.assertSchema(asn1, this.className);
            this.tbsView = asn1.result.TBSRequest.valueBeforeDecodeView;
            if (TBS_REQUEST_VERSION in asn1.result)
                this.version = asn1.result[TBS_REQUEST_VERSION].valueBlock.valueDec;
            if (TBS_REQUEST_REQUESTOR_NAME in asn1.result)
                this.requestorName = new GeneralName({ schema: asn1.result[TBS_REQUEST_REQUESTOR_NAME] });
            this.requestList = Array.from(asn1.result[TBS_REQUEST_REQUESTS], element => new Request({ schema: element }));
            if (TBS_REQUEST_REQUEST_EXTENSIONS in asn1.result)
                this.requestExtensions = Array.from(asn1.result[TBS_REQUEST_REQUEST_EXTENSIONS].valueBlock.value, element => new Extension({ schema: element }));
        }
        toSchema(encodeFlag = false) {
            let tbsSchema;
            if (encodeFlag === false) {
                if (this.tbsView.byteLength === 0)
                    return TBSRequest.schema();
                const asn1 = fromBER(this.tbsView);
                AsnError.assert(asn1, "TBS Request");
                if (!(asn1.result instanceof Sequence)) {
                    throw new Error("ASN.1 result should be SEQUENCE");
                }
                tbsSchema = asn1.result;
            }
            else {
                const outputArray = [];
                if (this.version !== undefined) {
                    outputArray.push(new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [new Integer({ value: this.version })]
                    }));
                }
                if (this.requestorName) {
                    outputArray.push(new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [this.requestorName.toSchema()]
                    }));
                }
                outputArray.push(new Sequence({
                    value: Array.from(this.requestList, o => o.toSchema())
                }));
                if (this.requestExtensions) {
                    outputArray.push(new Constructed({
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 2
                        },
                        value: [
                            new Sequence({
                                value: Array.from(this.requestExtensions, o => o.toSchema())
                            })
                        ]
                    }));
                }
                tbsSchema = new Sequence({
                    value: outputArray
                });
            }
            return tbsSchema;
        }
        toJSON() {
            const res = {};
            if (this.version != undefined)
                res.version = this.version;
            if (this.requestorName) {
                res.requestorName = this.requestorName.toJSON();
            }
            res.requestList = Array.from(this.requestList, o => o.toJSON());
            if (this.requestExtensions) {
                res.requestExtensions = Array.from(this.requestExtensions, o => o.toJSON());
            }
            return res;
        }
    }
    TBSRequest.CLASS_NAME = "TBSRequest";

    const SIGNATURE_ALGORITHM$1 = "signatureAlgorithm";
    const SIGNATURE$1 = "signature";
    const CERTS = "certs";
    class Signature extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM$1, Signature.defaultValues(SIGNATURE_ALGORITHM$1));
            this.signature = getParametersValue(parameters, SIGNATURE$1, Signature.defaultValues(SIGNATURE$1));
            if (CERTS in parameters) {
                this.certs = getParametersValue(parameters, CERTS, Signature.defaultValues(CERTS));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case SIGNATURE_ALGORITHM$1:
                    return new AlgorithmIdentifier();
                case SIGNATURE$1:
                    return new BitString();
                case CERTS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case SIGNATURE_ALGORITHM$1:
                    return ((memberValue.algorithmId === EMPTY_STRING) && (("algorithmParams" in memberValue) === false));
                case SIGNATURE$1:
                    return (memberValue.isEqual(Signature.defaultValues(memberName)));
                case CERTS:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    AlgorithmIdentifier.schema(names.signatureAlgorithm || {}),
                    new BitString({ name: (names.signature || EMPTY_STRING) }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [
                            new Sequence({
                                value: [new Repeated({
                                        name: (names.certs || EMPTY_STRING),
                                        value: Certificate.schema({})
                                    })]
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, [
                SIGNATURE_ALGORITHM$1,
                SIGNATURE$1,
                CERTS
            ]);
            const asn1 = compareSchema(schema, schema, Signature.schema({
                names: {
                    signatureAlgorithm: {
                        names: {
                            blockName: SIGNATURE_ALGORITHM$1
                        }
                    },
                    signature: SIGNATURE$1,
                    certs: CERTS
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
            this.signature = asn1.result.signature;
            if (CERTS in asn1.result)
                this.certs = Array.from(asn1.result.certs, element => new Certificate({ schema: element }));
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(this.signatureAlgorithm.toSchema());
            outputArray.push(this.signature);
            if (this.certs) {
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        new Sequence({
                            value: Array.from(this.certs, o => o.toSchema())
                        })
                    ]
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                signatureAlgorithm: this.signatureAlgorithm.toJSON(),
                signature: this.signature.toJSON(),
            };
            if (this.certs) {
                res.certs = Array.from(this.certs, o => o.toJSON());
            }
            return res;
        }
    }
    Signature.CLASS_NAME = "Signature";

    const TBS_REQUEST = "tbsRequest";
    const OPTIONAL_SIGNATURE = "optionalSignature";
    const CLEAR_PROPS$8 = [
        TBS_REQUEST,
        OPTIONAL_SIGNATURE
    ];
    class OCSPRequest extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.tbsRequest = getParametersValue(parameters, TBS_REQUEST, OCSPRequest.defaultValues(TBS_REQUEST));
            if (OPTIONAL_SIGNATURE in parameters) {
                this.optionalSignature = getParametersValue(parameters, OPTIONAL_SIGNATURE, OCSPRequest.defaultValues(OPTIONAL_SIGNATURE));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TBS_REQUEST:
                    return new TBSRequest();
                case OPTIONAL_SIGNATURE:
                    return new Signature();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case TBS_REQUEST:
                    return ((TBSRequest.compareWithDefault("tbs", memberValue.tbs)) &&
                        (TBSRequest.compareWithDefault("version", memberValue.version)) &&
                        (TBSRequest.compareWithDefault("requestorName", memberValue.requestorName)) &&
                        (TBSRequest.compareWithDefault("requestList", memberValue.requestList)) &&
                        (TBSRequest.compareWithDefault("requestExtensions", memberValue.requestExtensions)));
                case OPTIONAL_SIGNATURE:
                    return ((Signature.compareWithDefault("signatureAlgorithm", memberValue.signatureAlgorithm)) &&
                        (Signature.compareWithDefault("signature", memberValue.signature)) &&
                        (Signature.compareWithDefault("certs", memberValue.certs)));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: names.blockName || "OCSPRequest",
                value: [
                    TBSRequest.schema(names.tbsRequest || {
                        names: {
                            blockName: TBS_REQUEST
                        }
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [
                            Signature.schema(names.optionalSignature || {
                                names: {
                                    blockName: OPTIONAL_SIGNATURE
                                }
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$8);
            const asn1 = compareSchema(schema, schema, OCSPRequest.schema());
            AsnError.assertSchema(asn1, this.className);
            this.tbsRequest = new TBSRequest({ schema: asn1.result.tbsRequest });
            if (OPTIONAL_SIGNATURE in asn1.result)
                this.optionalSignature = new Signature({ schema: asn1.result.optionalSignature });
        }
        toSchema(encodeFlag = false) {
            const outputArray = [];
            outputArray.push(this.tbsRequest.toSchema(encodeFlag));
            if (this.optionalSignature)
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [
                        this.optionalSignature.toSchema()
                    ]
                }));
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                tbsRequest: this.tbsRequest.toJSON()
            };
            if (this.optionalSignature) {
                res.optionalSignature = this.optionalSignature.toJSON();
            }
            return res;
        }
        async createForCertificate(certificate, parameters, crypto = getCrypto(true)) {
            const certID = new CertID();
            await certID.createForCertificate(certificate, parameters, crypto);
            this.tbsRequest.requestList.push(new Request({
                reqCert: certID,
            }));
        }
        async sign(privateKey, hashAlgorithm = "SHA-1", crypto = getCrypto(true)) {
            ParameterError.assertEmpty(privateKey, "privateKey", "OCSPRequest.sign method");
            if (!this.optionalSignature) {
                throw new Error("Need to create \"optionalSignature\" field before signing");
            }
            const signatureParams = await crypto.getSignatureParameters(privateKey, hashAlgorithm);
            const parameters = signatureParams.parameters;
            this.optionalSignature.signatureAlgorithm = signatureParams.signatureAlgorithm;
            const tbs = this.tbsRequest.toSchema(true).toBER(false);
            const signature = await crypto.signWithPrivateKey(tbs, privateKey, parameters);
            this.optionalSignature.signature = new BitString({ valueHex: signature });
        }
        verify() {
        }
    }
    OCSPRequest.CLASS_NAME = "OCSPRequest";

    const RESPONSE_TYPE = "responseType";
    const RESPONSE = "response";
    const CLEAR_PROPS$7 = [
        RESPONSE_TYPE,
        RESPONSE
    ];
    class ResponseBytes extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.responseType = getParametersValue(parameters, RESPONSE_TYPE, ResponseBytes.defaultValues(RESPONSE_TYPE));
            this.response = getParametersValue(parameters, RESPONSE, ResponseBytes.defaultValues(RESPONSE));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case RESPONSE_TYPE:
                    return EMPTY_STRING;
                case RESPONSE:
                    return new OctetString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case RESPONSE_TYPE:
                    return (memberValue === EMPTY_STRING);
                case RESPONSE:
                    return (memberValue.isEqual(ResponseBytes.defaultValues(memberName)));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new ObjectIdentifier({ name: (names.responseType || EMPTY_STRING) }),
                    new OctetString({ name: (names.response || EMPTY_STRING) })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$7);
            const asn1 = compareSchema(schema, schema, ResponseBytes.schema({
                names: {
                    responseType: RESPONSE_TYPE,
                    response: RESPONSE
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.responseType = asn1.result.responseType.valueBlock.toString();
            this.response = asn1.result.response;
        }
        toSchema() {
            return (new Sequence({
                value: [
                    new ObjectIdentifier({ value: this.responseType }),
                    this.response
                ]
            }));
        }
        toJSON() {
            return {
                responseType: this.responseType,
                response: this.response.toJSON(),
            };
        }
    }
    ResponseBytes.CLASS_NAME = "ResponseBytes";

    const RESPONSE_STATUS = "responseStatus";
    const RESPONSE_BYTES = "responseBytes";
    class OCSPResponse extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.responseStatus = getParametersValue(parameters, RESPONSE_STATUS, OCSPResponse.defaultValues(RESPONSE_STATUS));
            if (RESPONSE_BYTES in parameters) {
                this.responseBytes = getParametersValue(parameters, RESPONSE_BYTES, OCSPResponse.defaultValues(RESPONSE_BYTES));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case RESPONSE_STATUS:
                    return new Enumerated();
                case RESPONSE_BYTES:
                    return new ResponseBytes();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case RESPONSE_STATUS:
                    return (memberValue.isEqual(OCSPResponse.defaultValues(memberName)));
                case RESPONSE_BYTES:
                    return ((ResponseBytes.compareWithDefault("responseType", memberValue.responseType)) &&
                        (ResponseBytes.compareWithDefault("response", memberValue.response)));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || "OCSPResponse"),
                value: [
                    new Enumerated({ name: (names.responseStatus || RESPONSE_STATUS) }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [
                            ResponseBytes.schema(names.responseBytes || {
                                names: {
                                    blockName: RESPONSE_BYTES
                                }
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, [
                RESPONSE_STATUS,
                RESPONSE_BYTES
            ]);
            const asn1 = compareSchema(schema, schema, OCSPResponse.schema());
            AsnError.assertSchema(asn1, this.className);
            this.responseStatus = asn1.result.responseStatus;
            if (RESPONSE_BYTES in asn1.result)
                this.responseBytes = new ResponseBytes({ schema: asn1.result.responseBytes });
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(this.responseStatus);
            if (this.responseBytes) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [this.responseBytes.toSchema()]
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                responseStatus: this.responseStatus.toJSON()
            };
            if (this.responseBytes) {
                res.responseBytes = this.responseBytes.toJSON();
            }
            return res;
        }
        async getCertificateStatus(certificate, issuerCertificate, crypto = getCrypto(true)) {
            let basicResponse;
            const result = {
                isForCertificate: false,
                status: 2
            };
            if (!this.responseBytes)
                return result;
            if (this.responseBytes.responseType !== id_PKIX_OCSP_Basic)
                return result;
            try {
                const asn1Basic = fromBER(this.responseBytes.response.valueBlock.valueHexView);
                AsnError.assert(asn1Basic, "Basic OCSP response");
                basicResponse = new BasicOCSPResponse({ schema: asn1Basic.result });
            }
            catch (ex) {
                return result;
            }
            return basicResponse.getCertificateStatus(certificate, issuerCertificate, crypto);
        }
        async sign(privateKey, hashAlgorithm, crypto = getCrypto(true)) {
            var _a;
            if (this.responseBytes && this.responseBytes.responseType === id_PKIX_OCSP_Basic) {
                const basicResponse = BasicOCSPResponse.fromBER(this.responseBytes.response.valueBlock.valueHexView);
                return basicResponse.sign(privateKey, hashAlgorithm, crypto);
            }
            throw new Error(`Unknown ResponseBytes type: ${((_a = this.responseBytes) === null || _a === void 0 ? void 0 : _a.responseType) || "Unknown"}`);
        }
        async verify(issuerCertificate = null, crypto = getCrypto(true)) {
            var _a;
            if ((RESPONSE_BYTES in this) === false)
                throw new Error("Empty ResponseBytes field");
            if (this.responseBytes && this.responseBytes.responseType === id_PKIX_OCSP_Basic) {
                const basicResponse = BasicOCSPResponse.fromBER(this.responseBytes.response.valueBlock.valueHexView);
                if (issuerCertificate !== null) {
                    if (!basicResponse.certs) {
                        basicResponse.certs = [];
                    }
                    basicResponse.certs.push(issuerCertificate);
                }
                return basicResponse.verify({}, crypto);
            }
            throw new Error(`Unknown ResponseBytes type: ${((_a = this.responseBytes) === null || _a === void 0 ? void 0 : _a.responseType) || "Unknown"}`);
        }
    }
    OCSPResponse.CLASS_NAME = "OCSPResponse";

    const TYPE = "type";
    const ATTRIBUTES = "attributes";
    const ENCODED_VALUE = "encodedValue";
    const CLEAR_PROPS$6 = [
        ATTRIBUTES
    ];
    class SignedAndUnsignedAttributes extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.type = getParametersValue(parameters, TYPE, SignedAndUnsignedAttributes.defaultValues(TYPE));
            this.attributes = getParametersValue(parameters, ATTRIBUTES, SignedAndUnsignedAttributes.defaultValues(ATTRIBUTES));
            this.encodedValue = getParametersValue(parameters, ENCODED_VALUE, SignedAndUnsignedAttributes.defaultValues(ENCODED_VALUE));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case TYPE:
                    return (-1);
                case ATTRIBUTES:
                    return [];
                case ENCODED_VALUE:
                    return EMPTY_BUFFER;
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case TYPE:
                    return (memberValue === SignedAndUnsignedAttributes.defaultValues(TYPE));
                case ATTRIBUTES:
                    return (memberValue.length === 0);
                case ENCODED_VALUE:
                    return (memberValue.byteLength === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Constructed({
                name: (names.blockName || EMPTY_STRING),
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: names.tagNumber || 0
                },
                value: [
                    new Repeated({
                        name: (names.attributes || EMPTY_STRING),
                        value: Attribute.schema()
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$6);
            const asn1 = compareSchema(schema, schema, SignedAndUnsignedAttributes.schema({
                names: {
                    tagNumber: this.type,
                    attributes: ATTRIBUTES
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.type = asn1.result.idBlock.tagNumber;
            this.encodedValue = BufferSourceConverter_1.toArrayBuffer(asn1.result.valueBeforeDecodeView);
            const encodedView = new Uint8Array(this.encodedValue);
            encodedView[0] = 0x31;
            if ((ATTRIBUTES in asn1.result) === false) {
                if (this.type === 0)
                    throw new Error("Wrong structure of SignedUnsignedAttributes");
                else
                    return;
            }
            this.attributes = Array.from(asn1.result.attributes, element => new Attribute({ schema: element }));
        }
        toSchema() {
            if (SignedAndUnsignedAttributes.compareWithDefault(TYPE, this.type) || SignedAndUnsignedAttributes.compareWithDefault(ATTRIBUTES, this.attributes))
                throw new Error("Incorrectly initialized \"SignedAndUnsignedAttributes\" class");
            return (new Constructed({
                optional: true,
                idBlock: {
                    tagClass: 3,
                    tagNumber: this.type
                },
                value: Array.from(this.attributes, o => o.toSchema())
            }));
        }
        toJSON() {
            if (SignedAndUnsignedAttributes.compareWithDefault(TYPE, this.type) || SignedAndUnsignedAttributes.compareWithDefault(ATTRIBUTES, this.attributes))
                throw new Error("Incorrectly initialized \"SignedAndUnsignedAttributes\" class");
            return {
                type: this.type,
                attributes: Array.from(this.attributes, o => o.toJSON())
            };
        }
    }
    SignedAndUnsignedAttributes.CLASS_NAME = "SignedAndUnsignedAttributes";

    const VERSION$4 = "version";
    const SID = "sid";
    const DIGEST_ALGORITHM = "digestAlgorithm";
    const SIGNED_ATTRS = "signedAttrs";
    const SIGNATURE_ALGORITHM = "signatureAlgorithm";
    const SIGNATURE = "signature";
    const UNSIGNED_ATTRS = "unsignedAttrs";
    const SIGNER_INFO = "SignerInfo";
    const SIGNER_INFO_VERSION = `${SIGNER_INFO}.${VERSION$4}`;
    const SIGNER_INFO_SID = `${SIGNER_INFO}.${SID}`;
    const SIGNER_INFO_DIGEST_ALGORITHM = `${SIGNER_INFO}.${DIGEST_ALGORITHM}`;
    const SIGNER_INFO_SIGNED_ATTRS = `${SIGNER_INFO}.${SIGNED_ATTRS}`;
    const SIGNER_INFO_SIGNATURE_ALGORITHM = `${SIGNER_INFO}.${SIGNATURE_ALGORITHM}`;
    const SIGNER_INFO_SIGNATURE = `${SIGNER_INFO}.${SIGNATURE}`;
    const SIGNER_INFO_UNSIGNED_ATTRS = `${SIGNER_INFO}.${UNSIGNED_ATTRS}`;
    const CLEAR_PROPS$5 = [
        SIGNER_INFO_VERSION,
        SIGNER_INFO_SID,
        SIGNER_INFO_DIGEST_ALGORITHM,
        SIGNER_INFO_SIGNED_ATTRS,
        SIGNER_INFO_SIGNATURE_ALGORITHM,
        SIGNER_INFO_SIGNATURE,
        SIGNER_INFO_UNSIGNED_ATTRS
    ];
    class SignerInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$4, SignerInfo.defaultValues(VERSION$4));
            this.sid = getParametersValue(parameters, SID, SignerInfo.defaultValues(SID));
            this.digestAlgorithm = getParametersValue(parameters, DIGEST_ALGORITHM, SignerInfo.defaultValues(DIGEST_ALGORITHM));
            if (SIGNED_ATTRS in parameters) {
                this.signedAttrs = getParametersValue(parameters, SIGNED_ATTRS, SignerInfo.defaultValues(SIGNED_ATTRS));
            }
            this.signatureAlgorithm = getParametersValue(parameters, SIGNATURE_ALGORITHM, SignerInfo.defaultValues(SIGNATURE_ALGORITHM));
            this.signature = getParametersValue(parameters, SIGNATURE, SignerInfo.defaultValues(SIGNATURE));
            if (UNSIGNED_ATTRS in parameters) {
                this.unsignedAttrs = getParametersValue(parameters, UNSIGNED_ATTRS, SignerInfo.defaultValues(UNSIGNED_ATTRS));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$4:
                    return 0;
                case SID:
                    return new Any();
                case DIGEST_ALGORITHM:
                    return new AlgorithmIdentifier();
                case SIGNED_ATTRS:
                    return new SignedAndUnsignedAttributes({ type: 0 });
                case SIGNATURE_ALGORITHM:
                    return new AlgorithmIdentifier();
                case SIGNATURE:
                    return new OctetString();
                case UNSIGNED_ATTRS:
                    return new SignedAndUnsignedAttributes({ type: 1 });
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VERSION$4:
                    return (SignerInfo.defaultValues(VERSION$4) === memberValue);
                case SID:
                    return (memberValue instanceof Any);
                case DIGEST_ALGORITHM:
                    if ((memberValue instanceof AlgorithmIdentifier) === false)
                        return false;
                    return memberValue.isEqual(SignerInfo.defaultValues(DIGEST_ALGORITHM));
                case SIGNED_ATTRS:
                    return ((SignedAndUnsignedAttributes.compareWithDefault("type", memberValue.type))
                        && (SignedAndUnsignedAttributes.compareWithDefault("attributes", memberValue.attributes))
                        && (SignedAndUnsignedAttributes.compareWithDefault("encodedValue", memberValue.encodedValue)));
                case SIGNATURE_ALGORITHM:
                    if ((memberValue instanceof AlgorithmIdentifier) === false)
                        return false;
                    return memberValue.isEqual(SignerInfo.defaultValues(SIGNATURE_ALGORITHM));
                case SIGNATURE:
                case UNSIGNED_ATTRS:
                    return ((SignedAndUnsignedAttributes.compareWithDefault("type", memberValue.type))
                        && (SignedAndUnsignedAttributes.compareWithDefault("attributes", memberValue.attributes))
                        && (SignedAndUnsignedAttributes.compareWithDefault("encodedValue", memberValue.encodedValue)));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: SIGNER_INFO,
                value: [
                    new Integer({ name: (names.version || SIGNER_INFO_VERSION) }),
                    new Choice({
                        value: [
                            IssuerAndSerialNumber.schema(names.sidSchema || {
                                names: {
                                    blockName: SIGNER_INFO_SID
                                }
                            }),
                            new Choice({
                                value: [
                                    new Constructed({
                                        optional: true,
                                        name: (names.sid || SIGNER_INFO_SID),
                                        idBlock: {
                                            tagClass: 3,
                                            tagNumber: 0
                                        },
                                        value: [new OctetString()]
                                    }),
                                    new Primitive({
                                        optional: true,
                                        name: (names.sid || SIGNER_INFO_SID),
                                        idBlock: {
                                            tagClass: 3,
                                            tagNumber: 0
                                        }
                                    }),
                                ]
                            }),
                        ]
                    }),
                    AlgorithmIdentifier.schema(names.digestAlgorithm || {
                        names: {
                            blockName: SIGNER_INFO_DIGEST_ALGORITHM
                        }
                    }),
                    SignedAndUnsignedAttributes.schema(names.signedAttrs || {
                        names: {
                            blockName: SIGNER_INFO_SIGNED_ATTRS,
                            tagNumber: 0
                        }
                    }),
                    AlgorithmIdentifier.schema(names.signatureAlgorithm || {
                        names: {
                            blockName: SIGNER_INFO_SIGNATURE_ALGORITHM
                        }
                    }),
                    new OctetString({ name: (names.signature || SIGNER_INFO_SIGNATURE) }),
                    SignedAndUnsignedAttributes.schema(names.unsignedAttrs || {
                        names: {
                            blockName: SIGNER_INFO_UNSIGNED_ATTRS,
                            tagNumber: 1
                        }
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$5);
            const asn1 = compareSchema(schema, schema, SignerInfo.schema());
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result[SIGNER_INFO_VERSION].valueBlock.valueDec;
            const currentSid = asn1.result[SIGNER_INFO_SID];
            if (currentSid.idBlock.tagClass === 1)
                this.sid = new IssuerAndSerialNumber({ schema: currentSid });
            else
                this.sid = currentSid;
            this.digestAlgorithm = new AlgorithmIdentifier({ schema: asn1.result[SIGNER_INFO_DIGEST_ALGORITHM] });
            if (SIGNER_INFO_SIGNED_ATTRS in asn1.result)
                this.signedAttrs = new SignedAndUnsignedAttributes({ type: 0, schema: asn1.result[SIGNER_INFO_SIGNED_ATTRS] });
            this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result[SIGNER_INFO_SIGNATURE_ALGORITHM] });
            this.signature = asn1.result[SIGNER_INFO_SIGNATURE];
            if (SIGNER_INFO_UNSIGNED_ATTRS in asn1.result)
                this.unsignedAttrs = new SignedAndUnsignedAttributes({ type: 1, schema: asn1.result[SIGNER_INFO_UNSIGNED_ATTRS] });
        }
        toSchema() {
            if (SignerInfo.compareWithDefault(SID, this.sid))
                throw new Error("Incorrectly initialized \"SignerInfo\" class");
            const outputArray = [];
            outputArray.push(new Integer({ value: this.version }));
            if (this.sid instanceof IssuerAndSerialNumber)
                outputArray.push(this.sid.toSchema());
            else
                outputArray.push(this.sid);
            outputArray.push(this.digestAlgorithm.toSchema());
            if (this.signedAttrs) {
                if (SignerInfo.compareWithDefault(SIGNED_ATTRS, this.signedAttrs) === false)
                    outputArray.push(this.signedAttrs.toSchema());
            }
            outputArray.push(this.signatureAlgorithm.toSchema());
            outputArray.push(this.signature);
            if (this.unsignedAttrs) {
                if (SignerInfo.compareWithDefault(UNSIGNED_ATTRS, this.unsignedAttrs) === false)
                    outputArray.push(this.unsignedAttrs.toSchema());
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            if (SignerInfo.compareWithDefault(SID, this.sid)) {
                throw new Error("Incorrectly initialized \"SignerInfo\" class");
            }
            const res = {
                version: this.version,
                digestAlgorithm: this.digestAlgorithm.toJSON(),
                signatureAlgorithm: this.signatureAlgorithm.toJSON(),
                signature: this.signature.toJSON(),
            };
            if (!(this.sid instanceof Any))
                res.sid = this.sid.toJSON();
            if (this.signedAttrs && SignerInfo.compareWithDefault(SIGNED_ATTRS, this.signedAttrs) === false) {
                res.signedAttrs = this.signedAttrs.toJSON();
            }
            if (this.unsignedAttrs && SignerInfo.compareWithDefault(UNSIGNED_ATTRS, this.unsignedAttrs) === false) {
                res.unsignedAttrs = this.unsignedAttrs.toJSON();
            }
            return res;
        }
    }
    SignerInfo.CLASS_NAME = "SignerInfo";

    const VERSION$3 = "version";
    const POLICY = "policy";
    const MESSAGE_IMPRINT$1 = "messageImprint";
    const SERIAL_NUMBER = "serialNumber";
    const GEN_TIME = "genTime";
    const ORDERING = "ordering";
    const NONCE$1 = "nonce";
    const ACCURACY = "accuracy";
    const TSA = "tsa";
    const EXTENSIONS$1 = "extensions";
    const TST_INFO = "TSTInfo";
    const TST_INFO_VERSION = `${TST_INFO}.${VERSION$3}`;
    const TST_INFO_POLICY = `${TST_INFO}.${POLICY}`;
    const TST_INFO_MESSAGE_IMPRINT = `${TST_INFO}.${MESSAGE_IMPRINT$1}`;
    const TST_INFO_SERIAL_NUMBER = `${TST_INFO}.${SERIAL_NUMBER}`;
    const TST_INFO_GEN_TIME = `${TST_INFO}.${GEN_TIME}`;
    const TST_INFO_ACCURACY = `${TST_INFO}.${ACCURACY}`;
    const TST_INFO_ORDERING = `${TST_INFO}.${ORDERING}`;
    const TST_INFO_NONCE = `${TST_INFO}.${NONCE$1}`;
    const TST_INFO_TSA = `${TST_INFO}.${TSA}`;
    const TST_INFO_EXTENSIONS = `${TST_INFO}.${EXTENSIONS$1}`;
    const CLEAR_PROPS$4 = [
        TST_INFO_VERSION,
        TST_INFO_POLICY,
        TST_INFO_MESSAGE_IMPRINT,
        TST_INFO_SERIAL_NUMBER,
        TST_INFO_GEN_TIME,
        TST_INFO_ACCURACY,
        TST_INFO_ORDERING,
        TST_INFO_NONCE,
        TST_INFO_TSA,
        TST_INFO_EXTENSIONS
    ];
    class TSTInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$3, TSTInfo.defaultValues(VERSION$3));
            this.policy = getParametersValue(parameters, POLICY, TSTInfo.defaultValues(POLICY));
            this.messageImprint = getParametersValue(parameters, MESSAGE_IMPRINT$1, TSTInfo.defaultValues(MESSAGE_IMPRINT$1));
            this.serialNumber = getParametersValue(parameters, SERIAL_NUMBER, TSTInfo.defaultValues(SERIAL_NUMBER));
            this.genTime = getParametersValue(parameters, GEN_TIME, TSTInfo.defaultValues(GEN_TIME));
            if (ACCURACY in parameters) {
                this.accuracy = getParametersValue(parameters, ACCURACY, TSTInfo.defaultValues(ACCURACY));
            }
            if (ORDERING in parameters) {
                this.ordering = getParametersValue(parameters, ORDERING, TSTInfo.defaultValues(ORDERING));
            }
            if (NONCE$1 in parameters) {
                this.nonce = getParametersValue(parameters, NONCE$1, TSTInfo.defaultValues(NONCE$1));
            }
            if (TSA in parameters) {
                this.tsa = getParametersValue(parameters, TSA, TSTInfo.defaultValues(TSA));
            }
            if (EXTENSIONS$1 in parameters) {
                this.extensions = getParametersValue(parameters, EXTENSIONS$1, TSTInfo.defaultValues(EXTENSIONS$1));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$3:
                    return 0;
                case POLICY:
                    return EMPTY_STRING;
                case MESSAGE_IMPRINT$1:
                    return new MessageImprint();
                case SERIAL_NUMBER:
                    return new Integer();
                case GEN_TIME:
                    return new Date(0, 0, 0);
                case ACCURACY:
                    return new Accuracy();
                case ORDERING:
                    return false;
                case NONCE$1:
                    return new Integer();
                case TSA:
                    return new GeneralName();
                case EXTENSIONS$1:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VERSION$3:
                case POLICY:
                case GEN_TIME:
                case ORDERING:
                    return (memberValue === TSTInfo.defaultValues(ORDERING));
                case MESSAGE_IMPRINT$1:
                    return ((MessageImprint.compareWithDefault(HASH_ALGORITHM, memberValue.hashAlgorithm)) &&
                        (MessageImprint.compareWithDefault(HASHED_MESSAGE, memberValue.hashedMessage)));
                case SERIAL_NUMBER:
                case NONCE$1:
                    return (memberValue.isEqual(TSTInfo.defaultValues(NONCE$1)));
                case ACCURACY:
                    return ((Accuracy.compareWithDefault(SECONDS, memberValue.seconds)) &&
                        (Accuracy.compareWithDefault(MILLIS, memberValue.millis)) &&
                        (Accuracy.compareWithDefault(MICROS, memberValue.micros)));
                case TSA:
                    return ((GeneralName.compareWithDefault(TYPE$4, memberValue.type)) &&
                        (GeneralName.compareWithDefault(VALUE$5, memberValue.value)));
                case EXTENSIONS$1:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || TST_INFO),
                value: [
                    new Integer({ name: (names.version || TST_INFO_VERSION) }),
                    new ObjectIdentifier({ name: (names.policy || TST_INFO_POLICY) }),
                    MessageImprint.schema(names.messageImprint || {
                        names: {
                            blockName: TST_INFO_MESSAGE_IMPRINT
                        }
                    }),
                    new Integer({ name: (names.serialNumber || TST_INFO_SERIAL_NUMBER) }),
                    new GeneralizedTime({ name: (names.genTime || TST_INFO_GEN_TIME) }),
                    Accuracy.schema(names.accuracy || {
                        names: {
                            blockName: TST_INFO_ACCURACY
                        }
                    }),
                    new Boolean$1({
                        name: (names.ordering || TST_INFO_ORDERING),
                        optional: true
                    }),
                    new Integer({
                        name: (names.nonce || TST_INFO_NONCE),
                        optional: true
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [GeneralName.schema(names.tsa || {
                                names: {
                                    blockName: TST_INFO_TSA
                                }
                            })]
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: [
                            new Repeated({
                                name: (names.extensions || TST_INFO_EXTENSIONS),
                                value: Extension.schema(names.extension || {})
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$4);
            const asn1 = compareSchema(schema, schema, TSTInfo.schema());
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result[TST_INFO_VERSION].valueBlock.valueDec;
            this.policy = asn1.result[TST_INFO_POLICY].valueBlock.toString();
            this.messageImprint = new MessageImprint({ schema: asn1.result[TST_INFO_MESSAGE_IMPRINT] });
            this.serialNumber = asn1.result[TST_INFO_SERIAL_NUMBER];
            this.genTime = asn1.result[TST_INFO_GEN_TIME].toDate();
            if (TST_INFO_ACCURACY in asn1.result)
                this.accuracy = new Accuracy({ schema: asn1.result[TST_INFO_ACCURACY] });
            if (TST_INFO_ORDERING in asn1.result)
                this.ordering = asn1.result[TST_INFO_ORDERING].valueBlock.value;
            if (TST_INFO_NONCE in asn1.result)
                this.nonce = asn1.result[TST_INFO_NONCE];
            if (TST_INFO_TSA in asn1.result)
                this.tsa = new GeneralName({ schema: asn1.result[TST_INFO_TSA] });
            if (TST_INFO_EXTENSIONS in asn1.result)
                this.extensions = Array.from(asn1.result[TST_INFO_EXTENSIONS], element => new Extension({ schema: element }));
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new Integer({ value: this.version }));
            outputArray.push(new ObjectIdentifier({ value: this.policy }));
            outputArray.push(this.messageImprint.toSchema());
            outputArray.push(this.serialNumber);
            outputArray.push(new GeneralizedTime({ valueDate: this.genTime }));
            if (this.accuracy)
                outputArray.push(this.accuracy.toSchema());
            if (this.ordering !== undefined)
                outputArray.push(new Boolean$1({ value: this.ordering }));
            if (this.nonce)
                outputArray.push(this.nonce);
            if (this.tsa) {
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: [this.tsa.toSchema()]
                }));
            }
            if (this.extensions) {
                outputArray.push(new Constructed({
                    optional: true,
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: Array.from(this.extensions, o => o.toSchema())
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                version: this.version,
                policy: this.policy,
                messageImprint: this.messageImprint.toJSON(),
                serialNumber: this.serialNumber.toJSON(),
                genTime: this.genTime
            };
            if (this.accuracy)
                res.accuracy = this.accuracy.toJSON();
            if (this.ordering !== undefined)
                res.ordering = this.ordering;
            if (this.nonce)
                res.nonce = this.nonce.toJSON();
            if (this.tsa)
                res.tsa = this.tsa.toJSON();
            if (this.extensions)
                res.extensions = Array.from(this.extensions, o => o.toJSON());
            return res;
        }
        async verify(params, crypto = getCrypto(true)) {
            if (!params.data) {
                throw new Error("\"data\" is a mandatory attribute for TST_INFO verification");
            }
            const data = params.data;
            if (params.notBefore) {
                if (this.genTime < params.notBefore)
                    throw new Error("Generation time for TSTInfo object is less than notBefore value");
            }
            if (params.notAfter) {
                if (this.genTime > params.notAfter)
                    throw new Error("Generation time for TSTInfo object is more than notAfter value");
            }
            const shaAlgorithm = crypto.getAlgorithmByOID(this.messageImprint.hashAlgorithm.algorithmId, true, "MessageImprint.hashAlgorithm");
            const hash = await crypto.digest(shaAlgorithm.name, new Uint8Array(data));
            return BufferSourceConverter_1.isEqual(hash, this.messageImprint.hashedMessage.valueBlock.valueHexView);
        }
    }
    TSTInfo.CLASS_NAME = "TSTInfo";

    const VERSION$2 = "version";
    const DIGEST_ALGORITHMS = "digestAlgorithms";
    const ENCAP_CONTENT_INFO = "encapContentInfo";
    const CERTIFICATES = "certificates";
    const CRLS = "crls";
    const SIGNER_INFOS = "signerInfos";
    const OCSPS = "ocsps";
    const SIGNED_DATA = "SignedData";
    const SIGNED_DATA_VERSION = `${SIGNED_DATA}.${VERSION$2}`;
    const SIGNED_DATA_DIGEST_ALGORITHMS = `${SIGNED_DATA}.${DIGEST_ALGORITHMS}`;
    const SIGNED_DATA_ENCAP_CONTENT_INFO = `${SIGNED_DATA}.${ENCAP_CONTENT_INFO}`;
    const SIGNED_DATA_CERTIFICATES = `${SIGNED_DATA}.${CERTIFICATES}`;
    const SIGNED_DATA_CRLS = `${SIGNED_DATA}.${CRLS}`;
    const SIGNED_DATA_SIGNER_INFOS = `${SIGNED_DATA}.${SIGNER_INFOS}`;
    const CLEAR_PROPS$3 = [
        SIGNED_DATA_VERSION,
        SIGNED_DATA_DIGEST_ALGORITHMS,
        SIGNED_DATA_ENCAP_CONTENT_INFO,
        SIGNED_DATA_CERTIFICATES,
        SIGNED_DATA_CRLS,
        SIGNED_DATA_SIGNER_INFOS
    ];
    class SignedDataVerifyError extends Error {
        constructor({ message, code = 0, date = new Date(), signatureVerified = null, signerCertificate = null, signerCertificateVerified = null, timestampSerial = null, }) {
            super(message);
            this.name = "SignedDataVerifyError";
            this.date = date;
            this.code = code;
            this.timestampSerial = timestampSerial;
            this.signatureVerified = signatureVerified;
            this.signerCertificate = signerCertificate;
            this.signerCertificateVerified = signerCertificateVerified;
        }
    }
    class SignedData extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$2, SignedData.defaultValues(VERSION$2));
            this.digestAlgorithms = getParametersValue(parameters, DIGEST_ALGORITHMS, SignedData.defaultValues(DIGEST_ALGORITHMS));
            this.encapContentInfo = getParametersValue(parameters, ENCAP_CONTENT_INFO, SignedData.defaultValues(ENCAP_CONTENT_INFO));
            if (CERTIFICATES in parameters) {
                this.certificates = getParametersValue(parameters, CERTIFICATES, SignedData.defaultValues(CERTIFICATES));
            }
            if (CRLS in parameters) {
                this.crls = getParametersValue(parameters, CRLS, SignedData.defaultValues(CRLS));
            }
            if (OCSPS in parameters) {
                this.ocsps = getParametersValue(parameters, OCSPS, SignedData.defaultValues(OCSPS));
            }
            this.signerInfos = getParametersValue(parameters, SIGNER_INFOS, SignedData.defaultValues(SIGNER_INFOS));
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$2:
                    return 0;
                case DIGEST_ALGORITHMS:
                    return [];
                case ENCAP_CONTENT_INFO:
                    return new EncapsulatedContentInfo();
                case CERTIFICATES:
                    return [];
                case CRLS:
                    return [];
                case OCSPS:
                    return [];
                case SIGNER_INFOS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VERSION$2:
                    return (memberValue === SignedData.defaultValues(VERSION$2));
                case ENCAP_CONTENT_INFO:
                    return EncapsulatedContentInfo.compareWithDefault("eContentType", memberValue.eContentType) &&
                        EncapsulatedContentInfo.compareWithDefault("eContent", memberValue.eContent);
                case DIGEST_ALGORITHMS:
                case CERTIFICATES:
                case CRLS:
                case OCSPS:
                case SIGNER_INFOS:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            if (names.optional === undefined) {
                names.optional = false;
            }
            return (new Sequence({
                name: (names.blockName || SIGNED_DATA),
                optional: names.optional,
                value: [
                    new Integer({ name: (names.version || SIGNED_DATA_VERSION) }),
                    new Set$1({
                        value: [
                            new Repeated({
                                name: (names.digestAlgorithms || SIGNED_DATA_DIGEST_ALGORITHMS),
                                value: AlgorithmIdentifier.schema()
                            })
                        ]
                    }),
                    EncapsulatedContentInfo.schema(names.encapContentInfo || {
                        names: {
                            blockName: SIGNED_DATA_ENCAP_CONTENT_INFO
                        }
                    }),
                    new Constructed({
                        name: (names.certificates || SIGNED_DATA_CERTIFICATES),
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: CertificateSet.schema().valueBlock.value
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 1
                        },
                        value: RevocationInfoChoices.schema(names.crls || {
                            names: {
                                crls: SIGNED_DATA_CRLS
                            }
                        }).valueBlock.value
                    }),
                    new Set$1({
                        value: [
                            new Repeated({
                                name: (names.signerInfos || SIGNED_DATA_SIGNER_INFOS),
                                value: SignerInfo.schema()
                            })
                        ]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$3);
            const asn1 = compareSchema(schema, schema, SignedData.schema());
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result[SIGNED_DATA_VERSION].valueBlock.valueDec;
            if (SIGNED_DATA_DIGEST_ALGORITHMS in asn1.result)
                this.digestAlgorithms = Array.from(asn1.result[SIGNED_DATA_DIGEST_ALGORITHMS], algorithm => new AlgorithmIdentifier({ schema: algorithm }));
            this.encapContentInfo = new EncapsulatedContentInfo({ schema: asn1.result[SIGNED_DATA_ENCAP_CONTENT_INFO] });
            if (SIGNED_DATA_CERTIFICATES in asn1.result) {
                const certificateSet = new CertificateSet({
                    schema: new Set$1({
                        value: asn1.result[SIGNED_DATA_CERTIFICATES].valueBlock.value
                    })
                });
                this.certificates = certificateSet.certificates.slice(0);
            }
            if (SIGNED_DATA_CRLS in asn1.result) {
                this.crls = Array.from(asn1.result[SIGNED_DATA_CRLS], (crl) => {
                    if (crl.idBlock.tagClass === 1)
                        return new CertificateRevocationList({ schema: crl });
                    crl.idBlock.tagClass = 1;
                    crl.idBlock.tagNumber = 16;
                    return new OtherRevocationInfoFormat({ schema: crl });
                });
            }
            if (SIGNED_DATA_SIGNER_INFOS in asn1.result)
                this.signerInfos = Array.from(asn1.result[SIGNED_DATA_SIGNER_INFOS], signerInfoSchema => new SignerInfo({ schema: signerInfoSchema }));
        }
        toSchema(encodeFlag = false) {
            const outputArray = [];
            if ((this.certificates && this.certificates.length && this.certificates.some(o => o instanceof OtherCertificateFormat))
                || (this.crls && this.crls.length && this.crls.some(o => o instanceof OtherRevocationInfoFormat))) {
                this.version = 5;
            }
            else if (this.certificates && this.certificates.length && this.certificates.some(o => o instanceof AttributeCertificateV2)) {
                this.version = 4;
            }
            else if ((this.certificates && this.certificates.length && this.certificates.some(o => o instanceof AttributeCertificateV1))
                || this.signerInfos.some(o => o.version === 3)
                || this.encapContentInfo.eContentType !== SignedData.ID_DATA) {
                this.version = 3;
            }
            else {
                this.version = 1;
            }
            outputArray.push(new Integer({ value: this.version }));
            outputArray.push(new Set$1({
                value: Array.from(this.digestAlgorithms, algorithm => algorithm.toSchema())
            }));
            outputArray.push(this.encapContentInfo.toSchema());
            if (this.certificates) {
                const certificateSet = new CertificateSet({ certificates: this.certificates });
                const certificateSetSchema = certificateSet.toSchema();
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: certificateSetSchema.valueBlock.value
                }));
            }
            if (this.crls) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                    },
                    value: Array.from(this.crls, crl => {
                        if (crl instanceof OtherRevocationInfoFormat) {
                            const crlSchema = crl.toSchema();
                            crlSchema.idBlock.tagClass = 3;
                            crlSchema.idBlock.tagNumber = 1;
                            return crlSchema;
                        }
                        return crl.toSchema(encodeFlag);
                    })
                }));
            }
            outputArray.push(new Set$1({
                value: Array.from(this.signerInfos, signerInfo => signerInfo.toSchema())
            }));
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                version: this.version,
                digestAlgorithms: Array.from(this.digestAlgorithms, algorithm => algorithm.toJSON()),
                encapContentInfo: this.encapContentInfo.toJSON(),
                signerInfos: Array.from(this.signerInfos, signerInfo => signerInfo.toJSON()),
            };
            if (this.certificates) {
                res.certificates = Array.from(this.certificates, certificate => certificate.toJSON());
            }
            if (this.crls) {
                res.crls = Array.from(this.crls, crl => crl.toJSON());
            }
            return res;
        }
        async verify({ signer = (-1), data = (EMPTY_BUFFER), trustedCerts = [], checkDate = (new Date()), checkChain = false, passedWhenNotRevValues = false, extendedMode = false, findOrigin = null, findIssuer = null } = {}, crypto = getCrypto(true)) {
            let signerCert = null;
            let timestampSerial = null;
            try {
                let messageDigestValue = EMPTY_BUFFER;
                let shaAlgorithm = EMPTY_STRING;
                let certificatePath = [];
                const signerInfo = this.signerInfos[signer];
                if (!signerInfo) {
                    throw new SignedDataVerifyError({
                        date: checkDate,
                        code: 1,
                        message: "Unable to get signer by supplied index",
                    });
                }
                if (!this.certificates) {
                    throw new SignedDataVerifyError({
                        date: checkDate,
                        code: 2,
                        message: "No certificates attached to this signed data",
                    });
                }
                if (signerInfo.sid instanceof IssuerAndSerialNumber) {
                    for (const certificate of this.certificates) {
                        if (!(certificate instanceof Certificate))
                            continue;
                        if ((certificate.issuer.isEqual(signerInfo.sid.issuer)) &&
                            (certificate.serialNumber.isEqual(signerInfo.sid.serialNumber))) {
                            signerCert = certificate;
                            break;
                        }
                    }
                }
                else {
                    const sid = signerInfo.sid;
                    const keyId = sid.idBlock.isConstructed
                        ? sid.valueBlock.value[0].valueBlock.valueHex
                        : sid.valueBlock.valueHex;
                    for (const certificate of this.certificates) {
                        if (!(certificate instanceof Certificate)) {
                            continue;
                        }
                        const digest = await crypto.digest({ name: "sha-1" }, certificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);
                        if (isEqualBuffer(digest, keyId)) {
                            signerCert = certificate;
                            break;
                        }
                    }
                }
                if (!signerCert) {
                    throw new SignedDataVerifyError({
                        date: checkDate,
                        code: 3,
                        message: "Unable to find signer certificate",
                    });
                }
                if (this.encapContentInfo.eContentType === id_eContentType_TSTInfo) {
                    if (!this.encapContentInfo.eContent) {
                        throw new SignedDataVerifyError({
                            date: checkDate,
                            code: 15,
                            message: "Error during verification: TSTInfo eContent is empty",
                            signatureVerified: null,
                            signerCertificate: signerCert,
                            timestampSerial,
                            signerCertificateVerified: true
                        });
                    }
                    let tstInfo;
                    try {
                        tstInfo = TSTInfo.fromBER(this.encapContentInfo.eContent.valueBlock.valueHexView);
                    }
                    catch (ex) {
                        throw new SignedDataVerifyError({
                            date: checkDate,
                            code: 15,
                            message: "Error during verification: TSTInfo wrong ASN.1 schema ",
                            signatureVerified: null,
                            signerCertificate: signerCert,
                            timestampSerial,
                            signerCertificateVerified: true
                        });
                    }
                    checkDate = tstInfo.genTime;
                    timestampSerial = tstInfo.serialNumber.valueBlock.valueHexView.slice();
                    if (data.byteLength === 0) {
                        throw new SignedDataVerifyError({
                            date: checkDate,
                            code: 4,
                            message: "Missed detached data input array",
                        });
                    }
                    if (!(await tstInfo.verify({ data }, crypto))) {
                        throw new SignedDataVerifyError({
                            date: checkDate,
                            code: 15,
                            message: "Error during verification: TSTInfo verification is failed",
                            signatureVerified: null,
                            signerCertificate: signerCert,
                            timestampSerial,
                            signerCertificateVerified: true
                        });
                    }
                }
                if (checkChain) {
                    const certs = this.certificates.filter(certificate => (certificate instanceof Certificate && !!checkCA(certificate, signerCert)));
                    const chainParams = {
                        checkDate,
                        certs,
                        trustedCerts,
                    };
                    if (findIssuer) {
                        chainParams.findIssuer = findIssuer;
                    }
                    if (findOrigin) {
                        chainParams.findOrigin = findOrigin;
                    }
                    const chainEngine = new CertificateChainValidationEngine(chainParams);
                    chainEngine.certs.push(signerCert);
                    if (this.crls) {
                        for (const crl of this.crls) {
                            if ("thisUpdate" in crl)
                                chainEngine.crls.push(crl);
                            else {
                                if (crl.otherRevInfoFormat === id_PKIX_OCSP_Basic)
                                    chainEngine.ocsps.push(new BasicOCSPResponse({ schema: crl.otherRevInfo }));
                            }
                        }
                    }
                    if (this.ocsps) {
                        chainEngine.ocsps.push(...(this.ocsps));
                    }
                    const verificationResult = await chainEngine.verify({ passedWhenNotRevValues }, crypto)
                        .catch(e => {
                        throw new SignedDataVerifyError({
                            date: checkDate,
                            code: 5,
                            message: `Validation of signer's certificate failed with error: ${((e instanceof Object) ? e.resultMessage : e)}`,
                            signerCertificate: signerCert,
                            signerCertificateVerified: false
                        });
                    });
                    if (verificationResult.certificatePath) {
                        certificatePath = verificationResult.certificatePath;
                    }
                    if (!verificationResult.result)
                        throw new SignedDataVerifyError({
                            date: checkDate,
                            code: 5,
                            message: `Validation of signer's certificate failed: ${verificationResult.resultMessage}`,
                            signerCertificate: signerCert,
                            signerCertificateVerified: false
                        });
                }
                const signerInfoHashAlgorithm = crypto.getAlgorithmByOID(signerInfo.digestAlgorithm.algorithmId);
                if (!("name" in signerInfoHashAlgorithm)) {
                    throw new SignedDataVerifyError({
                        date: checkDate,
                        code: 7,
                        message: `Unsupported signature algorithm: ${signerInfo.digestAlgorithm.algorithmId}`,
                        signerCertificate: signerCert,
                        signerCertificateVerified: true
                    });
                }
                shaAlgorithm = signerInfoHashAlgorithm.name;
                const eContent = this.encapContentInfo.eContent;
                if (eContent) {
                    if ((eContent.idBlock.tagClass === 1) &&
                        (eContent.idBlock.tagNumber === 4)) {
                        data = eContent.getValue();
                    }
                    else
                        data = eContent.valueBlock.valueBeforeDecodeView;
                }
                else {
                    if (data.byteLength === 0) {
                        throw new SignedDataVerifyError({
                            date: checkDate,
                            code: 8,
                            message: "Missed detached data input array",
                            signerCertificate: signerCert,
                            signerCertificateVerified: true
                        });
                    }
                }
                if (signerInfo.signedAttrs) {
                    let foundContentType = false;
                    let foundMessageDigest = false;
                    for (const attribute of signerInfo.signedAttrs.attributes) {
                        if (attribute.type === "1.2.840.113549.1.9.3")
                            foundContentType = true;
                        if (attribute.type === "1.2.840.113549.1.9.4") {
                            foundMessageDigest = true;
                            messageDigestValue = attribute.values[0].valueBlock.valueHex;
                        }
                        if (foundContentType && foundMessageDigest)
                            break;
                    }
                    if (foundContentType === false) {
                        throw new SignedDataVerifyError({
                            date: checkDate,
                            code: 9,
                            message: "Attribute \"content-type\" is a mandatory attribute for \"signed attributes\"",
                            signerCertificate: signerCert,
                            signerCertificateVerified: true
                        });
                    }
                    if (foundMessageDigest === false) {
                        throw new SignedDataVerifyError({
                            date: checkDate,
                            code: 10,
                            message: "Attribute \"message-digest\" is a mandatory attribute for \"signed attributes\"",
                            signatureVerified: null,
                            signerCertificate: signerCert,
                            signerCertificateVerified: true
                        });
                    }
                }
                if (signerInfo.signedAttrs) {
                    const messageDigest = await crypto.digest(shaAlgorithm, new Uint8Array(data));
                    if (!isEqualBuffer(messageDigest, messageDigestValue)) {
                        throw new SignedDataVerifyError({
                            date: checkDate,
                            code: 15,
                            message: "Error during verification: Message digest doesn't match",
                            signatureVerified: null,
                            signerCertificate: signerCert,
                            timestampSerial,
                            signerCertificateVerified: true
                        });
                    }
                    data = signerInfo.signedAttrs.encodedValue;
                }
                const verifyResult = await crypto.verifyWithPublicKey(data, signerInfo.signature, signerCert.subjectPublicKeyInfo, signerCert.signatureAlgorithm, shaAlgorithm);
                if (extendedMode) {
                    return {
                        date: checkDate,
                        code: 14,
                        message: EMPTY_STRING,
                        signatureVerified: verifyResult,
                        signerCertificate: signerCert,
                        timestampSerial,
                        signerCertificateVerified: true,
                        certificatePath
                    };
                }
                else {
                    return verifyResult;
                }
            }
            catch (e) {
                if (e instanceof SignedDataVerifyError) {
                    throw e;
                }
                throw new SignedDataVerifyError({
                    date: checkDate,
                    code: 15,
                    message: `Error during verification: ${e instanceof Error ? e.message : e}`,
                    signatureVerified: null,
                    signerCertificate: signerCert,
                    timestampSerial,
                    signerCertificateVerified: true
                });
            }
        }
        async sign(privateKey, signerIndex, hashAlgorithm = "SHA-1", data = (EMPTY_BUFFER), crypto = getCrypto(true)) {
            if (!privateKey)
                throw new Error("Need to provide a private key for signing");
            const hashAlgorithmOID = crypto.getOIDByAlgorithm({ name: hashAlgorithm }, true, "hashAlgorithm");
            if ((this.digestAlgorithms.filter(algorithm => algorithm.algorithmId === hashAlgorithmOID)).length === 0) {
                this.digestAlgorithms.push(new AlgorithmIdentifier({
                    algorithmId: hashAlgorithmOID,
                    algorithmParams: new Null()
                }));
            }
            const signerInfo = this.signerInfos[signerIndex];
            if (!signerInfo) {
                throw new RangeError("SignerInfo index is out of range");
            }
            signerInfo.digestAlgorithm = new AlgorithmIdentifier({
                algorithmId: hashAlgorithmOID,
                algorithmParams: new Null()
            });
            const signatureParams = await crypto.getSignatureParameters(privateKey, hashAlgorithm);
            const parameters = signatureParams.parameters;
            signerInfo.signatureAlgorithm = signatureParams.signatureAlgorithm;
            if (signerInfo.signedAttrs) {
                if (signerInfo.signedAttrs.encodedValue.byteLength !== 0)
                    data = signerInfo.signedAttrs.encodedValue;
                else {
                    data = signerInfo.signedAttrs.toSchema().toBER();
                    const view = BufferSourceConverter_1.toUint8Array(data);
                    view[0] = 0x31;
                }
            }
            else {
                const eContent = this.encapContentInfo.eContent;
                if (eContent) {
                    if ((eContent.idBlock.tagClass === 1) &&
                        (eContent.idBlock.tagNumber === 4)) {
                        data = eContent.getValue();
                    }
                    else
                        data = eContent.valueBlock.valueBeforeDecodeView;
                }
                else {
                    if (data.byteLength === 0)
                        throw new Error("Missed detached data input array");
                }
            }
            const signature = await crypto.signWithPrivateKey(data, privateKey, parameters);
            signerInfo.signature = new OctetString({ valueHex: signature });
        }
    }
    SignedData.CLASS_NAME = "SignedData";
    SignedData.ID_DATA = id_ContentType_Data;

    const VERSION$1 = "version";
    const AUTH_SAFE = "authSafe";
    const MAC_DATA = "macData";
    const PARSED_VALUE = "parsedValue";
    const CLERA_PROPS = [
        VERSION$1,
        AUTH_SAFE,
        MAC_DATA
    ];
    class PFX extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION$1, PFX.defaultValues(VERSION$1));
            this.authSafe = getParametersValue(parameters, AUTH_SAFE, PFX.defaultValues(AUTH_SAFE));
            if (MAC_DATA in parameters) {
                this.macData = getParametersValue(parameters, MAC_DATA, PFX.defaultValues(MAC_DATA));
            }
            if (PARSED_VALUE in parameters) {
                this.parsedValue = getParametersValue(parameters, PARSED_VALUE, PFX.defaultValues(PARSED_VALUE));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION$1:
                    return 3;
                case AUTH_SAFE:
                    return (new ContentInfo());
                case MAC_DATA:
                    return (new MacData());
                case PARSED_VALUE:
                    return {};
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VERSION$1:
                    return (memberValue === PFX.defaultValues(memberName));
                case AUTH_SAFE:
                    return ((ContentInfo.compareWithDefault("contentType", memberValue.contentType)) &&
                        (ContentInfo.compareWithDefault("content", memberValue.content)));
                case MAC_DATA:
                    return ((MacData.compareWithDefault("mac", memberValue.mac)) &&
                        (MacData.compareWithDefault("macSalt", memberValue.macSalt)) &&
                        (MacData.compareWithDefault("iterations", memberValue.iterations)));
                case PARSED_VALUE:
                    return ((memberValue instanceof Object) && (Object.keys(memberValue).length === 0));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.version || VERSION$1) }),
                    ContentInfo.schema(names.authSafe || {
                        names: {
                            blockName: AUTH_SAFE
                        }
                    }),
                    MacData.schema(names.macData || {
                        names: {
                            blockName: MAC_DATA,
                            optional: true
                        }
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLERA_PROPS);
            const asn1 = compareSchema(schema, schema, PFX.schema({
                names: {
                    version: VERSION$1,
                    authSafe: {
                        names: {
                            blockName: AUTH_SAFE
                        }
                    },
                    macData: {
                        names: {
                            blockName: MAC_DATA
                        }
                    }
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result.version.valueBlock.valueDec;
            this.authSafe = new ContentInfo({ schema: asn1.result.authSafe });
            if (MAC_DATA in asn1.result)
                this.macData = new MacData({ schema: asn1.result.macData });
        }
        toSchema() {
            const outputArray = [
                new Integer({ value: this.version }),
                this.authSafe.toSchema()
            ];
            if (this.macData) {
                outputArray.push(this.macData.toSchema());
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const output = {
                version: this.version,
                authSafe: this.authSafe.toJSON()
            };
            if (this.macData) {
                output.macData = this.macData.toJSON();
            }
            return output;
        }
        async makeInternalValues(parameters = {}, crypto = getCrypto(true)) {
            ArgumentError.assert(parameters, "parameters", "object");
            if (!this.parsedValue) {
                throw new Error("Please call \"parseValues\" function first in order to make \"parsedValue\" data");
            }
            ParameterError.assertEmpty(this.parsedValue.integrityMode, "integrityMode", "parsedValue");
            ParameterError.assertEmpty(this.parsedValue.authenticatedSafe, "authenticatedSafe", "parsedValue");
            switch (this.parsedValue.integrityMode) {
                case 0:
                    {
                        if (!("iterations" in parameters))
                            throw new ParameterError("iterations");
                        ParameterError.assertEmpty(parameters.pbkdf2HashAlgorithm, "pbkdf2HashAlgorithm");
                        ParameterError.assertEmpty(parameters.hmacHashAlgorithm, "hmacHashAlgorithm");
                        ParameterError.assertEmpty(parameters.password, "password");
                        const saltBuffer = new ArrayBuffer(64);
                        const saltView = new Uint8Array(saltBuffer);
                        crypto.getRandomValues(saltView);
                        const data = this.parsedValue.authenticatedSafe.toSchema().toBER(false);
                        this.authSafe = new ContentInfo({
                            contentType: ContentInfo.DATA,
                            content: new OctetString({ valueHex: data })
                        });
                        const result = await crypto.stampDataWithPassword({
                            password: parameters.password,
                            hashAlgorithm: parameters.hmacHashAlgorithm,
                            salt: saltBuffer,
                            iterationCount: parameters.iterations,
                            contentToStamp: data
                        });
                        this.macData = new MacData({
                            mac: new DigestInfo({
                                digestAlgorithm: new AlgorithmIdentifier({
                                    algorithmId: crypto.getOIDByAlgorithm({ name: parameters.hmacHashAlgorithm }, true, "hmacHashAlgorithm"),
                                }),
                                digest: new OctetString({ valueHex: result })
                            }),
                            macSalt: new OctetString({ valueHex: saltBuffer }),
                            iterations: parameters.iterations
                        });
                    }
                    break;
                case 1:
                    {
                        if (!("signingCertificate" in parameters)) {
                            throw new ParameterError("signingCertificate");
                        }
                        ParameterError.assertEmpty(parameters.privateKey, "privateKey");
                        ParameterError.assertEmpty(parameters.hashAlgorithm, "hashAlgorithm");
                        const toBeSigned = this.parsedValue.authenticatedSafe.toSchema().toBER(false);
                        const cmsSigned = new SignedData({
                            version: 1,
                            encapContentInfo: new EncapsulatedContentInfo({
                                eContentType: "1.2.840.113549.1.7.1",
                                eContent: new OctetString({ valueHex: toBeSigned })
                            }),
                            certificates: [parameters.signingCertificate]
                        });
                        const result = await crypto.digest({ name: parameters.hashAlgorithm }, new Uint8Array(toBeSigned));
                        const signedAttr = [];
                        signedAttr.push(new Attribute({
                            type: "1.2.840.113549.1.9.3",
                            values: [
                                new ObjectIdentifier({ value: "1.2.840.113549.1.7.1" })
                            ]
                        }));
                        signedAttr.push(new Attribute({
                            type: "1.2.840.113549.1.9.5",
                            values: [
                                new UTCTime({ valueDate: new Date() })
                            ]
                        }));
                        signedAttr.push(new Attribute({
                            type: "1.2.840.113549.1.9.4",
                            values: [
                                new OctetString({ valueHex: result })
                            ]
                        }));
                        cmsSigned.signerInfos.push(new SignerInfo({
                            version: 1,
                            sid: new IssuerAndSerialNumber({
                                issuer: parameters.signingCertificate.issuer,
                                serialNumber: parameters.signingCertificate.serialNumber
                            }),
                            signedAttrs: new SignedAndUnsignedAttributes({
                                type: 0,
                                attributes: signedAttr
                            })
                        }));
                        await cmsSigned.sign(parameters.privateKey, 0, parameters.hashAlgorithm, undefined, crypto);
                        this.authSafe = new ContentInfo({
                            contentType: "1.2.840.113549.1.7.2",
                            content: cmsSigned.toSchema(true)
                        });
                    }
                    break;
                default:
                    throw new Error(`Parameter "integrityMode" has unknown value: ${this.parsedValue.integrityMode}`);
            }
        }
        async parseInternalValues(parameters, crypto = getCrypto(true)) {
            ArgumentError.assert(parameters, "parameters", "object");
            if (parameters.checkIntegrity === undefined) {
                parameters.checkIntegrity = true;
            }
            this.parsedValue = {};
            switch (this.authSafe.contentType) {
                case ContentInfo.DATA:
                    {
                        ParameterError.assertEmpty(parameters.password, "password");
                        this.parsedValue.integrityMode = 0;
                        ArgumentError.assert(this.authSafe.content, "authSafe.content", OctetString);
                        const authSafeContent = this.authSafe.content.getValue();
                        this.parsedValue.authenticatedSafe = AuthenticatedSafe.fromBER(authSafeContent);
                        if (parameters.checkIntegrity) {
                            if (!this.macData) {
                                throw new Error("Absent \"macData\" value, can not check PKCS#12 data integrity");
                            }
                            const hashAlgorithm = crypto.getAlgorithmByOID(this.macData.mac.digestAlgorithm.algorithmId, true, "digestAlgorithm");
                            const result = await crypto.verifyDataStampedWithPassword({
                                password: parameters.password,
                                hashAlgorithm: hashAlgorithm.name,
                                salt: BufferSourceConverter_1.toArrayBuffer(this.macData.macSalt.valueBlock.valueHexView),
                                iterationCount: this.macData.iterations || 0,
                                contentToVerify: authSafeContent,
                                signatureToVerify: BufferSourceConverter_1.toArrayBuffer(this.macData.mac.digest.valueBlock.valueHexView),
                            });
                            if (!result) {
                                throw new Error("Integrity for the PKCS#12 data is broken!");
                            }
                        }
                    }
                    break;
                case ContentInfo.SIGNED_DATA:
                    {
                        this.parsedValue.integrityMode = 1;
                        const cmsSigned = new SignedData({ schema: this.authSafe.content });
                        const eContent = cmsSigned.encapContentInfo.eContent;
                        ParameterError.assert(eContent, "eContent", "cmsSigned.encapContentInfo");
                        ArgumentError.assert(eContent, "eContent", OctetString);
                        const data = eContent.getValue();
                        this.parsedValue.authenticatedSafe = AuthenticatedSafe.fromBER(data);
                        const ok = await cmsSigned.verify({ signer: 0, checkChain: false }, crypto);
                        if (!ok) {
                            throw new Error("Integrity for the PKCS#12 data is broken!");
                        }
                    }
                    break;
                default:
                    throw new Error(`Incorrect value for "this.authSafe.contentType": ${this.authSafe.contentType}`);
            }
        }
    }
    PFX.CLASS_NAME = "PFX";

    const STATUS$1 = "status";
    const STATUS_STRINGS = "statusStrings";
    const FAIL_INFO = "failInfo";
    const CLEAR_PROPS$2 = [
        STATUS$1,
        STATUS_STRINGS,
        FAIL_INFO
    ];
    var PKIStatus;
    (function (PKIStatus) {
        PKIStatus[PKIStatus["granted"] = 0] = "granted";
        PKIStatus[PKIStatus["grantedWithMods"] = 1] = "grantedWithMods";
        PKIStatus[PKIStatus["rejection"] = 2] = "rejection";
        PKIStatus[PKIStatus["waiting"] = 3] = "waiting";
        PKIStatus[PKIStatus["revocationWarning"] = 4] = "revocationWarning";
        PKIStatus[PKIStatus["revocationNotification"] = 5] = "revocationNotification";
    })(PKIStatus || (PKIStatus = {}));
    class PKIStatusInfo extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.status = getParametersValue(parameters, STATUS$1, PKIStatusInfo.defaultValues(STATUS$1));
            if (STATUS_STRINGS in parameters) {
                this.statusStrings = getParametersValue(parameters, STATUS_STRINGS, PKIStatusInfo.defaultValues(STATUS_STRINGS));
            }
            if (FAIL_INFO in parameters) {
                this.failInfo = getParametersValue(parameters, FAIL_INFO, PKIStatusInfo.defaultValues(FAIL_INFO));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case STATUS$1:
                    return 2;
                case STATUS_STRINGS:
                    return [];
                case FAIL_INFO:
                    return new BitString();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case STATUS$1:
                    return (memberValue === PKIStatusInfo.defaultValues(memberName));
                case STATUS_STRINGS:
                    return (memberValue.length === 0);
                case FAIL_INFO:
                    return (memberValue.isEqual(PKIStatusInfo.defaultValues(memberName)));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || EMPTY_STRING),
                value: [
                    new Integer({ name: (names.status || EMPTY_STRING) }),
                    new Sequence({
                        optional: true,
                        value: [
                            new Repeated({
                                name: (names.statusStrings || EMPTY_STRING),
                                value: new Utf8String()
                            })
                        ]
                    }),
                    new BitString({
                        name: (names.failInfo || EMPTY_STRING),
                        optional: true
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$2);
            const asn1 = compareSchema(schema, schema, PKIStatusInfo.schema({
                names: {
                    status: STATUS$1,
                    statusStrings: STATUS_STRINGS,
                    failInfo: FAIL_INFO
                }
            }));
            AsnError.assertSchema(asn1, this.className);
            const _status = asn1.result.status;
            if ((_status.valueBlock.isHexOnly === true) ||
                (_status.valueBlock.valueDec < 0) ||
                (_status.valueBlock.valueDec > 5))
                throw new Error("PKIStatusInfo \"status\" has invalid value");
            this.status = _status.valueBlock.valueDec;
            if (STATUS_STRINGS in asn1.result)
                this.statusStrings = asn1.result.statusStrings;
            if (FAIL_INFO in asn1.result)
                this.failInfo = asn1.result.failInfo;
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new Integer({ value: this.status }));
            if (this.statusStrings) {
                outputArray.push(new Sequence({
                    optional: true,
                    value: this.statusStrings
                }));
            }
            if (this.failInfo) {
                outputArray.push(this.failInfo);
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                status: this.status
            };
            if (this.statusStrings) {
                res.statusStrings = Array.from(this.statusStrings, o => o.toJSON());
            }
            if (this.failInfo) {
                res.failInfo = this.failInfo.toJSON();
            }
            return res;
        }
    }
    PKIStatusInfo.CLASS_NAME = "PKIStatusInfo";

    const VERSION = "version";
    const MESSAGE_IMPRINT = "messageImprint";
    const REQ_POLICY = "reqPolicy";
    const NONCE = "nonce";
    const CERT_REQ = "certReq";
    const EXTENSIONS = "extensions";
    const TIME_STAMP_REQ = "TimeStampReq";
    const TIME_STAMP_REQ_VERSION = `${TIME_STAMP_REQ}.${VERSION}`;
    const TIME_STAMP_REQ_MESSAGE_IMPRINT = `${TIME_STAMP_REQ}.${MESSAGE_IMPRINT}`;
    const TIME_STAMP_REQ_POLICY = `${TIME_STAMP_REQ}.${REQ_POLICY}`;
    const TIME_STAMP_REQ_NONCE = `${TIME_STAMP_REQ}.${NONCE}`;
    const TIME_STAMP_REQ_CERT_REQ = `${TIME_STAMP_REQ}.${CERT_REQ}`;
    const TIME_STAMP_REQ_EXTENSIONS = `${TIME_STAMP_REQ}.${EXTENSIONS}`;
    const CLEAR_PROPS$1 = [
        TIME_STAMP_REQ_VERSION,
        TIME_STAMP_REQ_MESSAGE_IMPRINT,
        TIME_STAMP_REQ_POLICY,
        TIME_STAMP_REQ_NONCE,
        TIME_STAMP_REQ_CERT_REQ,
        TIME_STAMP_REQ_EXTENSIONS,
    ];
    class TimeStampReq extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.version = getParametersValue(parameters, VERSION, TimeStampReq.defaultValues(VERSION));
            this.messageImprint = getParametersValue(parameters, MESSAGE_IMPRINT, TimeStampReq.defaultValues(MESSAGE_IMPRINT));
            if (REQ_POLICY in parameters) {
                this.reqPolicy = getParametersValue(parameters, REQ_POLICY, TimeStampReq.defaultValues(REQ_POLICY));
            }
            if (NONCE in parameters) {
                this.nonce = getParametersValue(parameters, NONCE, TimeStampReq.defaultValues(NONCE));
            }
            if (CERT_REQ in parameters) {
                this.certReq = getParametersValue(parameters, CERT_REQ, TimeStampReq.defaultValues(CERT_REQ));
            }
            if (EXTENSIONS in parameters) {
                this.extensions = getParametersValue(parameters, EXTENSIONS, TimeStampReq.defaultValues(EXTENSIONS));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case VERSION:
                    return 0;
                case MESSAGE_IMPRINT:
                    return new MessageImprint();
                case REQ_POLICY:
                    return EMPTY_STRING;
                case NONCE:
                    return new Integer();
                case CERT_REQ:
                    return false;
                case EXTENSIONS:
                    return [];
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case VERSION:
                case REQ_POLICY:
                case CERT_REQ:
                    return (memberValue === TimeStampReq.defaultValues(memberName));
                case MESSAGE_IMPRINT:
                    return ((MessageImprint.compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm)) &&
                        (MessageImprint.compareWithDefault("hashedMessage", memberValue.hashedMessage)));
                case NONCE:
                    return (memberValue.isEqual(TimeStampReq.defaultValues(memberName)));
                case EXTENSIONS:
                    return (memberValue.length === 0);
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || TIME_STAMP_REQ),
                value: [
                    new Integer({ name: (names.version || TIME_STAMP_REQ_VERSION) }),
                    MessageImprint.schema(names.messageImprint || {
                        names: {
                            blockName: TIME_STAMP_REQ_MESSAGE_IMPRINT
                        }
                    }),
                    new ObjectIdentifier({
                        name: (names.reqPolicy || TIME_STAMP_REQ_POLICY),
                        optional: true
                    }),
                    new Integer({
                        name: (names.nonce || TIME_STAMP_REQ_NONCE),
                        optional: true
                    }),
                    new Boolean$1({
                        name: (names.certReq || TIME_STAMP_REQ_CERT_REQ),
                        optional: true
                    }),
                    new Constructed({
                        optional: true,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: 0
                        },
                        value: [new Repeated({
                                name: (names.extensions || TIME_STAMP_REQ_EXTENSIONS),
                                value: Extension.schema()
                            })]
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS$1);
            const asn1 = compareSchema(schema, schema, TimeStampReq.schema());
            AsnError.assertSchema(asn1, this.className);
            this.version = asn1.result[TIME_STAMP_REQ_VERSION].valueBlock.valueDec;
            this.messageImprint = new MessageImprint({ schema: asn1.result[TIME_STAMP_REQ_MESSAGE_IMPRINT] });
            if (TIME_STAMP_REQ_POLICY in asn1.result)
                this.reqPolicy = asn1.result[TIME_STAMP_REQ_POLICY].valueBlock.toString();
            if (TIME_STAMP_REQ_NONCE in asn1.result)
                this.nonce = asn1.result[TIME_STAMP_REQ_NONCE];
            if (TIME_STAMP_REQ_CERT_REQ in asn1.result)
                this.certReq = asn1.result[TIME_STAMP_REQ_CERT_REQ].valueBlock.value;
            if (TIME_STAMP_REQ_EXTENSIONS in asn1.result)
                this.extensions = Array.from(asn1.result[TIME_STAMP_REQ_EXTENSIONS], element => new Extension({ schema: element }));
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(new Integer({ value: this.version }));
            outputArray.push(this.messageImprint.toSchema());
            if (this.reqPolicy)
                outputArray.push(new ObjectIdentifier({ value: this.reqPolicy }));
            if (this.nonce)
                outputArray.push(this.nonce);
            if ((CERT_REQ in this) && (TimeStampReq.compareWithDefault(CERT_REQ, this.certReq) === false))
                outputArray.push(new Boolean$1({ value: this.certReq }));
            if (this.extensions) {
                outputArray.push(new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                    },
                    value: Array.from(this.extensions, o => o.toSchema())
                }));
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                version: this.version,
                messageImprint: this.messageImprint.toJSON()
            };
            if (this.reqPolicy !== undefined)
                res.reqPolicy = this.reqPolicy;
            if (this.nonce !== undefined)
                res.nonce = this.nonce.toJSON();
            if ((this.certReq !== undefined) && (TimeStampReq.compareWithDefault(CERT_REQ, this.certReq) === false))
                res.certReq = this.certReq;
            if (this.extensions) {
                res.extensions = Array.from(this.extensions, o => o.toJSON());
            }
            return res;
        }
    }
    TimeStampReq.CLASS_NAME = "TimeStampReq";

    const STATUS = "status";
    const TIME_STAMP_TOKEN = "timeStampToken";
    const TIME_STAMP_RESP = "TimeStampResp";
    const TIME_STAMP_RESP_STATUS = `${TIME_STAMP_RESP}.${STATUS}`;
    const TIME_STAMP_RESP_TOKEN = `${TIME_STAMP_RESP}.${TIME_STAMP_TOKEN}`;
    const CLEAR_PROPS = [
        TIME_STAMP_RESP_STATUS,
        TIME_STAMP_RESP_TOKEN
    ];
    class TimeStampResp extends PkiObject {
        constructor(parameters = {}) {
            super();
            this.status = getParametersValue(parameters, STATUS, TimeStampResp.defaultValues(STATUS));
            if (TIME_STAMP_TOKEN in parameters) {
                this.timeStampToken = getParametersValue(parameters, TIME_STAMP_TOKEN, TimeStampResp.defaultValues(TIME_STAMP_TOKEN));
            }
            if (parameters.schema) {
                this.fromSchema(parameters.schema);
            }
        }
        static defaultValues(memberName) {
            switch (memberName) {
                case STATUS:
                    return new PKIStatusInfo();
                case TIME_STAMP_TOKEN:
                    return new ContentInfo();
                default:
                    return super.defaultValues(memberName);
            }
        }
        static compareWithDefault(memberName, memberValue) {
            switch (memberName) {
                case STATUS:
                    return ((PKIStatusInfo.compareWithDefault(STATUS, memberValue.status)) &&
                        (("statusStrings" in memberValue) === false) &&
                        (("failInfo" in memberValue) === false));
                case TIME_STAMP_TOKEN:
                    return ((memberValue.contentType === EMPTY_STRING) &&
                        (memberValue.content instanceof Any));
                default:
                    return super.defaultValues(memberName);
            }
        }
        static schema(parameters = {}) {
            const names = getParametersValue(parameters, "names", {});
            return (new Sequence({
                name: (names.blockName || TIME_STAMP_RESP),
                value: [
                    PKIStatusInfo.schema(names.status || {
                        names: {
                            blockName: TIME_STAMP_RESP_STATUS
                        }
                    }),
                    ContentInfo.schema(names.timeStampToken || {
                        names: {
                            blockName: TIME_STAMP_RESP_TOKEN,
                            optional: true
                        }
                    })
                ]
            }));
        }
        fromSchema(schema) {
            clearProps(schema, CLEAR_PROPS);
            const asn1 = compareSchema(schema, schema, TimeStampResp.schema());
            AsnError.assertSchema(asn1, this.className);
            this.status = new PKIStatusInfo({ schema: asn1.result[TIME_STAMP_RESP_STATUS] });
            if (TIME_STAMP_RESP_TOKEN in asn1.result)
                this.timeStampToken = new ContentInfo({ schema: asn1.result[TIME_STAMP_RESP_TOKEN] });
        }
        toSchema() {
            const outputArray = [];
            outputArray.push(this.status.toSchema());
            if (this.timeStampToken) {
                outputArray.push(this.timeStampToken.toSchema());
            }
            return (new Sequence({
                value: outputArray
            }));
        }
        toJSON() {
            const res = {
                status: this.status.toJSON()
            };
            if (this.timeStampToken) {
                res.timeStampToken = this.timeStampToken.toJSON();
            }
            return res;
        }
        async sign(privateKey, hashAlgorithm, crypto = getCrypto(true)) {
            this.assertContentType();
            const signed = new SignedData({ schema: this.timeStampToken.content });
            return signed.sign(privateKey, 0, hashAlgorithm, undefined, crypto);
        }
        async verify(verificationParameters = { signer: 0, trustedCerts: [], data: EMPTY_BUFFER }, crypto = getCrypto(true)) {
            this.assertContentType();
            const signed = new SignedData({ schema: this.timeStampToken.content });
            return signed.verify(verificationParameters, crypto);
        }
        assertContentType() {
            if (!this.timeStampToken) {
                throw new Error("timeStampToken is absent in TSP response");
            }
            if (this.timeStampToken.contentType !== id_ContentType_SignedData) {
                throw new Error(`Wrong format of timeStampToken: ${this.timeStampToken.contentType}`);
            }
        }
    }
    TimeStampResp.CLASS_NAME = "TimeStampResp";

    function initCryptoEngine() {
        if (typeof self !== "undefined") {
            if ("crypto" in self) {
                let engineName = "webcrypto";
                if ("webkitSubtle" in self.crypto) {
                    engineName = "safari";
                }
                setEngine(engineName, new CryptoEngine({ name: engineName, crypto: crypto }));
            }
        }
        else if (typeof crypto !== "undefined" && "webcrypto" in crypto) {
            const name = "NodeJS ^15";
            const nodeCrypto = crypto.webcrypto;
            setEngine(name, new CryptoEngine({ name, crypto: nodeCrypto }));
        }
    }

    initCryptoEngine();

    /* src/components/decoders/X509.svelte generated by Svelte v3.48.0 */
    const file$6 = "src/components/decoders/X509.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (19:70) {:else}
    function create_else_block_1$2(ctx) {
    	let a;
    	let t_value = /*value*/ ctx[2].type + "";
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", a_href_value = "https://oid-rep.orange-labs.fr/get/" + /*value*/ ctx[2].type);
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$6, 18, 77, 530);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*certificate*/ 1 && t_value !== (t_value = /*value*/ ctx[2].type + "")) set_data_dev(t, t_value);

    			if (dirty & /*certificate*/ 1 && a_href_value !== (a_href_value = "https://oid-rep.orange-labs.fr/get/" + /*value*/ ctx[2].type)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(19:70) {:else}",
    		ctx
    	});

    	return block;
    }

    // (19:11) {#if oids[value.type]}
    function create_if_block_1$2(ctx) {
    	let t_value = camelCaseToString(oids[/*value*/ ctx[2].type]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*certificate*/ 1 && t_value !== (t_value = camelCaseToString(oids[/*value*/ ctx[2].type]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(19:11) {#if oids[value.type]}",
    		ctx
    	});

    	return block;
    }

    // (16:4) {#each certificate.subject.typesAndValues as value}
    function create_each_block_1(ctx) {
    	let tr;
    	let th;
    	let t0;
    	let td;
    	let t1_value = /*value*/ ctx[2].value.valueBlock.value + "";
    	let t1;
    	let t2;

    	function select_block_type(ctx, dirty) {
    		if (oids[/*value*/ ctx[2].type]) return create_if_block_1$2;
    		return create_else_block_1$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			th = element("th");
    			if_block.c();
    			t0 = space();
    			td = element("td");
    			t1 = text(t1_value);
    			t2 = space();
    			add_location(th, file$6, 17, 8, 449);
    			add_location(td, file$6, 23, 8, 689);
    			add_location(tr, file$6, 16, 6, 436);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, th);
    			if_block.m(th, null);
    			append_dev(tr, t0);
    			append_dev(tr, td);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(th, null);
    				}
    			}

    			if (dirty & /*certificate*/ 1 && t1_value !== (t1_value = /*value*/ ctx[2].value.valueBlock.value + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(16:4) {#each certificate.subject.typesAndValues as value}",
    		ctx
    	});

    	return block;
    }

    // (33:4) {#each certificate.issuer.typesAndValues as value}
    function create_each_block$3(ctx) {
    	let tr;
    	let th;
    	let t0_value = camelCaseToString(oids[/*value*/ ctx[2].type]) + "";
    	let t0;
    	let t1;
    	let td;
    	let t2_value = /*value*/ ctx[2].value.valueBlock.value + "";
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			th = element("th");
    			t0 = text(t0_value);
    			t1 = space();
    			td = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			add_location(th, file$6, 34, 8, 939);
    			add_location(td, file$6, 35, 8, 994);
    			add_location(tr, file$6, 33, 6, 926);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, th);
    			append_dev(th, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td);
    			append_dev(td, t2);
    			append_dev(tr, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*certificate*/ 1 && t0_value !== (t0_value = camelCaseToString(oids[/*value*/ ctx[2].type]) + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*certificate*/ 1 && t2_value !== (t2_value = /*value*/ ctx[2].value.valueBlock.value + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(33:4) {#each certificate.issuer.typesAndValues as value}",
    		ctx
    	});

    	return block;
    }

    // (72:12) {:else}
    function create_else_block$3(ctx) {
    	let a;
    	let t_value = /*certificate*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId + "";
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", a_href_value = "https://oid-rep.orange-labs.fr/get/" + /*certificate*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId);
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$6, 71, 19, 1906);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*certificate*/ 1 && t_value !== (t_value = /*certificate*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId + "")) set_data_dev(t, t_value);

    			if (dirty & /*certificate*/ 1 && a_href_value !== (a_href_value = "https://oid-rep.orange-labs.fr/get/" + /*certificate*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(72:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (70:9) {#if oids[certificate.subjectPublicKeyInfo.algorithm.algorithmId]}
    function create_if_block$4(ctx) {
    	let t_value = camelCaseToString(oids[/*certificate*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*certificate*/ 1 && t_value !== (t_value = camelCaseToString(oids[/*certificate*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(70:9) {#if oids[certificate.subjectPublicKeyInfo.algorithm.algorithmId]}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let h2;
    	let t1;
    	let table;
    	let tbody0;
    	let tr0;
    	let td0;
    	let t3;
    	let div0;
    	let t4;
    	let t5;
    	let tbody1;
    	let tr1;
    	let td1;
    	let t7;
    	let div1;
    	let t8;
    	let t9;
    	let tbody2;
    	let tr2;
    	let td2;
    	let t11;
    	let div2;
    	let t12;
    	let tr3;
    	let th0;
    	let t14;
    	let td3;
    	let t15_value = arrayBufferToHex(/*certificate*/ ctx[0].serialNumber.valueBlock.valueHexView).toUpperCase() + "";
    	let t15;
    	let t16;
    	let tr4;
    	let th1;
    	let t18;
    	let td4;
    	let t19_value = /*certificate*/ ctx[0].notBefore.value.toLocaleString() + "";
    	let t19;
    	let t20;
    	let tr5;
    	let th2;
    	let t22;
    	let td5;
    	let t23_value = /*certificate*/ ctx[0].notAfter.value.toLocaleString() + "";
    	let t23;
    	let t24;
    	let tbody3;
    	let tr6;
    	let td6;
    	let t26;
    	let div3;
    	let t27;
    	let tr7;
    	let th3;
    	let t29;
    	let td7;
    	let t30;
    	let tr8;
    	let th4;
    	let t32;
    	let td8;
    	let t33_value = arrayBufferToHex(/*certificate*/ ctx[0].subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView).toUpperCase() + "";
    	let t33;
    	let t34;
    	let tr9;
    	let th5;
    	let t36;
    	let td9;
    	let t37_value = /*certificate*/ ctx[0].signatureValue.valueBlock.valueHexView.length + "";
    	let t37;
    	let t38;
    	let t39_value = arrayBufferToHex(/*certificate*/ ctx[0].signatureValue.valueBlock.valueHexView).toUpperCase() + "";
    	let t39;
    	let each_value_1 = /*certificate*/ ctx[0].subject.typesAndValues;
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let each_value = /*certificate*/ ctx[0].issuer.typesAndValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	function select_block_type_1(ctx, dirty) {
    		if (oids[/*certificate*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId]) return create_if_block$4;
    		return create_else_block$3;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Details";
    			t1 = space();
    			table = element("table");
    			tbody0 = element("tbody");
    			tr0 = element("tr");
    			td0 = element("td");
    			td0.textContent = "Subject";
    			t3 = space();
    			div0 = element("div");
    			t4 = space();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t5 = space();
    			tbody1 = element("tbody");
    			tr1 = element("tr");
    			td1 = element("td");
    			td1.textContent = "Issuer";
    			t7 = space();
    			div1 = element("div");
    			t8 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t9 = space();
    			tbody2 = element("tbody");
    			tr2 = element("tr");
    			td2 = element("td");
    			td2.textContent = "Details";
    			t11 = space();
    			div2 = element("div");
    			t12 = space();
    			tr3 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Serial Number";
    			t14 = space();
    			td3 = element("td");
    			t15 = text(t15_value);
    			t16 = space();
    			tr4 = element("tr");
    			th1 = element("th");
    			th1.textContent = "Issued";
    			t18 = space();
    			td4 = element("td");
    			t19 = text(t19_value);
    			t20 = space();
    			tr5 = element("tr");
    			th2 = element("th");
    			th2.textContent = "Expires";
    			t22 = space();
    			td5 = element("td");
    			t23 = text(t23_value);
    			t24 = space();
    			tbody3 = element("tbody");
    			tr6 = element("tr");
    			td6 = element("td");
    			td6.textContent = "Public Key";
    			t26 = space();
    			div3 = element("div");
    			t27 = space();
    			tr7 = element("tr");
    			th3 = element("th");
    			th3.textContent = "Algorithm";
    			t29 = space();
    			td7 = element("td");
    			if_block.c();
    			t30 = space();
    			tr8 = element("tr");
    			th4 = element("th");
    			th4.textContent = "Public Key";
    			t32 = space();
    			td8 = element("td");
    			t33 = text(t33_value);
    			t34 = space();
    			tr9 = element("tr");
    			th5 = element("th");
    			th5.textContent = "Signature";
    			t36 = space();
    			td9 = element("td");
    			t37 = text(t37_value);
    			t38 = text(" bytes: ");
    			t39 = text(t39_value);
    			add_location(h2, file$6, 8, 0, 228);
    			add_location(td0, file$6, 12, 6, 320);
    			attr_dev(div0, "class", "line");
    			add_location(div0, file$6, 13, 6, 343);
    			attr_dev(tr0, "class", "section-header");
    			add_location(tr0, file$6, 11, 4, 286);
    			add_location(tbody0, file$6, 10, 2, 274);
    			add_location(td1, file$6, 29, 6, 812);
    			attr_dev(div1, "class", "line");
    			add_location(div1, file$6, 30, 6, 834);
    			attr_dev(tr1, "class", "section-header");
    			add_location(tr1, file$6, 28, 4, 778);
    			add_location(tbody1, file$6, 27, 2, 766);
    			add_location(td2, file$6, 41, 6, 1117);
    			attr_dev(div2, "class", "line");
    			add_location(div2, file$6, 42, 6, 1140);
    			attr_dev(tr2, "class", "section-header");
    			add_location(tr2, file$6, 40, 4, 1083);
    			add_location(th0, file$6, 45, 6, 1186);
    			add_location(td3, file$6, 46, 6, 1215);
    			add_location(tr3, file$6, 44, 4, 1175);
    			add_location(th1, file$6, 53, 6, 1368);
    			add_location(td4, file$6, 54, 6, 1390);
    			add_location(tr4, file$6, 52, 4, 1357);
    			add_location(th2, file$6, 57, 6, 1471);
    			add_location(td5, file$6, 58, 6, 1494);
    			add_location(tr5, file$6, 56, 4, 1460);
    			add_location(tbody2, file$6, 39, 2, 1071);
    			add_location(td6, file$6, 63, 6, 1618);
    			attr_dev(div3, "class", "line");
    			add_location(div3, file$6, 64, 6, 1644);
    			attr_dev(tr6, "class", "section-header");
    			add_location(tr6, file$6, 62, 4, 1584);
    			add_location(th3, file$6, 67, 6, 1690);
    			add_location(td7, file$6, 68, 6, 1715);
    			add_location(tr7, file$6, 66, 4, 1679);
    			add_location(th4, file$6, 80, 6, 2190);
    			attr_dev(td8, "class", "bytes");
    			add_location(td8, file$6, 81, 6, 2216);
    			add_location(tr8, file$6, 79, 4, 2179);
    			add_location(th5, file$6, 89, 6, 2421);
    			attr_dev(td9, "class", "bytes");
    			add_location(td9, file$6, 90, 6, 2446);
    			add_location(tr9, file$6, 88, 4, 2410);
    			add_location(tbody3, file$6, 61, 2, 1572);
    			attr_dev(table, "class", "properties");
    			add_location(table, file$6, 9, 0, 245);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, tbody0);
    			append_dev(tbody0, tr0);
    			append_dev(tr0, td0);
    			append_dev(tr0, t3);
    			append_dev(tr0, div0);
    			append_dev(tbody0, t4);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(tbody0, null);
    			}

    			append_dev(table, t5);
    			append_dev(table, tbody1);
    			append_dev(tbody1, tr1);
    			append_dev(tr1, td1);
    			append_dev(tr1, t7);
    			append_dev(tr1, div1);
    			append_dev(tbody1, t8);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody1, null);
    			}

    			append_dev(table, t9);
    			append_dev(table, tbody2);
    			append_dev(tbody2, tr2);
    			append_dev(tr2, td2);
    			append_dev(tr2, t11);
    			append_dev(tr2, div2);
    			append_dev(tbody2, t12);
    			append_dev(tbody2, tr3);
    			append_dev(tr3, th0);
    			append_dev(tr3, t14);
    			append_dev(tr3, td3);
    			append_dev(td3, t15);
    			append_dev(tbody2, t16);
    			append_dev(tbody2, tr4);
    			append_dev(tr4, th1);
    			append_dev(tr4, t18);
    			append_dev(tr4, td4);
    			append_dev(td4, t19);
    			append_dev(tbody2, t20);
    			append_dev(tbody2, tr5);
    			append_dev(tr5, th2);
    			append_dev(tr5, t22);
    			append_dev(tr5, td5);
    			append_dev(td5, t23);
    			append_dev(table, t24);
    			append_dev(table, tbody3);
    			append_dev(tbody3, tr6);
    			append_dev(tr6, td6);
    			append_dev(tr6, t26);
    			append_dev(tr6, div3);
    			append_dev(tbody3, t27);
    			append_dev(tbody3, tr7);
    			append_dev(tr7, th3);
    			append_dev(tr7, t29);
    			append_dev(tr7, td7);
    			if_block.m(td7, null);
    			append_dev(tbody3, t30);
    			append_dev(tbody3, tr8);
    			append_dev(tr8, th4);
    			append_dev(tr8, t32);
    			append_dev(tr8, td8);
    			append_dev(td8, t33);
    			append_dev(tbody3, t34);
    			append_dev(tbody3, tr9);
    			append_dev(tr9, th5);
    			append_dev(tr9, t36);
    			append_dev(tr9, td9);
    			append_dev(td9, t37);
    			append_dev(td9, t38);
    			append_dev(td9, t39);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*certificate, camelCaseToString, oids*/ 1) {
    				each_value_1 = /*certificate*/ ctx[0].subject.typesAndValues;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(tbody0, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*certificate, camelCaseToString, oids*/ 1) {
    				each_value = /*certificate*/ ctx[0].issuer.typesAndValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*certificate*/ 1 && t15_value !== (t15_value = arrayBufferToHex(/*certificate*/ ctx[0].serialNumber.valueBlock.valueHexView).toUpperCase() + "")) set_data_dev(t15, t15_value);
    			if (dirty & /*certificate*/ 1 && t19_value !== (t19_value = /*certificate*/ ctx[0].notBefore.value.toLocaleString() + "")) set_data_dev(t19, t19_value);
    			if (dirty & /*certificate*/ 1 && t23_value !== (t23_value = /*certificate*/ ctx[0].notAfter.value.toLocaleString() + "")) set_data_dev(t23, t23_value);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(td7, null);
    				}
    			}

    			if (dirty & /*certificate*/ 1 && t33_value !== (t33_value = arrayBufferToHex(/*certificate*/ ctx[0].subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView).toUpperCase() + "")) set_data_dev(t33, t33_value);
    			if (dirty & /*certificate*/ 1 && t37_value !== (t37_value = /*certificate*/ ctx[0].signatureValue.valueBlock.valueHexView.length + "")) set_data_dev(t37, t37_value);
    			if (dirty & /*certificate*/ 1 && t39_value !== (t39_value = arrayBufferToHex(/*certificate*/ ctx[0].signatureValue.valueBlock.valueHexView).toUpperCase() + "")) set_data_dev(t39, t39_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let certificate;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('X509', slots, []);
    	let { result } = $$props;
    	const writable_props = ['result'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<X509> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('result' in $$props) $$invalidate(1, result = $$props.result);
    	};

    	$$self.$capture_state = () => ({
    		oids,
    		camelCaseToString,
    		arrayBufferToHex,
    		result,
    		certificate
    	});

    	$$self.$inject_state = $$props => {
    		if ('result' in $$props) $$invalidate(1, result = $$props.result);
    		if ('certificate' in $$props) $$invalidate(0, certificate = $$props.certificate);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*result*/ 2) {
    			$$invalidate(0, certificate = result.value);
    		}
    	};

    	return [certificate, result];
    }

    class X509 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, { result: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "X509",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*result*/ ctx[1] === undefined && !('result' in props)) {
    			console.warn("<X509> was created without expected prop 'result'");
    		}
    	}

    	get result() {
    		throw new Error("<X509>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set result(value) {
    		throw new Error("<X509>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var x509Decoder = {
        name: "X.509",
        fullName: "Public Key Certificate",
        rfc: 5280,
        inputType: "asn1",
        outputType: "x509",
        display: X509,
        f: (asn1) => {
            try {
                let cert = new Certificate({ schema: asn1 });
                return [cert, null];
            }
            catch (_a) {
                return [null, null];
            }
        }
    };
    const oids = {};
    const addOid = (id, name) => {
        oids[id] = name;
        oids[name] = id;
    };
    // algorithm OIDs
    addOid('1.2.840.113549.1.1.1', 'rsaEncryption');
    // Note: md2 & md4 not implemented
    //addOid('1.2.840.113549.1.1.2', 'md2WithRSAEncryption');
    //addOid('1.2.840.113549.1.1.3', 'md4WithRSAEncryption');
    addOid('1.2.840.113549.1.1.4', 'md5WithRSAEncryption');
    addOid('1.2.840.113549.1.1.5', 'sha1WithRSAEncryption');
    addOid('1.2.840.113549.1.1.7', 'RSAES-OAEP');
    addOid('1.2.840.113549.1.1.8', 'mgf1');
    addOid('1.2.840.113549.1.1.9', 'pSpecified');
    addOid('1.2.840.113549.1.1.10', 'RSASSA-PSS');
    addOid('1.2.840.113549.1.1.11', 'sha256WithRSAEncryption');
    addOid('1.2.840.113549.1.1.12', 'sha384WithRSAEncryption');
    addOid('1.2.840.113549.1.1.13', 'sha512WithRSAEncryption');
    // Edwards-curve Digital Signature Algorithm (EdDSA) Ed25519
    addOid('1.3.101.112', 'EdDSA25519');
    addOid('1.2.840.10045.2.1', "ECDSA");
    addOid('1.2.840.10040.4.3', 'dsa-with-sha1');
    addOid('1.3.14.3.2.7', 'desCBC');
    addOid('1.3.14.3.2.26', 'sha1');
    // Deprecated equivalent of sha1WithRSAEncryption
    addOid('1.3.14.3.2.29', 'sha1WithRSASignature');
    addOid('2.16.840.1.101.3.4.2.1', 'sha256');
    addOid('2.16.840.1.101.3.4.2.2', 'sha384');
    addOid('2.16.840.1.101.3.4.2.3', 'sha512');
    addOid('2.16.840.1.101.3.4.2.4', 'sha224');
    addOid('2.16.840.1.101.3.4.2.5', 'sha512-224');
    addOid('2.16.840.1.101.3.4.2.6', 'sha512-256');
    addOid('1.2.840.113549.2.2', 'md2');
    addOid('1.2.840.113549.2.5', 'md5');
    // pkcs#7 content types
    addOid('1.2.840.113549.1.7.1', 'data');
    addOid('1.2.840.113549.1.7.2', 'signedData');
    addOid('1.2.840.113549.1.7.3', 'envelopedData');
    addOid('1.2.840.113549.1.7.4', 'signedAndEnvelopedData');
    addOid('1.2.840.113549.1.7.5', 'digestedData');
    addOid('1.2.840.113549.1.7.6', 'encryptedData');
    // pkcs#9 oids
    addOid('1.2.840.113549.1.9.1', 'emailAddress');
    addOid('1.2.840.113549.1.9.2', 'unstructuredName');
    addOid('1.2.840.113549.1.9.3', 'contentType');
    addOid('1.2.840.113549.1.9.4', 'messageDigest');
    addOid('1.2.840.113549.1.9.5', 'signingTime');
    addOid('1.2.840.113549.1.9.6', 'counterSignature');
    addOid('1.2.840.113549.1.9.7', 'challengePassword');
    addOid('1.2.840.113549.1.9.8', 'unstructuredAddress');
    addOid('1.2.840.113549.1.9.14', 'extensionRequest');
    addOid('0.9.2342.19200300.100.1.1', 'userId'); // rfc4519
    addOid('1.2.840.113549.1.9.20', 'friendlyName');
    addOid('1.2.840.113549.1.9.21', 'localKeyId');
    addOid('1.2.840.113549.1.9.22.1', 'x509Certificate');
    // pkcs#12 safe bags
    addOid('1.2.840.113549.1.12.10.1.1', 'keyBag');
    addOid('1.2.840.113549.1.12.10.1.2', 'pkcs8ShroudedKeyBag');
    addOid('1.2.840.113549.1.12.10.1.3', 'certBag');
    addOid('1.2.840.113549.1.12.10.1.4', 'crlBag');
    addOid('1.2.840.113549.1.12.10.1.5', 'secretBag');
    addOid('1.2.840.113549.1.12.10.1.6', 'safeContentsBag');
    // password-based-encryption for pkcs#12
    addOid('1.2.840.113549.1.5.13', 'pkcs5PBES2');
    addOid('1.2.840.113549.1.5.12', 'pkcs5PBKDF2');
    addOid('1.2.840.113549.1.12.1.1', 'pbeWithSHAAnd128BitRC4');
    addOid('1.2.840.113549.1.12.1.2', 'pbeWithSHAAnd40BitRC4');
    addOid('1.2.840.113549.1.12.1.3', 'pbeWithSHAAnd3-KeyTripleDES-CBC');
    addOid('1.2.840.113549.1.12.1.4', 'pbeWithSHAAnd2-KeyTripleDES-CBC');
    addOid('1.2.840.113549.1.12.1.5', 'pbeWithSHAAnd128BitRC2-CBC');
    addOid('1.2.840.113549.1.12.1.6', 'pbewithSHAAnd40BitRC2-CBC');
    // hmac OIDs
    addOid('1.2.840.113549.2.7', 'hmacWithSHA1');
    addOid('1.2.840.113549.2.8', 'hmacWithSHA224');
    addOid('1.2.840.113549.2.9', 'hmacWithSHA256');
    addOid('1.2.840.113549.2.10', 'hmacWithSHA384');
    addOid('1.2.840.113549.2.11', 'hmacWithSHA512');
    // symmetric key algorithm oids
    addOid('1.2.840.113549.3.7', 'des-EDE3-CBC');
    addOid('2.16.840.1.101.3.4.1.2', 'aes128-CBC');
    addOid('2.16.840.1.101.3.4.1.22', 'aes192-CBC');
    addOid('2.16.840.1.101.3.4.1.42', 'aes256-CBC');
    // certificate issuer/subject OIDs
    addOid('2.5.4.3', 'commonName');
    addOid('2.5.4.4', 'surname');
    addOid('2.5.4.5', 'serialNumber');
    addOid('2.5.4.6', 'countryName');
    addOid('2.5.4.7', 'localityName');
    addOid('2.5.4.8', 'stateOrProvinceName');
    addOid('2.5.4.9', 'streetAddress');
    addOid('2.5.4.10', 'organizationName');
    addOid('2.5.4.11', 'organizationalUnitName');
    addOid('2.5.4.12', 'title');
    addOid('2.5.4.13', 'description');
    addOid('2.5.4.15', 'businessCategory');
    addOid('2.5.4.17', 'postalCode');
    addOid('2.5.4.42', 'givenName');
    addOid('1.3.6.1.4.1.311.60.2.1.2', 'jurisdictionOfIncorporationStateOrProvinceName');
    addOid('1.3.6.1.4.1.311.60.2.1.3', 'jurisdictionOfIncorporationCountryName');
    // X.509 extension OIDs
    addOid('2.16.840.1.113730.1.1', 'nsCertType');
    addOid('2.16.840.1.113730.1.13', 'nsComment'); // deprecated in theory; still widely used
    addOid('2.5.29.1', 'authorityKeyIdentifier'); // deprecated, use .35
    addOid('2.5.29.2', 'keyAttributes'); // obsolete use .37 or .15
    addOid('2.5.29.3', 'certificatePolicies'); // deprecated, use .32
    addOid('2.5.29.4', 'keyUsageRestriction'); // obsolete use .37 or .15
    addOid('2.5.29.5', 'policyMapping'); // deprecated use .33
    addOid('2.5.29.6', 'subtreesConstraint'); // obsolete use .30
    addOid('2.5.29.7', 'subjectAltName'); // deprecated use .17
    addOid('2.5.29.8', 'issuerAltName'); // deprecated use .18
    addOid('2.5.29.9', 'subjectDirectoryAttributes');
    addOid('2.5.29.10', 'basicConstraints'); // deprecated use .19
    addOid('2.5.29.11', 'nameConstraints'); // deprecated use .30
    addOid('2.5.29.12', 'policyConstraints'); // deprecated use .36
    addOid('2.5.29.13', 'basicConstraints'); // deprecated use .19
    addOid('2.5.29.14', 'subjectKeyIdentifier');
    addOid('2.5.29.15', 'keyUsage');
    addOid('2.5.29.16', 'privateKeyUsagePeriod');
    addOid('2.5.29.17', 'subjectAltName');
    addOid('2.5.29.18', 'issuerAltName');
    addOid('2.5.29.19', 'basicConstraints');
    addOid('2.5.29.20', 'cRLNumber');
    addOid('2.5.29.21', 'cRLReason');
    addOid('2.5.29.22', 'expirationDate');
    addOid('2.5.29.23', 'instructionCode');
    addOid('2.5.29.24', 'invalidityDate');
    addOid('2.5.29.25', 'cRLDistributionPoints'); // deprecated use .31
    addOid('2.5.29.26', 'issuingDistributionPoint'); // deprecated use .28
    addOid('2.5.29.27', 'deltaCRLIndicator');
    addOid('2.5.29.28', 'issuingDistributionPoint');
    addOid('2.5.29.29', 'certificateIssuer');
    addOid('2.5.29.30', 'nameConstraints');
    addOid('2.5.29.31', 'cRLDistributionPoints');
    addOid('2.5.29.32', 'certificatePolicies');
    addOid('2.5.29.33', 'policyMappings');
    addOid('2.5.29.34', 'policyConstraints'); // deprecated use .36
    addOid('2.5.29.35', 'authorityKeyIdentifier');
    addOid('2.5.29.36', 'policyConstraints');
    addOid('2.5.29.37', 'extKeyUsage');
    addOid('2.5.29.46', 'freshestCRL');
    addOid('2.5.29.54', 'inhibitAnyPolicy');
    // extKeyUsage purposes
    addOid('1.3.6.1.4.1.11129.2.4.2', 'timestampList');
    addOid('1.3.6.1.5.5.7.1.1', 'authorityInfoAccess');
    addOid('1.3.6.1.5.5.7.3.1', 'serverAuth');
    addOid('1.3.6.1.5.5.7.3.2', 'clientAuth');
    addOid('1.3.6.1.5.5.7.3.3', 'codeSigning');
    addOid('1.3.6.1.5.5.7.3.4', 'emailProtection');
    addOid('1.3.6.1.5.5.7.3.8', 'timeStamping');

    /* src/components/decoders/CSR.svelte generated by Svelte v3.48.0 */
    const file$5 = "src/components/decoders/CSR.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (19:70) {:else}
    function create_else_block_1$1(ctx) {
    	let a;
    	let t_value = /*value*/ ctx[2].type + "";
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", a_href_value = "https://oid-rep.orange-labs.fr/get/" + /*value*/ ctx[2].type);
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$5, 18, 77, 554);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*certificateRequest*/ 1 && t_value !== (t_value = /*value*/ ctx[2].type + "")) set_data_dev(t, t_value);

    			if (dirty & /*certificateRequest*/ 1 && a_href_value !== (a_href_value = "https://oid-rep.orange-labs.fr/get/" + /*value*/ ctx[2].type)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(19:70) {:else}",
    		ctx
    	});

    	return block;
    }

    // (19:11) {#if oids[value.type]}
    function create_if_block_1$1(ctx) {
    	let t_value = camelCaseToString(oids[/*value*/ ctx[2].type]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*certificateRequest*/ 1 && t_value !== (t_value = camelCaseToString(oids[/*value*/ ctx[2].type]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(19:11) {#if oids[value.type]}",
    		ctx
    	});

    	return block;
    }

    // (16:4) {#each certificateRequest.subject.typesAndValues as value}
    function create_each_block$2(ctx) {
    	let tr;
    	let th;
    	let t0;
    	let td;
    	let t1_value = /*value*/ ctx[2].value.valueBlock.value + "";
    	let t1;
    	let t2;

    	function select_block_type(ctx, dirty) {
    		if (oids[/*value*/ ctx[2].type]) return create_if_block_1$1;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			th = element("th");
    			if_block.c();
    			t0 = space();
    			td = element("td");
    			t1 = text(t1_value);
    			t2 = space();
    			add_location(th, file$5, 17, 8, 473);
    			add_location(td, file$5, 23, 8, 713);
    			add_location(tr, file$5, 16, 6, 460);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, th);
    			if_block.m(th, null);
    			append_dev(tr, t0);
    			append_dev(tr, td);
    			append_dev(td, t1);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(th, null);
    				}
    			}

    			if (dirty & /*certificateRequest*/ 1 && t1_value !== (t1_value = /*value*/ ctx[2].value.valueBlock.value + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(16:4) {#each certificateRequest.subject.typesAndValues as value}",
    		ctx
    	});

    	return block;
    }

    // (38:12) {:else}
    function create_else_block$2(ctx) {
    	let a;
    	let t_value = /*certificateRequest*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId + "";
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", a_href_value = "https://oid-rep.orange-labs.fr/get/" + /*certificateRequest*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId);
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$5, 37, 19, 1138);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*certificateRequest*/ 1 && t_value !== (t_value = /*certificateRequest*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId + "")) set_data_dev(t, t_value);

    			if (dirty & /*certificateRequest*/ 1 && a_href_value !== (a_href_value = "https://oid-rep.orange-labs.fr/get/" + /*certificateRequest*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(38:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (36:9) {#if oids[certificateRequest.subjectPublicKeyInfo.algorithm.algorithmId]}
    function create_if_block$3(ctx) {
    	let t_value = camelCaseToString(oids[/*certificateRequest*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*certificateRequest*/ 1 && t_value !== (t_value = camelCaseToString(oids[/*certificateRequest*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(36:9) {#if oids[certificateRequest.subjectPublicKeyInfo.algorithm.algorithmId]}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let h2;
    	let t1;
    	let table;
    	let tbody0;
    	let tr0;
    	let td0;
    	let t3;
    	let div0;
    	let t4;
    	let t5;
    	let tbody1;
    	let tr1;
    	let td1;
    	let t7;
    	let div1;
    	let t8;
    	let tr2;
    	let th0;
    	let t10;
    	let td2;
    	let t11;
    	let tr3;
    	let th1;
    	let t13;
    	let td3;
    	let t14_value = arrayBufferToHex(/*certificateRequest*/ ctx[0].subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView).toUpperCase() + "";
    	let t14;
    	let t15;
    	let tr4;
    	let th2;
    	let t17;
    	let td4;
    	let t18_value = /*certificateRequest*/ ctx[0].signatureValue.valueBlock.valueHexView.length + "";
    	let t18;
    	let t19;
    	let t20_value = arrayBufferToHex(/*certificateRequest*/ ctx[0].signatureValue.valueBlock.valueHexView).toUpperCase() + "";
    	let t20;
    	let each_value = /*certificateRequest*/ ctx[0].subject.typesAndValues;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	function select_block_type_1(ctx, dirty) {
    		if (oids[/*certificateRequest*/ ctx[0].subjectPublicKeyInfo.algorithm.algorithmId]) return create_if_block$3;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Details";
    			t1 = space();
    			table = element("table");
    			tbody0 = element("tbody");
    			tr0 = element("tr");
    			td0 = element("td");
    			td0.textContent = "Requested Subject";
    			t3 = space();
    			div0 = element("div");
    			t4 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t5 = space();
    			tbody1 = element("tbody");
    			tr1 = element("tr");
    			td1 = element("td");
    			td1.textContent = "Public Key";
    			t7 = space();
    			div1 = element("div");
    			t8 = space();
    			tr2 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Algorithm";
    			t10 = space();
    			td2 = element("td");
    			if_block.c();
    			t11 = space();
    			tr3 = element("tr");
    			th1 = element("th");
    			th1.textContent = "Public Key";
    			t13 = space();
    			td3 = element("td");
    			t14 = text(t14_value);
    			t15 = space();
    			tr4 = element("tr");
    			th2 = element("th");
    			th2.textContent = "Signature";
    			t17 = space();
    			td4 = element("td");
    			t18 = text(t18_value);
    			t19 = text(" bytes:\n        ");
    			t20 = text(t20_value);
    			add_location(h2, file$5, 8, 0, 235);
    			add_location(td0, file$5, 12, 6, 327);
    			attr_dev(div0, "class", "line");
    			add_location(div0, file$5, 13, 6, 360);
    			attr_dev(tr0, "class", "section-header");
    			add_location(tr0, file$5, 11, 4, 293);
    			add_location(tbody0, file$5, 10, 2, 281);
    			add_location(td1, file$5, 29, 6, 836);
    			attr_dev(div1, "class", "line");
    			add_location(div1, file$5, 30, 6, 862);
    			attr_dev(tr1, "class", "section-header");
    			add_location(tr1, file$5, 28, 4, 802);
    			add_location(th0, file$5, 33, 6, 908);
    			add_location(td2, file$5, 34, 6, 933);
    			add_location(tr2, file$5, 32, 4, 897);
    			add_location(th1, file$5, 46, 6, 1436);
    			attr_dev(td3, "class", "bytes");
    			add_location(td3, file$5, 47, 6, 1462);
    			add_location(tr3, file$5, 45, 4, 1425);
    			add_location(th2, file$5, 55, 6, 1674);
    			attr_dev(td4, "class", "bytes");
    			add_location(td4, file$5, 56, 6, 1699);
    			add_location(tr4, file$5, 54, 4, 1663);
    			add_location(tbody1, file$5, 27, 2, 790);
    			attr_dev(table, "class", "properties");
    			add_location(table, file$5, 9, 0, 252);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, tbody0);
    			append_dev(tbody0, tr0);
    			append_dev(tr0, td0);
    			append_dev(tr0, t3);
    			append_dev(tr0, div0);
    			append_dev(tbody0, t4);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody0, null);
    			}

    			append_dev(table, t5);
    			append_dev(table, tbody1);
    			append_dev(tbody1, tr1);
    			append_dev(tr1, td1);
    			append_dev(tr1, t7);
    			append_dev(tr1, div1);
    			append_dev(tbody1, t8);
    			append_dev(tbody1, tr2);
    			append_dev(tr2, th0);
    			append_dev(tr2, t10);
    			append_dev(tr2, td2);
    			if_block.m(td2, null);
    			append_dev(tbody1, t11);
    			append_dev(tbody1, tr3);
    			append_dev(tr3, th1);
    			append_dev(tr3, t13);
    			append_dev(tr3, td3);
    			append_dev(td3, t14);
    			append_dev(tbody1, t15);
    			append_dev(tbody1, tr4);
    			append_dev(tr4, th2);
    			append_dev(tr4, t17);
    			append_dev(tr4, td4);
    			append_dev(td4, t18);
    			append_dev(td4, t19);
    			append_dev(td4, t20);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*certificateRequest, camelCaseToString, oids*/ 1) {
    				each_value = /*certificateRequest*/ ctx[0].subject.typesAndValues;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(td2, null);
    				}
    			}

    			if (dirty & /*certificateRequest*/ 1 && t14_value !== (t14_value = arrayBufferToHex(/*certificateRequest*/ ctx[0].subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView).toUpperCase() + "")) set_data_dev(t14, t14_value);
    			if (dirty & /*certificateRequest*/ 1 && t18_value !== (t18_value = /*certificateRequest*/ ctx[0].signatureValue.valueBlock.valueHexView.length + "")) set_data_dev(t18, t18_value);
    			if (dirty & /*certificateRequest*/ 1 && t20_value !== (t20_value = arrayBufferToHex(/*certificateRequest*/ ctx[0].signatureValue.valueBlock.valueHexView).toUpperCase() + "")) set_data_dev(t20, t20_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let certificateRequest;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CSR', slots, []);
    	let { result } = $$props;
    	const writable_props = ['result'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CSR> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('result' in $$props) $$invalidate(1, result = $$props.result);
    	};

    	$$self.$capture_state = () => ({
    		oids,
    		camelCaseToString,
    		arrayBufferToHex,
    		result,
    		certificateRequest
    	});

    	$$self.$inject_state = $$props => {
    		if ('result' in $$props) $$invalidate(1, result = $$props.result);
    		if ('certificateRequest' in $$props) $$invalidate(0, certificateRequest = $$props.certificateRequest);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*result*/ 2) {
    			$$invalidate(0, certificateRequest = result.value);
    		}
    	};

    	return [certificateRequest, result];
    }

    class CSR extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { result: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CSR",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*result*/ ctx[1] === undefined && !('result' in props)) {
    			console.warn("<CSR> was created without expected prop 'result'");
    		}
    	}

    	get result() {
    		throw new Error("<CSR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set result(value) {
    		throw new Error("<CSR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var csrDecoder = {
        name: "PKCS #10",
        fullName: "Certification Signing Request",
        rfc: 2986,
        inputType: "asn1",
        outputType: "csr",
        display: CSR,
        f: (asn1) => {
            try {
                let cert = new CertificationRequest({ schema: asn1 });
                return [cert, null];
            }
            catch (_a) {
                return [null, null];
            }
        }
    };

    const pemRegex = /-----BEGIN (.*?)-----\n?((?:(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}(?:=)?)?\n?)+)\n?-----END (.*?)-----[\n\r]*/;
    var pemDecoder = {
        name: "PEM",
        fullName: "Privacy-Enhanced Mail",
        rfc: 7468,
        inputType: "text",
        outputType: "bytes",
        f: (text) => {
            pemRegex.lastIndex = 0;
            let r = text.match(pemRegex);
            if (r && r.length == 4) {
                return [base64ToArrayBuffer(r[2].replace(/\n/g, "")), null];
            }
            else {
                return [null, null];
            }
        }
    };

    /* src/components/decoders/CMS.svelte generated by Svelte v3.48.0 */
    const file$4 = "src/components/decoders/CMS.svelte";

    function create_fragment$4(ctx) {
    	let h2;
    	let t1;
    	let p;
    	let t2;
    	let t3_value = (/*signatureValid*/ ctx[0] ? "Yes" : "No") + "";
    	let t3;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Details";
    			t1 = space();
    			p = element("p");
    			t2 = text("Signature valid: ");
    			t3 = text(t3_value);
    			add_location(h2, file$4, 20, 0, 375);
    			add_location(p, file$4, 21, 0, 392);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t2);
    			append_dev(p, t3);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*signatureValid*/ 1 && t3_value !== (t3_value = (/*signatureValid*/ ctx[0] ? "Yes" : "No") + "")) set_data_dev(t3, t3_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let signedData;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CMS', slots, []);
    	let { result } = $$props;
    	let signatureValid = false;
    	const writable_props = ['result'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CMS> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('result' in $$props) $$invalidate(1, result = $$props.result);
    	};

    	$$self.$capture_state = () => ({ result, signatureValid, signedData });

    	$$self.$inject_state = $$props => {
    		if ('result' in $$props) $$invalidate(1, result = $$props.result);
    		if ('signatureValid' in $$props) $$invalidate(0, signatureValid = $$props.signatureValid);
    		if ('signedData' in $$props) $$invalidate(2, signedData = $$props.signedData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*result*/ 2) {
    			$$invalidate(2, signedData = result.displayProps);
    		}

    		if ($$self.$$.dirty & /*signedData*/ 4) {
    			{
    				signedData.verify({ signer: 0, checkChain: false }).then(valid => {
    					$$invalidate(0, signatureValid = valid);
    				}).catch(() => {
    					$$invalidate(0, signatureValid = false);
    				});
    			}
    		}
    	};

    	return [signatureValid, result, signedData];
    }

    class CMS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { result: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CMS",
    			options,
    			id: create_fragment$4.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*result*/ ctx[1] === undefined && !('result' in props)) {
    			console.warn("<CMS> was created without expected prop 'result'");
    		}
    	}

    	get result() {
    		throw new Error("<CMS>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set result(value) {
    		throw new Error("<CMS>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var cmsDecoder = {
        name: "PKCS #7",
        fullName: "Cryptographic Message Syntax",
        rfc: 5652,
        inputType: "asn1",
        outputType: "bytes",
        display: CMS,
        f: (asn1) => {
            try {
                let cms = new ContentInfo({ schema: asn1 });
                if (cms.contentType == ContentInfo.SIGNED_DATA) {
                    let signedData = new SignedData({ schema: cms.content });
                    return [signedData.encapContentInfo.eContent.getValue(), signedData];
                }
                else {
                    return [null, null];
                }
            }
            catch (err) {
                return [null, null];
            }
        }
    };

    var uriencodingDecoder = {
        name: "URI Encoding",
        rfc: 3986,
        inputType: "text",
        outputType: "text",
        f: (text) => {
            try {
                let decoded = decodeURIComponent(text);
                if (decoded != text) {
                    return [decoded, null];
                }
                else {
                    return [null, null];
                }
            }
            catch (_a) {
                return [null, null];
            }
        }
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /*! For license information please see cbor.js.LICENSE.txt */

    var cbor = createCommonjsModule(function (module, exports) {
    !function(e,t){module.exports=t();}(commonjsGlobal,(function(){return (()=>{var e={742:(e,t)=>{t.byteLength=function(e){var t=u(e),r=t[0],n=t[1];return 3*(r+n)/4-n},t.toByteArray=function(e){var t,r,o=u(e),s=o[0],a=o[1],f=new i(function(e,t,r){return 3*(t+r)/4-r}(0,s,a)),h=0,l=a>0?s-4:s;for(r=0;r<l;r+=4)t=n[e.charCodeAt(r)]<<18|n[e.charCodeAt(r+1)]<<12|n[e.charCodeAt(r+2)]<<6|n[e.charCodeAt(r+3)],f[h++]=t>>16&255,f[h++]=t>>8&255,f[h++]=255&t;return 2===a&&(t=n[e.charCodeAt(r)]<<2|n[e.charCodeAt(r+1)]>>4,f[h++]=255&t),1===a&&(t=n[e.charCodeAt(r)]<<10|n[e.charCodeAt(r+1)]<<4|n[e.charCodeAt(r+2)]>>2,f[h++]=t>>8&255,f[h++]=255&t),f},t.fromByteArray=function(e){for(var t,n=e.length,i=n%3,o=[],s=16383,a=0,u=n-i;a<u;a+=s)o.push(f(e,a,a+s>u?u:a+s));return 1===i?(t=e[n-1],o.push(r[t>>2]+r[t<<4&63]+"==")):2===i&&(t=(e[n-2]<<8)+e[n-1],o.push(r[t>>10]+r[t>>4&63]+r[t<<2&63]+"=")),o.join("")};for(var r=[],n=[],i="undefined"!=typeof Uint8Array?Uint8Array:Array,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,a=o.length;s<a;++s)r[s]=o[s],n[o.charCodeAt(s)]=s;function u(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");return -1===r&&(r=t),[r,r===t?0:4-r%4]}function f(e,t,n){for(var i,o,s=[],a=t;a<n;a+=3)i=(e[a]<<16&16711680)+(e[a+1]<<8&65280)+(255&e[a+2]),s.push(r[(o=i)>>18&63]+r[o>>12&63]+r[o>>6&63]+r[63&o]);return s.join("")}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63;},764:(e,t,r)=>{const n=r(742),i=r(645),o="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;t.Buffer=u,t.SlowBuffer=function(e){return +e!=e&&(e=0),u.alloc(+e)},t.INSPECT_MAX_BYTES=50;const s=2147483647;function a(e){if(e>s)throw new RangeError('The value "'+e+'" is invalid for option "size"');const t=new Uint8Array(e);return Object.setPrototypeOf(t,u.prototype),t}function u(e,t,r){if("number"==typeof e){if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return l(e)}return f(e,t,r)}function f(e,t,r){if("string"==typeof e)return function(e,t){if("string"==typeof t&&""!==t||(t="utf8"),!u.isEncoding(t))throw new TypeError("Unknown encoding: "+t);const r=0|g(e,t);let n=a(r);const i=n.write(e,t);return i!==r&&(n=n.slice(0,i)),n}(e,t);if(ArrayBuffer.isView(e))return function(e){if(z(e,Uint8Array)){const t=new Uint8Array(e);return d(t.buffer,t.byteOffset,t.byteLength)}return c(e)}(e);if(null==e)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(z(e,ArrayBuffer)||e&&z(e.buffer,ArrayBuffer))return d(e,t,r);if("undefined"!=typeof SharedArrayBuffer&&(z(e,SharedArrayBuffer)||e&&z(e.buffer,SharedArrayBuffer)))return d(e,t,r);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');const n=e.valueOf&&e.valueOf();if(null!=n&&n!==e)return u.from(n,t,r);const i=function(e){if(u.isBuffer(e)){const t=0|p(e.length),r=a(t);return 0===r.length||e.copy(r,0,0,t),r}return void 0!==e.length?"number"!=typeof e.length||J(e.length)?a(0):c(e):"Buffer"===e.type&&Array.isArray(e.data)?c(e.data):void 0}(e);if(i)return i;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return u.from(e[Symbol.toPrimitive]("string"),t,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function h(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function l(e){return h(e),a(e<0?0:0|p(e))}function c(e){const t=e.length<0?0:0|p(e.length),r=a(t);for(let n=0;n<t;n+=1)r[n]=255&e[n];return r}function d(e,t,r){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(r||0))throw new RangeError('"length" is outside of buffer bounds');let n;return n=void 0===t&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,t):new Uint8Array(e,t,r),Object.setPrototypeOf(n,u.prototype),n}function p(e){if(e>=s)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s.toString(16)+" bytes");return 0|e}function g(e,t){if(u.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||z(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);const r=e.length,n=arguments.length>2&&!0===arguments[2];if(!n&&0===r)return 0;let i=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return H(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return K(e).length;default:if(i)return n?-1:H(e).length;t=(""+t).toLowerCase(),i=!0;}}function y(e,t,r){let n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return "";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return "";if((r>>>=0)<=(t>>>=0))return "";for(e||(e="utf8");;)switch(e){case"hex":return L(this,t,r);case"utf8":case"utf-8":return A(this,t,r);case"ascii":return R(this,t,r);case"latin1":case"binary":return U(this,t,r);case"base64":return I(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return N(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0;}}function b(e,t,r){const n=e[t];e[t]=e[r],e[r]=n;}function w(e,t,r,n,i){if(0===e.length)return -1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),J(r=+r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return -1;r=e.length-1;}else if(r<0){if(!i)return -1;r=0;}if("string"==typeof t&&(t=u.from(t,n)),u.isBuffer(t))return 0===t.length?-1:_(e,t,r,n,i);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):_(e,[t],r,n,i);throw new TypeError("val must be string, number or Buffer")}function _(e,t,r,n,i){let o,s=1,a=e.length,u=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return -1;s=2,a/=2,u/=2,r/=2;}function f(e,t){return 1===s?e[t]:e.readUInt16BE(t*s)}if(i){let n=-1;for(o=r;o<a;o++)if(f(e,o)===f(t,-1===n?0:o-n)){if(-1===n&&(n=o),o-n+1===u)return n*s}else -1!==n&&(o-=o-n),n=-1;}else for(r+u>a&&(r=a-u),o=r;o>=0;o--){let r=!0;for(let n=0;n<u;n++)if(f(e,o+n)!==f(t,n)){r=!1;break}if(r)return o}return -1}function m(e,t,r,n){r=Number(r)||0;const i=e.length-r;n?(n=Number(n))>i&&(n=i):n=i;const o=t.length;let s;for(n>o/2&&(n=o/2),s=0;s<n;++s){const n=parseInt(t.substr(2*s,2),16);if(J(n))return s;e[r+s]=n;}return s}function E(e,t,r,n){return V(H(t,e.length-r),e,r,n)}function v(e,t,r,n){return V(function(e){const t=[];for(let r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function S(e,t,r,n){return V(K(t),e,r,n)}function T(e,t,r,n){return V(function(e,t){let r,n,i;const o=[];for(let s=0;s<e.length&&!((t-=2)<0);++s)r=e.charCodeAt(s),n=r>>8,i=r%256,o.push(i),o.push(n);return o}(t,e.length-r),e,r,n)}function I(e,t,r){return 0===t&&r===e.length?n.fromByteArray(e):n.fromByteArray(e.slice(t,r))}function A(e,t,r){r=Math.min(e.length,r);const n=[];let i=t;for(;i<r;){const t=e[i];let o=null,s=t>239?4:t>223?3:t>191?2:1;if(i+s<=r){let r,n,a,u;switch(s){case 1:t<128&&(o=t);break;case 2:r=e[i+1],128==(192&r)&&(u=(31&t)<<6|63&r,u>127&&(o=u));break;case 3:r=e[i+1],n=e[i+2],128==(192&r)&&128==(192&n)&&(u=(15&t)<<12|(63&r)<<6|63&n,u>2047&&(u<55296||u>57343)&&(o=u));break;case 4:r=e[i+1],n=e[i+2],a=e[i+3],128==(192&r)&&128==(192&n)&&128==(192&a)&&(u=(15&t)<<18|(63&r)<<12|(63&n)<<6|63&a,u>65535&&u<1114112&&(o=u));}}null===o?(o=65533,s=1):o>65535&&(o-=65536,n.push(o>>>10&1023|55296),o=56320|1023&o),n.push(o),i+=s;}return function(e){const t=e.length;if(t<=B)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=B));return r}(n)}t.kMaxLength=s,u.TYPED_ARRAY_SUPPORT=function(){try{const e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return !1}}(),u.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(u.prototype,"parent",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.buffer}}),Object.defineProperty(u.prototype,"offset",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.byteOffset}}),u.poolSize=8192,u.from=function(e,t,r){return f(e,t,r)},Object.setPrototypeOf(u.prototype,Uint8Array.prototype),Object.setPrototypeOf(u,Uint8Array),u.alloc=function(e,t,r){return function(e,t,r){return h(e),e<=0?a(e):void 0!==t?"string"==typeof r?a(e).fill(t,r):a(e).fill(t):a(e)}(e,t,r)},u.allocUnsafe=function(e){return l(e)},u.allocUnsafeSlow=function(e){return l(e)},u.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==u.prototype},u.compare=function(e,t){if(z(e,Uint8Array)&&(e=u.from(e,e.offset,e.byteLength)),z(t,Uint8Array)&&(t=u.from(t,t.offset,t.byteLength)),!u.isBuffer(e)||!u.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let r=e.length,n=t.length;for(let i=0,o=Math.min(r,n);i<o;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0},u.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return !0;default:return !1}},u.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return u.alloc(0);let r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;const n=u.allocUnsafe(t);let i=0;for(r=0;r<e.length;++r){let t=e[r];if(z(t,Uint8Array))i+t.length>n.length?(u.isBuffer(t)||(t=u.from(t)),t.copy(n,i)):Uint8Array.prototype.set.call(n,t,i);else {if(!u.isBuffer(t))throw new TypeError('"list" argument must be an Array of Buffers');t.copy(n,i);}i+=t.length;}return n},u.byteLength=g,u.prototype._isBuffer=!0,u.prototype.swap16=function(){const e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)b(this,t,t+1);return this},u.prototype.swap32=function(){const e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)b(this,t,t+3),b(this,t+1,t+2);return this},u.prototype.swap64=function(){const e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)b(this,t,t+7),b(this,t+1,t+6),b(this,t+2,t+5),b(this,t+3,t+4);return this},u.prototype.toString=function(){const e=this.length;return 0===e?"":0===arguments.length?A(this,0,e):y.apply(this,arguments)},u.prototype.toLocaleString=u.prototype.toString,u.prototype.equals=function(e){if(!u.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===u.compare(this,e)},u.prototype.inspect=function(){let e="";const r=t.INSPECT_MAX_BYTES;return e=this.toString("hex",0,r).replace(/(.{2})/g,"$1 ").trim(),this.length>r&&(e+=" ... "),"<Buffer "+e+">"},o&&(u.prototype[o]=u.prototype.inspect),u.prototype.compare=function(e,t,r,n,i){if(z(e,Uint8Array)&&(e=u.from(e,e.offset,e.byteLength)),!u.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&t>=r)return 0;if(n>=i)return -1;if(t>=r)return 1;if(this===e)return 0;let o=(i>>>=0)-(n>>>=0),s=(r>>>=0)-(t>>>=0);const a=Math.min(o,s),f=this.slice(n,i),h=e.slice(t,r);for(let e=0;e<a;++e)if(f[e]!==h[e]){o=f[e],s=h[e];break}return o<s?-1:s<o?1:0},u.prototype.includes=function(e,t,r){return -1!==this.indexOf(e,t,r)},u.prototype.indexOf=function(e,t,r){return w(this,e,t,r,!0)},u.prototype.lastIndexOf=function(e,t,r){return w(this,e,t,r,!1)},u.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else {if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(r)?(r>>>=0,void 0===n&&(n="utf8")):(n=r,r=void 0);}const i=this.length-t;if((void 0===r||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");let o=!1;for(;;)switch(n){case"hex":return m(this,e,t,r);case"utf8":case"utf-8":return E(this,e,t,r);case"ascii":case"latin1":case"binary":return v(this,e,t,r);case"base64":return S(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return T(this,e,t,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0;}},u.prototype.toJSON=function(){return {type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const B=4096;function R(e,t,r){let n="";r=Math.min(e.length,r);for(let i=t;i<r;++i)n+=String.fromCharCode(127&e[i]);return n}function U(e,t,r){let n="";r=Math.min(e.length,r);for(let i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function L(e,t,r){const n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);let i="";for(let n=t;n<r;++n)i+=X[e[n]];return i}function N(e,t,r){const n=e.slice(t,r);let i="";for(let e=0;e<n.length-1;e+=2)i+=String.fromCharCode(n[e]+256*n[e+1]);return i}function M(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function O(e,t,r,n,i,o){if(!u.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<o)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function x(e,t,r,n,i){G(t,n,i,e,r,7);let o=Number(t&BigInt(4294967295));e[r++]=o,o>>=8,e[r++]=o,o>>=8,e[r++]=o,o>>=8,e[r++]=o;let s=Number(t>>BigInt(32)&BigInt(4294967295));return e[r++]=s,s>>=8,e[r++]=s,s>>=8,e[r++]=s,s>>=8,e[r++]=s,r}function k(e,t,r,n,i){G(t,n,i,e,r,7);let o=Number(t&BigInt(4294967295));e[r+7]=o,o>>=8,e[r+6]=o,o>>=8,e[r+5]=o,o>>=8,e[r+4]=o;let s=Number(t>>BigInt(32)&BigInt(4294967295));return e[r+3]=s,s>>=8,e[r+2]=s,s>>=8,e[r+1]=s,s>>=8,e[r]=s,r+8}function P(e,t,r,n,i,o){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function j(e,t,r,n,o){return t=+t,r>>>=0,o||P(e,0,r,4),i.write(e,t,r,n,23,4),r+4}function C(e,t,r,n,o){return t=+t,r>>>=0,o||P(e,0,r,8),i.write(e,t,r,n,52,8),r+8}u.prototype.slice=function(e,t){const r=this.length;(e=~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),(t=void 0===t?r:~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e);const n=this.subarray(e,t);return Object.setPrototypeOf(n,u.prototype),n},u.prototype.readUintLE=u.prototype.readUIntLE=function(e,t,r){e>>>=0,t>>>=0,r||M(e,t,this.length);let n=this[e],i=1,o=0;for(;++o<t&&(i*=256);)n+=this[e+o]*i;return n},u.prototype.readUintBE=u.prototype.readUIntBE=function(e,t,r){e>>>=0,t>>>=0,r||M(e,t,this.length);let n=this[e+--t],i=1;for(;t>0&&(i*=256);)n+=this[e+--t]*i;return n},u.prototype.readUint8=u.prototype.readUInt8=function(e,t){return e>>>=0,t||M(e,1,this.length),this[e]},u.prototype.readUint16LE=u.prototype.readUInt16LE=function(e,t){return e>>>=0,t||M(e,2,this.length),this[e]|this[e+1]<<8},u.prototype.readUint16BE=u.prototype.readUInt16BE=function(e,t){return e>>>=0,t||M(e,2,this.length),this[e]<<8|this[e+1]},u.prototype.readUint32LE=u.prototype.readUInt32LE=function(e,t){return e>>>=0,t||M(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},u.prototype.readUint32BE=u.prototype.readUInt32BE=function(e,t){return e>>>=0,t||M(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},u.prototype.readBigUInt64LE=Q((function(e){W(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||Y(e,this.length-8);const n=t+256*this[++e]+65536*this[++e]+this[++e]*2**24,i=this[++e]+256*this[++e]+65536*this[++e]+r*2**24;return BigInt(n)+(BigInt(i)<<BigInt(32))})),u.prototype.readBigUInt64BE=Q((function(e){W(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||Y(e,this.length-8);const n=t*2**24+65536*this[++e]+256*this[++e]+this[++e],i=this[++e]*2**24+65536*this[++e]+256*this[++e]+r;return (BigInt(n)<<BigInt(32))+BigInt(i)})),u.prototype.readIntLE=function(e,t,r){e>>>=0,t>>>=0,r||M(e,t,this.length);let n=this[e],i=1,o=0;for(;++o<t&&(i*=256);)n+=this[e+o]*i;return i*=128,n>=i&&(n-=Math.pow(2,8*t)),n},u.prototype.readIntBE=function(e,t,r){e>>>=0,t>>>=0,r||M(e,t,this.length);let n=t,i=1,o=this[e+--n];for(;n>0&&(i*=256);)o+=this[e+--n]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*t)),o},u.prototype.readInt8=function(e,t){return e>>>=0,t||M(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},u.prototype.readInt16LE=function(e,t){e>>>=0,t||M(e,2,this.length);const r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt16BE=function(e,t){e>>>=0,t||M(e,2,this.length);const r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt32LE=function(e,t){return e>>>=0,t||M(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},u.prototype.readInt32BE=function(e,t){return e>>>=0,t||M(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},u.prototype.readBigInt64LE=Q((function(e){W(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||Y(e,this.length-8);const n=this[e+4]+256*this[e+5]+65536*this[e+6]+(r<<24);return (BigInt(n)<<BigInt(32))+BigInt(t+256*this[++e]+65536*this[++e]+this[++e]*2**24)})),u.prototype.readBigInt64BE=Q((function(e){W(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||Y(e,this.length-8);const n=(t<<24)+65536*this[++e]+256*this[++e]+this[++e];return (BigInt(n)<<BigInt(32))+BigInt(this[++e]*2**24+65536*this[++e]+256*this[++e]+r)})),u.prototype.readFloatLE=function(e,t){return e>>>=0,t||M(e,4,this.length),i.read(this,e,!0,23,4)},u.prototype.readFloatBE=function(e,t){return e>>>=0,t||M(e,4,this.length),i.read(this,e,!1,23,4)},u.prototype.readDoubleLE=function(e,t){return e>>>=0,t||M(e,8,this.length),i.read(this,e,!0,52,8)},u.prototype.readDoubleBE=function(e,t){return e>>>=0,t||M(e,8,this.length),i.read(this,e,!1,52,8)},u.prototype.writeUintLE=u.prototype.writeUIntLE=function(e,t,r,n){e=+e,t>>>=0,r>>>=0,n||O(this,e,t,r,Math.pow(2,8*r)-1,0);let i=1,o=0;for(this[t]=255&e;++o<r&&(i*=256);)this[t+o]=e/i&255;return t+r},u.prototype.writeUintBE=u.prototype.writeUIntBE=function(e,t,r,n){e=+e,t>>>=0,r>>>=0,n||O(this,e,t,r,Math.pow(2,8*r)-1,0);let i=r-1,o=1;for(this[t+i]=255&e;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+r},u.prototype.writeUint8=u.prototype.writeUInt8=function(e,t,r){return e=+e,t>>>=0,r||O(this,e,t,1,255,0),this[t]=255&e,t+1},u.prototype.writeUint16LE=u.prototype.writeUInt16LE=function(e,t,r){return e=+e,t>>>=0,r||O(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},u.prototype.writeUint16BE=u.prototype.writeUInt16BE=function(e,t,r){return e=+e,t>>>=0,r||O(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},u.prototype.writeUint32LE=u.prototype.writeUInt32LE=function(e,t,r){return e=+e,t>>>=0,r||O(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},u.prototype.writeUint32BE=u.prototype.writeUInt32BE=function(e,t,r){return e=+e,t>>>=0,r||O(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},u.prototype.writeBigUInt64LE=Q((function(e,t=0){return x(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),u.prototype.writeBigUInt64BE=Q((function(e,t=0){return k(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),u.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t>>>=0,!n){const n=Math.pow(2,8*r-1);O(this,e,t,r,n-1,-n);}let i=0,o=1,s=0;for(this[t]=255&e;++i<r&&(o*=256);)e<0&&0===s&&0!==this[t+i-1]&&(s=1),this[t+i]=(e/o>>0)-s&255;return t+r},u.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t>>>=0,!n){const n=Math.pow(2,8*r-1);O(this,e,t,r,n-1,-n);}let i=r-1,o=1,s=0;for(this[t+i]=255&e;--i>=0&&(o*=256);)e<0&&0===s&&0!==this[t+i+1]&&(s=1),this[t+i]=(e/o>>0)-s&255;return t+r},u.prototype.writeInt8=function(e,t,r){return e=+e,t>>>=0,r||O(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},u.prototype.writeInt16LE=function(e,t,r){return e=+e,t>>>=0,r||O(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},u.prototype.writeInt16BE=function(e,t,r){return e=+e,t>>>=0,r||O(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},u.prototype.writeInt32LE=function(e,t,r){return e=+e,t>>>=0,r||O(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},u.prototype.writeInt32BE=function(e,t,r){return e=+e,t>>>=0,r||O(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},u.prototype.writeBigInt64LE=Q((function(e,t=0){return x(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),u.prototype.writeBigInt64BE=Q((function(e,t=0){return k(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),u.prototype.writeFloatLE=function(e,t,r){return j(this,e,t,!0,r)},u.prototype.writeFloatBE=function(e,t,r){return j(this,e,t,!1,r)},u.prototype.writeDoubleLE=function(e,t,r){return C(this,e,t,!0,r)},u.prototype.writeDoubleBE=function(e,t,r){return C(this,e,t,!1,r)},u.prototype.copy=function(e,t,r,n){if(!u.isBuffer(e))throw new TypeError("argument should be a Buffer");if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);const i=n-r;return this===e&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(t,r,n):Uint8Array.prototype.set.call(e,this.subarray(r,n),t),i},u.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!u.isEncoding(n))throw new TypeError("Unknown encoding: "+n);if(1===e.length){const t=e.charCodeAt(0);("utf8"===n&&t<128||"latin1"===n)&&(e=t);}}else "number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;let i;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(i=t;i<r;++i)this[i]=e;else {const o=u.isBuffer(e)?e:u.from(e,n),s=o.length;if(0===s)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(i=0;i<r-t;++i)this[i+t]=o[i%s];}return this};const F={};function D(e,t,r){F[e]=class extends r{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name;}get code(){return e}set code(e){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:e,writable:!0});}toString(){return `${this.name} [${e}]: ${this.message}`}};}function $(e){let t="",r=e.length;const n="-"===e[0]?1:0;for(;r>=n+4;r-=3)t=`_${e.slice(r-3,r)}${t}`;return `${e.slice(0,r)}${t}`}function G(e,t,r,n,i,o){if(e>r||e<t){const n="bigint"==typeof t?"n":"";let i;throw i=o>3?0===t||t===BigInt(0)?`>= 0${n} and < 2${n} ** ${8*(o+1)}${n}`:`>= -(2${n} ** ${8*(o+1)-1}${n}) and < 2 ** ${8*(o+1)-1}${n}`:`>= ${t}${n} and <= ${r}${n}`,new F.ERR_OUT_OF_RANGE("value",i,e)}!function(e,t,r){W(t,"offset"),void 0!==e[t]&&void 0!==e[t+r]||Y(t,e.length-(r+1));}(n,i,o);}function W(e,t){if("number"!=typeof e)throw new F.ERR_INVALID_ARG_TYPE(t,"number",e)}function Y(e,t,r){if(Math.floor(e)!==e)throw W(e,r),new F.ERR_OUT_OF_RANGE(r||"offset","an integer",e);if(t<0)throw new F.ERR_BUFFER_OUT_OF_BOUNDS;throw new F.ERR_OUT_OF_RANGE(r||"offset",`>= ${r?1:0} and <= ${t}`,e)}D("ERR_BUFFER_OUT_OF_BOUNDS",(function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),D("ERR_INVALID_ARG_TYPE",(function(e,t){return `The "${e}" argument must be of type number. Received type ${typeof t}`}),TypeError),D("ERR_OUT_OF_RANGE",(function(e,t,r){let n=`The value of "${e}" is out of range.`,i=r;return Number.isInteger(r)&&Math.abs(r)>2**32?i=$(String(r)):"bigint"==typeof r&&(i=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(i=$(i)),i+="n"),n+=` It must be ${t}. Received ${i}`,n}),RangeError);const q=/[^+/0-9A-Za-z-_]/g;function H(e,t){let r;t=t||1/0;const n=e.length;let i=null;const o=[];for(let s=0;s<n;++s){if(r=e.charCodeAt(s),r>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&o.push(239,191,189);continue}if(s+1===n){(t-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320);}else i&&(t-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;o.push(r);}else if(r<2048){if((t-=2)<0)break;o.push(r>>6|192,63&r|128);}else if(r<65536){if((t-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128);}else {if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128);}}return o}function K(e){return n.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(q,"")).length<2)return "";for(;e.length%4!=0;)e+="=";return e}(e))}function V(e,t,r,n){let i;for(i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}function z(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function J(e){return e!=e}const X=function(){const e="0123456789abcdef",t=new Array(256);for(let r=0;r<16;++r){const n=16*r;for(let i=0;i<16;++i)t[n+i]=e[r]+e[i];}return t}();function Q(e){return "undefined"==typeof BigInt?Z:e}function Z(){throw new Error("BigInt not supported")}},141:(e,t,r)=>{t.Commented=r(20),t.Diagnose=r(694),t.Decoder=r(774),t.Encoder=r(666),t.Simple=r(32),t.Tagged=r(785),t.Map=r(70),t.UI=t.Commented.comment,t.fI=t.Decoder.decodeAll,t.h8=t.Decoder.decodeFirst,t.cc=t.Decoder.decodeAllSync,t.$u=t.Decoder.decodeFirstSync,t.M=t.Diagnose.diagnose,t.cv=t.Encoder.encode,t.N2=t.Encoder.encodeCanonical,t.TG=t.Encoder.encodeOne,t.WR=t.Encoder.encodeAsync,t.Jx=t.Decoder.decodeFirstSync,t.ww={decode:t.Decoder.decodeFirstSync,encode:t.Encoder.encode,buffer:!0,name:"cbor"},t.mc=function(){t.Encoder.reset(),t.Tagged.reset();};},20:(e,t,r)=>{const n=r(830),i=r(873),o=r(774),s=r(202),{MT:a,NUMBYTES:u,SYMS:f}=r(66),{Buffer:h}=r(764);function l(e){return e>1?"s":""}class c extends n.Transform{constructor(e={}){const{depth:t=1,max_depth:r=10,no_summary:n=!1,tags:i={},preferWeb:a,encoding:u,...f}=e;super({...f,readableObjectMode:!1,writableObjectMode:!1}),this.depth=t,this.max_depth=r,this.all=new s,i[24]||(i[24]=this._tag_24.bind(this)),this.parser=new o({tags:i,max_depth:r,preferWeb:a,encoding:u}),this.parser.on("value",this._on_value.bind(this)),this.parser.on("start",this._on_start.bind(this)),this.parser.on("start-string",this._on_start_string.bind(this)),this.parser.on("stop",this._on_stop.bind(this)),this.parser.on("more-bytes",this._on_more.bind(this)),this.parser.on("error",this._on_error.bind(this)),n||this.parser.on("data",this._on_data.bind(this)),this.parser.bs.on("read",this._on_read.bind(this));}_tag_24(e){const t=new c({depth:this.depth+1,no_summary:!0});t.on("data",(e=>this.push(e))),t.on("error",(e=>this.emit("error",e))),t.end(e);}_transform(e,t,r){this.parser.write(e,t,r);}_flush(e){return this.parser._flush(e)}static comment(e,t={},r=null){if(null==e)throw new Error("input required");({options:t,cb:r}=function(e,t){switch(typeof e){case"function":return {options:{},cb:e};case"string":return {options:{encoding:e},cb:t};case"number":return {options:{max_depth:e},cb:t};case"object":return {options:e||{},cb:t};default:throw new TypeError("Unknown option type")}}(t,r));const n=new s,{encoding:o="hex",...a}=t,u=new c(a);let f=null;return "function"==typeof r?(u.on("end",(()=>{r(null,n.toString("utf8"));})),u.on("error",r)):f=new Promise(((e,t)=>{u.on("end",(()=>{e(n.toString("utf8"));})),u.on("error",t);})),u.pipe(n),i.guessEncoding(e,o).pipe(u),f}_on_error(e){this.push("ERROR: "),this.push(e.toString()),this.push("\n");}_on_read(e){this.all.write(e);const t=e.toString("hex");this.push(new Array(this.depth+1).join("  ")),this.push(t);let r=2*(this.max_depth-this.depth)-t.length;r<1&&(r=1),this.push(new Array(r+1).join(" ")),this.push("-- ");}_on_more(e,t,r,n){let i="";switch(this.depth++,e){case a.POS_INT:i="Positive number,";break;case a.NEG_INT:i="Negative number,";break;case a.ARRAY:i="Array, length";break;case a.MAP:i="Map, count";break;case a.BYTE_STRING:i="Bytes, length";break;case a.UTF8_STRING:i="String, length";break;case a.SIMPLE_FLOAT:i=1===t?"Simple value,":"Float,";}this.push(`${i} next ${t} byte${l(t)}\n`);}_on_start_string(e,t,r,n){let i="";switch(this.depth++,e){case a.BYTE_STRING:i=`Bytes, length: ${t}`;break;case a.UTF8_STRING:i=`String, length: ${t.toString()}`;}this.push(`${i}\n`);}_on_start(e,t,r,n){switch(this.depth++,r){case a.ARRAY:this.push(`[${n}], `);break;case a.MAP:n%2?this.push(`{Val:${Math.floor(n/2)}}, `):this.push(`{Key:${Math.floor(n/2)}}, `);}switch(e){case a.TAG:this.push(`Tag #${t}`),24===t&&this.push(" Encoded CBOR data item");break;case a.ARRAY:t===f.STREAM?this.push("Array (streaming)"):this.push(`Array, ${t} item${l(t)}`);break;case a.MAP:t===f.STREAM?this.push("Map (streaming)"):this.push(`Map, ${t} pair${l(t)}`);break;case a.BYTE_STRING:this.push("Bytes (streaming)");break;case a.UTF8_STRING:this.push("String (streaming)");}this.push("\n");}_on_stop(e){this.depth--;}_on_value(e,t,r,n){if(e!==f.BREAK)switch(t){case a.ARRAY:this.push(`[${r}], `);break;case a.MAP:r%2?this.push(`{Val:${Math.floor(r/2)}}, `):this.push(`{Key:${Math.floor(r/2)}}, `);}const o=i.cborValueToString(e,-1/0);switch("string"==typeof e||h.isBuffer(e)?(e.length>0&&(this.push(o),this.push("\n")),this.depth--):(this.push(o),this.push("\n")),n){case u.ONE:case u.TWO:case u.FOUR:case u.EIGHT:this.depth--;}}_on_data(){this.push("0x"),this.push(this.all.read().toString("hex")),this.push("\n");}}e.exports=c;},66:(e,t)=>{t.MT={POS_INT:0,NEG_INT:1,BYTE_STRING:2,UTF8_STRING:3,ARRAY:4,MAP:5,TAG:6,SIMPLE_FLOAT:7},t.TAG={DATE_STRING:0,DATE_EPOCH:1,POS_BIGINT:2,NEG_BIGINT:3,DECIMAL_FRAC:4,BIGFLOAT:5,BASE64URL_EXPECTED:21,BASE64_EXPECTED:22,BASE16_EXPECTED:23,CBOR:24,URI:32,BASE64URL:33,BASE64:34,REGEXP:35,MIME:36,SET:258},t.NUMBYTES={ZERO:0,ONE:24,TWO:25,FOUR:26,EIGHT:27,INDEFINITE:31},t.SIMPLE={FALSE:20,TRUE:21,NULL:22,UNDEFINED:23},t.SYMS={NULL:Symbol.for("github.com/hildjj/node-cbor/null"),UNDEFINED:Symbol.for("github.com/hildjj/node-cbor/undef"),PARENT:Symbol.for("github.com/hildjj/node-cbor/parent"),BREAK:Symbol.for("github.com/hildjj/node-cbor/break"),STREAM:Symbol.for("github.com/hildjj/node-cbor/stream")},t.SHIFT32=4294967296,t.BI={MINUS_ONE:BigInt(-1),NEG_MAX:BigInt(-1)-BigInt(Number.MAX_SAFE_INTEGER),MAXINT32:BigInt("0xffffffff"),MAXINT64:BigInt("0xffffffffffffffff"),SHIFT32:BigInt(t.SHIFT32)};},774:(e,t,r)=>{const n=r(71),i=r(785),o=r(32),s=r(873),a=r(202),u=(r(830),r(66)),{MT:f,NUMBYTES:h,SYMS:l,BI:c}=u,{Buffer:d}=r(764),p=Symbol("count"),g=Symbol("major type"),y=Symbol("error"),b=Symbol("not found");function w(e,t,r){const n=[];return n[p]=r,n[l.PARENT]=e,n[g]=t,n}function _(e,t){const r=new a;return r[p]=-1,r[l.PARENT]=e,r[g]=t,r}class m extends Error{constructor(e,t){super(`Unexpected data: 0x${e.toString(16)}`),this.name="UnexpectedDataError",this.byte=e,this.value=t;}}function E(e,t){switch(typeof e){case"function":return {options:{},cb:e};case"string":return {options:{encoding:e},cb:t};case"object":return {options:e||{},cb:t};default:throw new TypeError("Unknown option type")}}class v extends n{constructor(e={}){const{tags:t={},max_depth:r=-1,preferWeb:n=!1,required:i=!1,encoding:o="hex",extendedResults:s=!1,preventDuplicateKeys:u=!1,...f}=e;super({defaultEncoding:o,...f}),this.running=!0,this.max_depth=r,this.tags=t,this.preferWeb=n,this.extendedResults=s,this.required=i,this.preventDuplicateKeys=u,s&&(this.bs.on("read",this._onRead.bind(this)),this.valueBytes=new a);}static nullcheck(e){switch(e){case l.NULL:return null;case l.UNDEFINED:return;case b:throw new Error("Value not found");default:return e}}static decodeFirstSync(e,t={}){if(null==e)throw new TypeError("input required");({options:t}=E(t));const{encoding:r="hex",...n}=t,i=new v(n),o=s.guessEncoding(e,r),a=i._parse();let u=a.next();for(;!u.done;){const e=o.read(u.value);if(null==e||e.length!==u.value)throw new Error("Insufficient data");i.extendedResults&&i.valueBytes.write(e),u=a.next(e);}let f=null;if(i.extendedResults)f=u.value,f.unused=o.read();else if(f=v.nullcheck(u.value),o.length>0){const e=o.read(1);throw o.unshift(e),new m(e[0],f)}return f}static decodeAllSync(e,t={}){if(null==e)throw new TypeError("input required");({options:t}=E(t));const{encoding:r="hex",...n}=t,i=new v(n),o=s.guessEncoding(e,r),a=[];for(;o.length>0;){const e=i._parse();let t=e.next();for(;!t.done;){const r=o.read(t.value);if(null==r||r.length!==t.value)throw new Error("Insufficient data");i.extendedResults&&i.valueBytes.write(r),t=e.next(r);}a.push(v.nullcheck(t.value));}return a}static decodeFirst(e,t={},r=null){if(null==e)throw new TypeError("input required");({options:t,cb:r}=E(t,r));const{encoding:n="hex",required:i=!1,...o}=t,a=new v(o);let u=b;const f=s.guessEncoding(e,n),h=new Promise(((e,t)=>{a.on("data",(e=>{u=v.nullcheck(e),a.close();})),a.once("error",(r=>a.extendedResults&&r instanceof m?(u.unused=a.bs.slice(),e(u)):(u!==b&&(r.value=u),u=y,a.close(),t(r)))),a.once("end",(()=>{switch(u){case b:return i?t(new Error("No CBOR found")):e(u);case y:return;default:return e(u)}}));}));return "function"==typeof r&&h.then((e=>r(null,e)),r),f.pipe(a),h}static decodeAll(e,t={},r=null){if(null==e)throw new TypeError("input required");({options:t,cb:r}=E(t,r));const{encoding:n="hex",...i}=t,o=new v(i),a=[];o.on("data",(e=>a.push(v.nullcheck(e))));const u=new Promise(((e,t)=>{o.on("error",t),o.on("end",(()=>e(a)));}));return "function"==typeof r&&u.then((e=>r(void 0,e)),(e=>r(e,void 0))),s.guessEncoding(e,n).pipe(o),u}close(){this.running=!1,this.__fresh=!0;}_onRead(e){this.valueBytes.write(e);}*_parse(){let e=null,t=0,r=null;for(;;){if(this.max_depth>=0&&t>this.max_depth)throw new Error(`Maximum depth ${this.max_depth} exceeded`);const[n]=yield 1;if(!this.running)throw this.bs.unshift(d.from([n])),new m(n);const u=n>>5,y=31&n,b=null==e?void 0:e[g],E=null==e?void 0:e.length;switch(y){case h.ONE:this.emit("more-bytes",u,1,b,E),[r]=yield 1;break;case h.TWO:case h.FOUR:case h.EIGHT:{const e=1<<y-24;this.emit("more-bytes",u,e,b,E);const t=yield e;r=u===f.SIMPLE_FLOAT?t:s.parseCBORint(y,t);break}case 28:case 29:case 30:throw this.running=!1,new Error(`Additional info not implemented: ${y}`);case h.INDEFINITE:switch(u){case f.POS_INT:case f.NEG_INT:case f.TAG:throw new Error(`Invalid indefinite encoding for MT ${u}`)}r=-1;break;default:r=y;}switch(u){case f.POS_INT:break;case f.NEG_INT:r=r===Number.MAX_SAFE_INTEGER?c.NEG_MAX:"bigint"==typeof r?c.MINUS_ONE-r:-1-r;break;case f.BYTE_STRING:case f.UTF8_STRING:switch(r){case 0:this.emit("start-string",u,r,b,E),r=u===f.UTF8_STRING?"":this.preferWeb?new Uint8Array(0):d.allocUnsafe(0);break;case-1:this.emit("start",u,l.STREAM,b,E),e=_(e,u),t++;continue;default:this.emit("start-string",u,r,b,E),r=yield r,u===f.UTF8_STRING?r=s.utf8(r):this.preferWeb&&(r=new Uint8Array(r.buffer,r.byteOffset,r.length));}break;case f.ARRAY:case f.MAP:switch(r){case 0:r=u===f.MAP?{}:[];break;case-1:this.emit("start",u,l.STREAM,b,E),e=w(e,u,-1),t++;continue;default:this.emit("start",u,r,b,E),e=w(e,u,r*(u-3)),t++;continue}break;case f.TAG:this.emit("start",u,r,b,E),e=w(e,u,1),e.push(r),t++;continue;case f.SIMPLE_FLOAT:if("number"==typeof r){if(y===h.ONE&&r<32)throw new Error(`Invalid two-byte encoding of simple value ${r}`);const t=null!=e;r=o.decode(r,t,t&&e[p]<0);}else r=s.parseCBORfloat(r);}this.emit("value",r,b,E,y);let S=!1;for(;null!=e;){if(r===l.BREAK)e[p]=1;else if(Array.isArray(e))e.push(r);else {const t=e[g];if(null!=t&&t!==u)throw this.running=!1,new Error("Invalid major type in indefinite encoding");e.write(r);}if(0!=--e[p]){S=!0;break}if(--t,delete e[p],Array.isArray(e))switch(e[g]){case f.ARRAY:r=e;break;case f.MAP:{let t=!0;if(e.length%2!=0)throw new Error(`Invalid map length: ${e.length}`);for(let r=0,n=e.length;r<n;r+=2)if("string"!=typeof e[r]||"__proto__"===e[r]){t=!1;break}if(t){r={};for(let t=0,n=e.length;t<n;t+=2){if(this.preventDuplicateKeys&&Object.prototype.hasOwnProperty.call(r,e[t]))throw new Error("Duplicate keys in a map");r[e[t]]=e[t+1];}}else {r=new Map;for(let t=0,n=e.length;t<n;t+=2){if(this.preventDuplicateKeys&&r.has(e[t]))throw new Error("Duplicate keys in a map");r.set(e[t],e[t+1]);}}break}case f.TAG:r=new i(e[0],e[1]).convert(this.tags);}else if(e instanceof a)switch(e[g]){case f.BYTE_STRING:r=e.slice(),this.preferWeb&&(r=new Uint8Array(r.buffer,r.byteOffset,r.length));break;case f.UTF8_STRING:r=e.toString("utf-8");}this.emit("stop",e[g]);const n=e;e=e[l.PARENT],delete n[l.PARENT],delete n[g];}if(!S){if(this.extendedResults){const e=this.valueBytes.slice(),t={value:v.nullcheck(r),bytes:e,length:e.length};return this.valueBytes=new a,t}return r}}}}v.NOT_FOUND=b,e.exports=v;},694:(e,t,r)=>{const n=r(830),i=r(774),o=r(873),s=r(202),{MT:a,SYMS:u}=r(66);class f extends n.Transform{constructor(e={}){const{separator:t="\n",stream_errors:r=!1,tags:n,max_depth:o,preferWeb:s,encoding:a,...u}=e;super({...u,readableObjectMode:!1,writableObjectMode:!1}),this.float_bytes=-1,this.separator=t,this.stream_errors=r,this.parser=new i({tags:n,max_depth:o,preferWeb:s,encoding:a}),this.parser.on("more-bytes",this._on_more.bind(this)),this.parser.on("value",this._on_value.bind(this)),this.parser.on("start",this._on_start.bind(this)),this.parser.on("stop",this._on_stop.bind(this)),this.parser.on("data",this._on_data.bind(this)),this.parser.on("error",this._on_error.bind(this));}_transform(e,t,r){return this.parser.write(e,t,r)}_flush(e){return this.parser._flush((t=>this.stream_errors?(t&&this._on_error(t),e()):e(t)))}static diagnose(e,t={},r=null){if(null==e)throw new TypeError("input required");({options:t,cb:r}=function(e,t){switch(typeof e){case"function":return {options:{},cb:e};case"string":return {options:{encoding:e},cb:t};case"object":return {options:e||{},cb:t};default:throw new TypeError("Unknown option type")}}(t,r));const{encoding:n="hex",...i}=t,a=new s,u=new f(i);let h=null;return "function"==typeof r?(u.on("end",(()=>r(null,a.toString("utf8")))),u.on("error",r)):h=new Promise(((e,t)=>{u.on("end",(()=>e(a.toString("utf8")))),u.on("error",t);})),u.pipe(a),o.guessEncoding(e,n).pipe(u),h}_on_error(e){this.stream_errors?this.push(e.toString()):this.emit("error",e);}_on_more(e,t,r,n){e===a.SIMPLE_FLOAT&&(this.float_bytes={2:1,4:2,8:3}[t]);}_fore(e,t){switch(e){case a.BYTE_STRING:case a.UTF8_STRING:case a.ARRAY:t>0&&this.push(", ");break;case a.MAP:t>0&&(t%2?this.push(": "):this.push(", "));}}_on_value(e,t,r){if(e===u.BREAK)return;this._fore(t,r);const n=this.float_bytes;this.float_bytes=-1,this.push(o.cborValueToString(e,n));}_on_start(e,t,r,n){switch(this._fore(r,n),e){case a.TAG:this.push(`${t}(`);break;case a.ARRAY:this.push("[");break;case a.MAP:this.push("{");break;case a.BYTE_STRING:case a.UTF8_STRING:this.push("(");}t===u.STREAM&&this.push("_ ");}_on_stop(e){switch(e){case a.TAG:this.push(")");break;case a.ARRAY:this.push("]");break;case a.MAP:this.push("}");break;case a.BYTE_STRING:case a.UTF8_STRING:this.push(")");}}_on_data(){this.push(this.separator);}}e.exports=f;},666:(e,t,r)=>{const n=r(830),i=r(202),o=r(873),s=r(66),{MT:a,NUMBYTES:u,SHIFT32:f,SIMPLE:h,SYMS:l,TAG:c,BI:d}=s,{Buffer:p}=r(764),g=a.SIMPLE_FLOAT<<5|u.TWO,y=a.SIMPLE_FLOAT<<5|u.FOUR,b=a.SIMPLE_FLOAT<<5|u.EIGHT,w=a.SIMPLE_FLOAT<<5|h.TRUE,_=a.SIMPLE_FLOAT<<5|h.FALSE,m=a.SIMPLE_FLOAT<<5|h.UNDEFINED,E=a.SIMPLE_FLOAT<<5|h.NULL,v=p.from([255]),S=p.from("f97e00","hex"),T=p.from("f9fc00","hex"),I=p.from("f97c00","hex"),A=p.from("f98000","hex"),B={};let R={};class U extends n.Transform{constructor(e={}){const{canonical:t=!1,encodeUndefined:r,disallowUndefinedKeys:n=!1,dateType:i="number",collapseBigIntegers:o=!1,detectLoops:s=!1,omitUndefinedProperties:a=!1,genTypes:u=[],...f}=e;if(super({...f,readableObjectMode:!1,writableObjectMode:!0}),this.canonical=t,this.encodeUndefined=r,this.disallowUndefinedKeys=n,this.dateType=function(e){if(!e)return "number";switch(e.toLowerCase()){case"number":return "number";case"float":return "float";case"int":case"integer":return "int";case"string":return "string"}throw new TypeError(`dateType invalid, got "${e}"`)}(i),this.collapseBigIntegers=!!this.canonical||o,this.detectLoops=void 0,"boolean"==typeof s)s&&(this.detectLoops=new WeakSet);else {if(!(s instanceof WeakSet))throw new TypeError("detectLoops must be boolean or WeakSet");this.detectLoops=s;}if(this.omitUndefinedProperties=a,this.semanticTypes={...U.SEMANTIC_TYPES},Array.isArray(u))for(let e=0,t=u.length;e<t;e+=2)this.addSemanticType(u[e],u[e+1]);else for(const[e,t]of Object.entries(u))this.addSemanticType(e,t);}_transform(e,t,r){return r(!1===this.pushAny(e)?new Error("Push Error"):void 0)}_flush(e){return e()}_pushUInt8(e){const t=p.allocUnsafe(1);return t.writeUInt8(e,0),this.push(t)}_pushUInt16BE(e){const t=p.allocUnsafe(2);return t.writeUInt16BE(e,0),this.push(t)}_pushUInt32BE(e){const t=p.allocUnsafe(4);return t.writeUInt32BE(e,0),this.push(t)}_pushFloatBE(e){const t=p.allocUnsafe(4);return t.writeFloatBE(e,0),this.push(t)}_pushDoubleBE(e){const t=p.allocUnsafe(8);return t.writeDoubleBE(e,0),this.push(t)}_pushNaN(){return this.push(S)}_pushInfinity(e){const t=e<0?T:I;return this.push(t)}_pushFloat(e){if(this.canonical){const t=p.allocUnsafe(2);if(o.writeHalf(t,e))return this._pushUInt8(g)&&this.push(t)}return Math.fround(e)===e?this._pushUInt8(y)&&this._pushFloatBE(e):this._pushUInt8(b)&&this._pushDoubleBE(e)}_pushInt(e,t,r){const n=t<<5;if(e<24)return this._pushUInt8(n|e);if(e<=255)return this._pushUInt8(n|u.ONE)&&this._pushUInt8(e);if(e<=65535)return this._pushUInt8(n|u.TWO)&&this._pushUInt16BE(e);if(e<=4294967295)return this._pushUInt8(n|u.FOUR)&&this._pushUInt32BE(e);let i=Number.MAX_SAFE_INTEGER;return t===a.NEG_INT&&i--,e<=i?this._pushUInt8(n|u.EIGHT)&&this._pushUInt32BE(Math.floor(e/f))&&this._pushUInt32BE(e%f):t===a.NEG_INT?this._pushFloat(r):this._pushFloat(e)}_pushIntNum(e){return Object.is(e,-0)?this.push(A):e<0?this._pushInt(-e-1,a.NEG_INT,e):this._pushInt(e,a.POS_INT)}_pushNumber(e){return isNaN(e)?this._pushNaN():isFinite(e)?Math.round(e)===e?this._pushIntNum(e):this._pushFloat(e):this._pushInfinity(e)}_pushString(e){const t=p.byteLength(e,"utf8");return this._pushInt(t,a.UTF8_STRING)&&this.push(e,"utf8")}_pushBoolean(e){return this._pushUInt8(e?w:_)}_pushUndefined(e){switch(typeof this.encodeUndefined){case"undefined":return this._pushUInt8(m);case"function":return this.pushAny(this.encodeUndefined(e));case"object":{const e=o.bufferishToBuffer(this.encodeUndefined);if(e)return this.push(e)}}return this.pushAny(this.encodeUndefined)}_pushNull(e){return this._pushUInt8(E)}_pushTag(e){return this._pushInt(e,a.TAG)}_pushJSBigint(e){let t=a.POS_INT,r=c.POS_BIGINT;if(e<0&&(e=-e+d.MINUS_ONE,t=a.NEG_INT,r=c.NEG_BIGINT),this.collapseBigIntegers&&e<=d.MAXINT64)return e<=4294967295?this._pushInt(Number(e),t):this._pushUInt8(t<<5|u.EIGHT)&&this._pushUInt32BE(Number(e/d.SHIFT32))&&this._pushUInt32BE(Number(e%d.SHIFT32));let n=e.toString(16);n.length%2&&(n=`0${n}`);const i=p.from(n,"hex");return this._pushTag(r)&&U._pushBuffer(this,i)}_pushObject(e,t){if(!e)return this._pushNull(e);if(!(t={indefinite:!1,skipTypes:!1,...t}).indefinite&&this.detectLoops){if(this.detectLoops.has(e))throw new Error("Loop detected while CBOR encoding.\nCall removeLoopDetectors before resuming.");this.detectLoops.add(e);}if(!t.skipTypes){const t=e.encodeCBOR;if("function"==typeof t)return t.call(e,this);const r=this.semanticTypes[e.constructor.name];if(r)return r.call(e,this,e)}const r=Object.keys(e).filter((t=>{const r=typeof e[t];return "function"!==r&&(!this.omitUndefinedProperties||"undefined"!==r)})),n={};if(this.canonical&&r.sort(((e,t)=>{const r=n[e]||(n[e]=U.encode(e)),i=n[t]||(n[t]=U.encode(t));return r.compare(i)})),t.indefinite){if(!this._pushUInt8(a.MAP<<5|u.INDEFINITE))return !1}else if(!this._pushInt(r.length,a.MAP))return !1;let i=null;for(let t=0,o=r.length;t<o;t++){const o=r[t];if(this.canonical&&(i=n[o])){if(!this.push(i))return !1}else if(!this._pushString(o))return !1;if(!this.pushAny(e[o]))return !1}if(t.indefinite){if(!this.push(v))return !1}else this.detectLoops&&this.detectLoops.delete(e);return !0}_encodeAll(e){const t=new i({highWaterMark:this.readableHighWaterMark});this.pipe(t);for(const t of e)this.pushAny(t);return this.end(),t.read()}addSemanticType(e,t){const r="string"==typeof e?e:e.name,n=this.semanticTypes[r];if(t){if("function"!=typeof t)throw new TypeError("fun must be of type function");this.semanticTypes[r]=t;}else n&&delete this.semanticTypes[r];return n}pushAny(e){switch(typeof e){case"number":return this._pushNumber(e);case"bigint":return this._pushJSBigint(e);case"string":return this._pushString(e);case"boolean":return this._pushBoolean(e);case"undefined":return this._pushUndefined(e);case"object":return this._pushObject(e);case"symbol":switch(e){case l.NULL:return this._pushNull(null);case l.UNDEFINED:return this._pushUndefined(void 0);default:throw new TypeError(`Unknown symbol: ${e.toString()}`)}default:throw new TypeError(`Unknown type: ${typeof e}, ${"function"==typeof e.toString?e.toString():""}`)}}static pushArray(e,t,r){r={indefinite:!1,...r};const n=t.length;if(r.indefinite){if(!e._pushUInt8(a.ARRAY<<5|u.INDEFINITE))return !1}else if(!e._pushInt(n,a.ARRAY))return !1;for(let r=0;r<n;r++)if(!e.pushAny(t[r]))return !1;return !(r.indefinite&&!e.push(v))}removeLoopDetectors(){return !!this.detectLoops&&(this.detectLoops=new WeakSet,!0)}static _pushDate(e,t){switch(e.dateType){case"string":return e._pushTag(c.DATE_STRING)&&e._pushString(t.toISOString());case"int":return e._pushTag(c.DATE_EPOCH)&&e._pushIntNum(Math.round(t.getTime()/1e3));case"float":return e._pushTag(c.DATE_EPOCH)&&e._pushFloat(t.getTime()/1e3);default:return e._pushTag(c.DATE_EPOCH)&&e.pushAny(t.getTime()/1e3)}}static _pushBuffer(e,t){return e._pushInt(t.length,a.BYTE_STRING)&&e.push(t)}static _pushNoFilter(e,t){return U._pushBuffer(e,t.slice())}static _pushRegexp(e,t){return e._pushTag(c.REGEXP)&&e.pushAny(t.source)}static _pushSet(e,t){if(!e._pushTag(c.SET))return !1;if(!e._pushInt(t.size,a.ARRAY))return !1;for(const r of t)if(!e.pushAny(r))return !1;return !0}static _pushURL(e,t){return e._pushTag(c.URI)&&e.pushAny(t.toString())}static _pushBoxed(e,t){return e.pushAny(t.valueOf())}static _pushMap(e,t,r){r={indefinite:!1,...r};let n=[...t.entries()];if(e.omitUndefinedProperties&&(n=n.filter((([e,t])=>void 0!==t))),r.indefinite){if(!e._pushUInt8(a.MAP<<5|u.INDEFINITE))return !1}else if(!e._pushInt(n.length,a.MAP))return !1;if(e.canonical){const t=new U({genTypes:e.semanticTypes,canonical:e.canonical,detectLoops:Boolean(e.detectLoops),dateType:e.dateType,disallowUndefinedKeys:e.disallowUndefinedKeys,collapseBigIntegers:e.collapseBigIntegers}),r=new i({highWaterMark:e.readableHighWaterMark});t.pipe(r),n.sort((([e],[n])=>{t.pushAny(e);const i=r.read();t.pushAny(n);const o=r.read();return i.compare(o)}));for(const[t,r]of n){if(e.disallowUndefinedKeys&&void 0===t)throw new Error("Invalid Map key: undefined");if(!e.pushAny(t)||!e.pushAny(r))return !1}}else for(const[t,r]of n){if(e.disallowUndefinedKeys&&void 0===t)throw new Error("Invalid Map key: undefined");if(!e.pushAny(t)||!e.pushAny(r))return !1}return !(r.indefinite&&!e.push(v))}static _pushTypedArray(e,t){let r=64,n=t.BYTES_PER_ELEMENT;const{name:i}=t.constructor;return i.startsWith("Float")?(r|=16,n/=2):i.includes("U")||(r|=8),(i.includes("Clamped")||1!==n&&!o.isBigEndian())&&(r|=4),r|={1:0,2:1,4:2,8:3}[n],!!e._pushTag(r)&&U._pushBuffer(e,p.from(t.buffer,t.byteOffset,t.byteLength))}static _pushArrayBuffer(e,t){return U._pushBuffer(e,p.from(t))}static encodeIndefinite(e,t,r={}){if(null==t){if(null==this)throw new Error("No object to encode");t=this;}const{chunkSize:n=4096}=r;let i=!0;const s=typeof t;let f=null;if("string"===s){i=i&&e._pushUInt8(a.UTF8_STRING<<5|u.INDEFINITE);let r=0;for(;r<t.length;){const o=r+n;i=i&&e._pushString(t.slice(r,o)),r=o;}i=i&&e.push(v);}else if(f=o.bufferishToBuffer(t)){i=i&&e._pushUInt8(a.BYTE_STRING<<5|u.INDEFINITE);let t=0;for(;t<f.length;){const r=t+n;i=i&&U._pushBuffer(e,f.slice(t,r)),t=r;}i=i&&e.push(v);}else if(Array.isArray(t))i=i&&U.pushArray(e,t,{indefinite:!0});else if(t instanceof Map)i=i&&U._pushMap(e,t,{indefinite:!0});else {if("object"!==s)throw new Error("Invalid indefinite encoding");i=i&&e._pushObject(t,{indefinite:!0,skipTypes:!0});}return i}static encode(...e){return (new U)._encodeAll(e)}static encodeCanonical(...e){return new U({canonical:!0})._encodeAll(e)}static encodeOne(e,t){return new U(t)._encodeAll([e])}static encodeAsync(e,t){return new Promise(((r,n)=>{const i=[],o=new U(t);o.on("data",(e=>i.push(e))),o.on("error",n),o.on("finish",(()=>r(p.concat(i)))),o.pushAny(e),o.end();}))}static get SEMANTIC_TYPES(){return R}static set SEMANTIC_TYPES(e){R=e;}static reset(){U.SEMANTIC_TYPES={...B};}}Object.assign(B,{Array:U.pushArray,Date:U._pushDate,Buffer:U._pushBuffer,[p.name]:U._pushBuffer,Map:U._pushMap,NoFilter:U._pushNoFilter,[i.name]:U._pushNoFilter,RegExp:U._pushRegexp,Set:U._pushSet,ArrayBuffer:U._pushArrayBuffer,Uint8ClampedArray:U._pushTypedArray,Uint8Array:U._pushTypedArray,Uint16Array:U._pushTypedArray,Uint32Array:U._pushTypedArray,Int8Array:U._pushTypedArray,Int16Array:U._pushTypedArray,Int32Array:U._pushTypedArray,Float32Array:U._pushTypedArray,Float64Array:U._pushTypedArray,URL:U._pushURL,Boolean:U._pushBoxed,Number:U._pushBoxed,String:U._pushBoxed}),"undefined"!=typeof BigUint64Array&&(B[BigUint64Array.name]=U._pushTypedArray),"undefined"!=typeof BigInt64Array&&(B[BigInt64Array.name]=U._pushTypedArray),U.reset(),e.exports=U;},70:(e,t,r)=>{const{Buffer:n}=r(764),i=r(666),o=r(774),{MT:s}=r(66);class a extends Map{constructor(e){super(e);}static _encode(e){return i.encodeCanonical(e).toString("base64")}static _decode(e){return o.decodeFirstSync(e,"base64")}get(e){return super.get(a._encode(e))}set(e,t){return super.set(a._encode(e),t)}delete(e){return super.delete(a._encode(e))}has(e){return super.has(a._encode(e))}*keys(){for(const e of super.keys())yield a._decode(e);}*entries(){for(const e of super.entries())yield [a._decode(e[0]),e[1]];}[Symbol.iterator](){return this.entries()}forEach(e,t){if("function"!=typeof e)throw new TypeError("Must be function");for(const t of super.entries())e.call(this,t[1],a._decode(t[0]),this);}encodeCBOR(e){if(!e._pushInt(this.size,s.MAP))return !1;if(e.canonical){const t=Array.from(super.entries()).map((e=>[n.from(e[0],"base64"),e[1]]));t.sort(((e,t)=>e[0].compare(t[0])));for(const r of t)if(!e.push(r[0])||!e.pushAny(r[1]))return !1}else for(const t of super.entries())if(!e.push(n.from(t[0],"base64"))||!e.pushAny(t[1]))return !1;return !0}}e.exports=a;},32:(e,t,r)=>{const{MT:n,SIMPLE:i,SYMS:o}=r(66);class s{constructor(e){if("number"!=typeof e)throw new Error("Invalid Simple type: "+typeof e);if(e<0||e>255||(0|e)!==e)throw new Error(`value must be a small positive integer: ${e}`);this.value=e;}toString(){return `simple(${this.value})`}[Symbol.for("nodejs.util.inspect.custom")](e,t){return `simple(${this.value})`}encodeCBOR(e){return e._pushInt(this.value,n.SIMPLE_FLOAT)}static isSimple(e){return e instanceof s}static decode(e,t=!0,r=!1){switch(e){case i.FALSE:return !1;case i.TRUE:return !0;case i.NULL:return t?null:o.NULL;case i.UNDEFINED:if(t)return;return o.UNDEFINED;case-1:if(!t||!r)throw new Error("Invalid BREAK");return o.BREAK;default:return new s(e)}}}e.exports=s;},785:(e,t,r)=>{const n=r(66),i=r(873),o=Symbol("INTERNAL_JSON");function s(e,t){if(i.isBufferish(e))e.toJSON=t;else if(Array.isArray(e))for(const r of e)s(r,t);else if(e&&"object"==typeof e&&(!(e instanceof p)||e.tag<21||e.tag>23))for(const r of Object.values(e))s(r,t);}function a(){return i.base64(this)}function u(){return i.base64url(this)}function f(){return this.toString("hex")}const h={0:e=>new Date(e),1:e=>new Date(1e3*e),2:e=>i.bufferToBigInt(e),3:e=>n.BI.MINUS_ONE-i.bufferToBigInt(e),21:(e,t)=>(i.isBufferish(e)?t[o]=u:s(e,u),t),22:(e,t)=>(i.isBufferish(e)?t[o]=a:s(e,a),t),23:(e,t)=>(i.isBufferish(e)?t[o]=f:s(e,f),t),32:e=>new URL(e),33:(e,t)=>{if(!e.match(/^[a-zA-Z0-9_-]+$/))throw new Error("Invalid base64url characters");const r=e.length%4;if(1===r)throw new Error("Invalid base64url length");if(2===r){if(-1==="AQgw".indexOf(e[e.length-1]))throw new Error("Invalid base64 padding")}else if(3===r&&-1==="AEIMQUYcgkosw048".indexOf(e[e.length-1]))throw new Error("Invalid base64 padding");return t},34:(e,t)=>{const r=e.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/);if(!r)throw new Error("Invalid base64 characters");if(e.length%4!=0)throw new Error("Invalid base64 length");if("="===r.groups.padding){if(-1==="AQgw".indexOf(e[e.length-2]))throw new Error("Invalid base64 padding")}else if("=="===r.groups.padding&&-1==="AEIMQUYcgkosw048".indexOf(e[e.length-3]))throw new Error("Invalid base64 padding");return t},35:e=>new RegExp(e),258:e=>new Set(e)},l={64:Uint8Array,65:Uint16Array,66:Uint32Array,68:Uint8ClampedArray,69:Uint16Array,70:Uint32Array,72:Int8Array,73:Int16Array,74:Int32Array,77:Int16Array,78:Int32Array,81:Float32Array,82:Float64Array,85:Float32Array,86:Float64Array};function c(e,t){if(!i.isBufferish(e))throw new TypeError("val not a buffer");const{tag:r}=t,n=l[r];if(!n)throw new Error(`Invalid typed array tag: ${r}`);const o=2**(((16&r)>>4)+(3&r));return !(4&r)!==i.isBigEndian()&&o>1&&function(e,t,r,n){const i=new DataView(e),[o,s]={2:[i.getUint16,i.setUint16],4:[i.getUint32,i.setUint32],8:[i.getBigUint64,i.setBigUint64]}[t],a=r+n;for(let e=r;e<a;e+=t)s.call(i,e,o.call(i,e,!0));}(e.buffer,o,e.byteOffset,e.byteLength),new n(e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength))}"undefined"!=typeof BigUint64Array&&(l[67]=BigUint64Array,l[71]=BigUint64Array),"undefined"!=typeof BigInt64Array&&(l[75]=BigInt64Array,l[79]=BigInt64Array);for(const e of Object.keys(l))h[e]=c;let d={};class p{constructor(e,t,r){if(this.tag=e,this.value=t,this.err=r,"number"!=typeof this.tag)throw new Error(`Invalid tag type (${typeof this.tag})`);if(this.tag<0||(0|this.tag)!==this.tag)throw new Error(`Tag must be a positive integer: ${this.tag}`)}toJSON(){if(this[o])return this[o].call(this.value);const e={tag:this.tag,value:this.value};return this.err&&(e.err=this.err),e}toString(){return `${this.tag}(${JSON.stringify(this.value)})`}encodeCBOR(e){return e._pushTag(this.tag),e.pushAny(this.value)}convert(e){let t=null==e?void 0:e[this.tag];if("function"!=typeof t&&(t=p.TAGS[this.tag],"function"!=typeof t))return this;try{return t.call(this,this.value,this)}catch(e){return e&&e.message&&e.message.length>0?this.err=e.message:this.err=e,this}}static get TAGS(){return d}static set TAGS(e){d=e;}static reset(){p.TAGS={...h};}}p.INTERNAL_JSON=o,p.reset(),e.exports=p;},873:(e,t,r)=>{const{Buffer:n}=r(764),i=r(202),o=r(830),s=r(66),{NUMBYTES:a,SHIFT32:u,BI:f,SYMS:h}=s,l=new TextDecoder("utf8",{fatal:!0,ignoreBOM:!0});t.utf8=e=>l.decode(e),t.utf8.checksUTF8=!0,t.isBufferish=function(e){return e&&"object"==typeof e&&(n.isBuffer(e)||e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof ArrayBuffer||e instanceof DataView)},t.bufferishToBuffer=function(e){return n.isBuffer(e)?e:ArrayBuffer.isView(e)?n.from(e.buffer,e.byteOffset,e.byteLength):e instanceof ArrayBuffer?n.from(e):null},t.parseCBORint=function(e,t){switch(e){case a.ONE:return t.readUInt8(0);case a.TWO:return t.readUInt16BE(0);case a.FOUR:return t.readUInt32BE(0);case a.EIGHT:{const e=t.readUInt32BE(0),r=t.readUInt32BE(4);return e>2097151?BigInt(e)*f.SHIFT32+BigInt(r):e*u+r}default:throw new Error(`Invalid additional info for int: ${e}`)}},t.writeHalf=function(e,t){const r=n.allocUnsafe(4);r.writeFloatBE(t,0);const i=r.readUInt32BE(0);if(0!=(8191&i))return !1;let o=i>>16&32768;const s=i>>23&255,a=8388607&i;if(s>=113&&s<=142)o+=(s-112<<10)+(a>>13);else {if(!(s>=103&&s<113))return !1;if(a&(1<<126-s)-1)return !1;o+=a+8388608>>126-s;}return e.writeUInt16BE(o),!0},t.parseHalf=function(e){const t=128&e[0]?-1:1,r=(124&e[0])>>2,n=(3&e[0])<<8|e[1];return r?31===r?t*(n?NaN:1/0):t*2**(r-25)*(1024+n):5.960464477539063e-8*t*n},t.parseCBORfloat=function(e){switch(e.length){case 2:return t.parseHalf(e);case 4:return e.readFloatBE(0);case 8:return e.readDoubleBE(0);default:throw new Error(`Invalid float size: ${e.length}`)}},t.hex=function(e){return n.from(e.replace(/^0x/,""),"hex")},t.bin=function(e){let t=0,r=(e=e.replace(/\s/g,"")).length%8||8;const i=[];for(;r<=e.length;)i.push(parseInt(e.slice(t,r),2)),t=r,r+=8;return n.from(i)},t.arrayEqual=function(e,t){return null==e&&null==t||null!=e&&null!=t&&e.length===t.length&&e.every(((e,r)=>e===t[r]))},t.bufferToBigInt=function(e){return BigInt(`0x${e.toString("hex")}`)},t.cborValueToString=function(e,r=-1){switch(typeof e){case"symbol":{switch(e){case h.NULL:return "null";case h.UNDEFINED:return "undefined";case h.BREAK:return "BREAK"}if(e.description)return e.description;const t=e.toString().match(/^Symbol\((?<name>.*)\)/);return t&&t.groups.name?t.groups.name:"Symbol"}case"string":return JSON.stringify(e);case"bigint":return e.toString();case"number":{const t=Object.is(e,-0)?"-0":String(e);return r>0?`${t}_${r}`:t}case"object":{const n=t.bufferishToBuffer(e);if(n){const e=n.toString("hex");return r===-1/0?e:`h'${e}'`}return "function"==typeof e[Symbol.for("nodejs.util.inspect.custom")]?e[Symbol.for("nodejs.util.inspect.custom")]():Array.isArray(e)?"[]":"{}"}}return String(e)},t.guessEncoding=function(e,r){if("string"==typeof e)return new i(e,null==r?"hex":r);const n=t.bufferishToBuffer(e);if(n)return new i(n);if((s=e)instanceof o.Readable||["read","on","pipe"].every((e=>"function"==typeof s[e])))return e;var s;throw new Error("Unknown input type")};const c={"=":"","+":"-","/":"_"};t.base64url=function(e){return t.bufferishToBuffer(e).toString("base64").replace(/[=+/]/g,(e=>c[e]))},t.base64=function(e){return t.bufferishToBuffer(e).toString("base64")},t.isBigEndian=function(){const e=new Uint8Array(4);return !((new Uint32Array(e.buffer)[0]=1)&e[0])};},202:(e,t,r)=>{const n=r(830),{Buffer:i}=r(764),o=new TextDecoder("utf8",{fatal:!0,ignoreBOM:!0});class s extends n.Transform{constructor(e,t,r={}){let n=null,o=null;switch(typeof e){case"object":i.isBuffer(e)?n=e:e&&(r=e);break;case"string":n=e;break;case"undefined":break;default:throw new TypeError("Invalid input")}switch(typeof t){case"object":t&&(r=t);break;case"string":o=t;break;case"undefined":break;default:throw new TypeError("Invalid inputEncoding")}if(!r||"object"!=typeof r)throw new TypeError("Invalid options");null==n&&(n=r.input),null==o&&(o=r.inputEncoding),delete r.input,delete r.inputEncoding;const s=null==r.watchPipe||r.watchPipe;delete r.watchPipe;const a=Boolean(r.readError);delete r.readError,super(r),this.readError=a,s&&this.on("pipe",(e=>{const t=e._readableState.objectMode;if(this.length>0&&t!==this._readableState.objectMode)throw new Error("Do not switch objectMode in the middle of the stream");this._readableState.objectMode=t,this._writableState.objectMode=t;})),null!=n&&this.end(n,o);}static isNoFilter(e){return e instanceof this}static compare(e,t){if(!(e instanceof this))throw new TypeError("Arguments must be NoFilters");return e===t?0:e.compare(t)}static concat(e,t){if(!Array.isArray(e))throw new TypeError("list argument must be an Array of NoFilters");if(0===e.length||0===t)return i.alloc(0);null==t&&(t=e.reduce(((e,t)=>{if(!(t instanceof s))throw new TypeError("list argument must be an Array of NoFilters");return e+t.length}),0));let r=!0,n=!0;const o=e.map((e=>{if(!(e instanceof s))throw new TypeError("list argument must be an Array of NoFilters");const t=e.slice();return i.isBuffer(t)?n=!1:r=!1,t}));if(r)return i.concat(o,t);if(n)return [].concat(...o).slice(0,t);throw new Error("Concatenating mixed object and byte streams not supported")}_transform(e,t,r){this._readableState.objectMode||i.isBuffer(e)||(e=i.from(e,t)),this.push(e),r();}_bufArray(){let e=this._readableState.buffer;if(!Array.isArray(e)){let t=e.head;for(e=[];null!=t;)e.push(t.data),t=t.next;}return e}read(e){const t=super.read(e);if(null!=t){if(this.emit("read",t),this.readError&&t.length<e)throw new Error(`Read ${t.length}, wanted ${e}`)}else if(this.readError)throw new Error(`No data available, wanted ${e}`);return t}readFull(e){let t=null,r=null,n=null;return new Promise(((i,o)=>{this.length>=e?i(this.read(e)):this.writableFinished?o(new Error(`Stream finished before ${e} bytes were available`)):(t=t=>{this.length>=e&&i(this.read(e));},r=()=>{o(new Error(`Stream finished before ${e} bytes were available`));},n=o,this.on("readable",t),this.on("error",n),this.on("finish",r));})).finally((()=>{t&&(this.removeListener("readable",t),this.removeListener("error",n),this.removeListener("finish",r));}))}promise(e){let t=!1;return new Promise(((r,n)=>{this.on("finish",(()=>{const n=this.read();null==e||t||(t=!0,e(null,n)),r(n);})),this.on("error",(r=>{null==e||t||(t=!0,e(r)),n(r);}));}))}compare(e){if(!(e instanceof s))throw new TypeError("Arguments must be NoFilters");if(this===e)return 0;const t=this.slice(),r=e.slice();if(i.isBuffer(t)&&i.isBuffer(r))return t.compare(r);throw new Error("Cannot compare streams in object mode")}equals(e){return 0===this.compare(e)}slice(e,t){if(this._readableState.objectMode)return this._bufArray().slice(e,t);const r=this._bufArray();switch(r.length){case 0:return i.alloc(0);case 1:return r[0].slice(e,t);default:return i.concat(r).slice(e,t)}}get(e){return this.slice()[e]}toJSON(){const e=this.slice();return i.isBuffer(e)?e.toJSON():e}toString(e,t,r){const n=this.slice(t,r);return i.isBuffer(n)?e&&"utf8"!==e?n.toString(e):o.decode(n):JSON.stringify(n)}[Symbol.for("nodejs.util.inspect.custom")](e,t){const r=this._bufArray().map((e=>i.isBuffer(e)?t.stylize(e.toString("hex"),"string"):JSON.stringify(e))).join(", ");return `${this.constructor.name} [${r}]`}get length(){return this._readableState.length}writeBigInt(e){let t=e.toString(16);if(e<0){const r=BigInt(Math.floor(t.length/2));t=(e=(BigInt(1)<<r*BigInt(8))+e).toString(16);}return t.length%2&&(t=`0${t}`),this.push(i.from(t,"hex"))}readUBigInt(e){const t=this.read(e);return i.isBuffer(t)?BigInt(`0x${t.toString("hex")}`):null}readBigInt(e){const t=this.read(e);if(!i.isBuffer(t))return null;let r=BigInt(`0x${t.toString("hex")}`);return 128&t[0]&&(r-=BigInt(1)<<BigInt(t.length)*BigInt(8)),r}writeUInt8(e){const t=i.from([e]);return this.push(t)}writeUInt16LE(e){const t=i.alloc(2);return t.writeUInt16LE(e),this.push(t)}writeUInt16BE(e){const t=i.alloc(2);return t.writeUInt16BE(e),this.push(t)}writeUInt32LE(e){const t=i.alloc(4);return t.writeUInt32LE(e),this.push(t)}writeUInt32BE(e){const t=i.alloc(4);return t.writeUInt32BE(e),this.push(t)}writeInt8(e){const t=i.from([e]);return this.push(t)}writeInt16LE(e){const t=i.alloc(2);return t.writeUInt16LE(e),this.push(t)}writeInt16BE(e){const t=i.alloc(2);return t.writeUInt16BE(e),this.push(t)}writeInt32LE(e){const t=i.alloc(4);return t.writeUInt32LE(e),this.push(t)}writeInt32BE(e){const t=i.alloc(4);return t.writeUInt32BE(e),this.push(t)}writeFloatLE(e){const t=i.alloc(4);return t.writeFloatLE(e),this.push(t)}writeFloatBE(e){const t=i.alloc(4);return t.writeFloatBE(e),this.push(t)}writeDoubleLE(e){const t=i.alloc(8);return t.writeDoubleLE(e),this.push(t)}writeDoubleBE(e){const t=i.alloc(8);return t.writeDoubleBE(e),this.push(t)}writeBigInt64LE(e){const t=i.alloc(8);return t.writeBigInt64LE(e),this.push(t)}writeBigInt64BE(e){const t=i.alloc(8);return t.writeBigInt64BE(e),this.push(t)}writeBigUInt64LE(e){const t=i.alloc(8);return t.writeBigUInt64LE(e),this.push(t)}writeBigUInt64BE(e){const t=i.alloc(8);return t.writeBigUInt64BE(e),this.push(t)}readUInt8(){const e=this.read(1);return i.isBuffer(e)?e.readUInt8():null}readUInt16LE(){const e=this.read(2);return i.isBuffer(e)?e.readUInt16LE():null}readUInt16BE(){const e=this.read(2);return i.isBuffer(e)?e.readUInt16BE():null}readUInt32LE(){const e=this.read(4);return i.isBuffer(e)?e.readUInt32LE():null}readUInt32BE(){const e=this.read(4);return i.isBuffer(e)?e.readUInt32BE():null}readInt8(){const e=this.read(1);return i.isBuffer(e)?e.readInt8():null}readInt16LE(){const e=this.read(2);return i.isBuffer(e)?e.readInt16LE():null}readInt16BE(){const e=this.read(2);return i.isBuffer(e)?e.readInt16BE():null}readInt32LE(){const e=this.read(4);return i.isBuffer(e)?e.readInt32LE():null}readInt32BE(){const e=this.read(4);return i.isBuffer(e)?e.readInt32BE():null}readFloatLE(){const e=this.read(4);return i.isBuffer(e)?e.readFloatLE():null}readFloatBE(){const e=this.read(4);return i.isBuffer(e)?e.readFloatBE():null}readDoubleLE(){const e=this.read(8);return i.isBuffer(e)?e.readDoubleLE():null}readDoubleBE(){const e=this.read(8);return i.isBuffer(e)?e.readDoubleBE():null}readBigInt64LE(){const e=this.read(8);return i.isBuffer(e)?e.readBigInt64LE():null}readBigInt64BE(){const e=this.read(8);return i.isBuffer(e)?e.readBigInt64BE():null}readBigUInt64LE(){const e=this.read(8);return i.isBuffer(e)?e.readBigUInt64LE():null}readBigUInt64BE(){const e=this.read(8);return i.isBuffer(e)?e.readBigUInt64BE():null}}e.exports=s;},71:(e,t,r)=>{const n=r(830),i=r(202);class o extends n.Transform{constructor(e){super(e),this._writableState.objectMode=!1,this._readableState.objectMode=!0,this.bs=new i,this.__restart();}_transform(e,t,r){for(this.bs.write(e);this.bs.length>=this.__needed;){let e=null;const t=null===this.__needed?void 0:this.bs.read(this.__needed);try{e=this.__parser.next(t);}catch(e){return r(e)}this.__needed&&(this.__fresh=!1),e.done?(this.push(e.value),this.__restart()):this.__needed=e.value||1/0;}return r()}*_parse(){throw new Error("Must be implemented in subclass")}__restart(){this.__needed=null,this.__parser=this._parse(),this.__fresh=!0;}_flush(e){e(this.__fresh?null:new Error("unexpected end of input"));}}e.exports=o;},187:e=>{var t,r="object"==typeof Reflect?Reflect:null,n=r&&"function"==typeof r.apply?r.apply:function(e,t,r){return Function.prototype.apply.call(e,t,r)};t=r&&"function"==typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var i=Number.isNaN||function(e){return e!=e};function o(){o.init.call(this);}e.exports=o,e.exports.once=function(e,t){return new Promise((function(r,n){function i(r){e.removeListener(t,o),n(r);}function o(){"function"==typeof e.removeListener&&e.removeListener("error",i),r([].slice.call(arguments));}g(e,t,o,{once:!0}),"error"!==t&&function(e,t,r){"function"==typeof e.on&&g(e,"error",t,{once:!0});}(e,i);}))},o.EventEmitter=o,o.prototype._events=void 0,o.prototype._eventsCount=0,o.prototype._maxListeners=void 0;var s=10;function a(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function u(e){return void 0===e._maxListeners?o.defaultMaxListeners:e._maxListeners}function f(e,t,r,n){var i,o,s,f;if(a(r),void 0===(o=e._events)?(o=e._events=Object.create(null),e._eventsCount=0):(void 0!==o.newListener&&(e.emit("newListener",t,r.listener?r.listener:r),o=e._events),s=o[t]),void 0===s)s=o[t]=r,++e._eventsCount;else if("function"==typeof s?s=o[t]=n?[r,s]:[s,r]:n?s.unshift(r):s.push(r),(i=u(e))>0&&s.length>i&&!s.warned){s.warned=!0;var h=new Error("Possible EventEmitter memory leak detected. "+s.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");h.name="MaxListenersExceededWarning",h.emitter=e,h.type=t,h.count=s.length,f=h,console&&console.warn&&console.warn(f);}return e}function h(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function l(e,t,r){var n={fired:!1,wrapFn:void 0,target:e,type:t,listener:r},i=h.bind(n);return i.listener=r,n.wrapFn=i,i}function c(e,t,r){var n=e._events;if(void 0===n)return [];var i=n[t];return void 0===i?[]:"function"==typeof i?r?[i.listener||i]:[i]:r?function(e){for(var t=new Array(e.length),r=0;r<t.length;++r)t[r]=e[r].listener||e[r];return t}(i):p(i,i.length)}function d(e){var t=this._events;if(void 0!==t){var r=t[e];if("function"==typeof r)return 1;if(void 0!==r)return r.length}return 0}function p(e,t){for(var r=new Array(t),n=0;n<t;++n)r[n]=e[n];return r}function g(e,t,r,n){if("function"==typeof e.on)n.once?e.once(t,r):e.on(t,r);else {if("function"!=typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);e.addEventListener(t,(function i(o){n.once&&e.removeEventListener(t,i),r(o);}));}}Object.defineProperty(o,"defaultMaxListeners",{enumerable:!0,get:function(){return s},set:function(e){if("number"!=typeof e||e<0||i(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");s=e;}}),o.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0;},o.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||i(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},o.prototype.getMaxListeners=function(){return u(this)},o.prototype.emit=function(e){for(var t=[],r=1;r<arguments.length;r++)t.push(arguments[r]);var i="error"===e,o=this._events;if(void 0!==o)i=i&&void 0===o.error;else if(!i)return !1;if(i){var s;if(t.length>0&&(s=t[0]),s instanceof Error)throw s;var a=new Error("Unhandled error."+(s?" ("+s.message+")":""));throw a.context=s,a}var u=o[e];if(void 0===u)return !1;if("function"==typeof u)n(u,this,t);else {var f=u.length,h=p(u,f);for(r=0;r<f;++r)n(h[r],this,t);}return !0},o.prototype.addListener=function(e,t){return f(this,e,t,!1)},o.prototype.on=o.prototype.addListener,o.prototype.prependListener=function(e,t){return f(this,e,t,!0)},o.prototype.once=function(e,t){return a(t),this.on(e,l(this,e,t)),this},o.prototype.prependOnceListener=function(e,t){return a(t),this.prependListener(e,l(this,e,t)),this},o.prototype.removeListener=function(e,t){var r,n,i,o,s;if(a(t),void 0===(n=this._events))return this;if(void 0===(r=n[e]))return this;if(r===t||r.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete n[e],n.removeListener&&this.emit("removeListener",e,r.listener||t));else if("function"!=typeof r){for(i=-1,o=r.length-1;o>=0;o--)if(r[o]===t||r[o].listener===t){s=r[o].listener,i=o;break}if(i<0)return this;0===i?r.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop();}(r,i),1===r.length&&(n[e]=r[0]),void 0!==n.removeListener&&this.emit("removeListener",e,s||t);}return this},o.prototype.off=o.prototype.removeListener,o.prototype.removeAllListeners=function(e){var t,r,n;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete r[e]),this;if(0===arguments.length){var i,o=Object.keys(r);for(n=0;n<o.length;++n)"removeListener"!==(i=o[n])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=r[e]))this.removeListener(e,t);else if(void 0!==t)for(n=t.length-1;n>=0;n--)this.removeListener(e,t[n]);return this},o.prototype.listeners=function(e){return c(this,e,!0)},o.prototype.rawListeners=function(e){return c(this,e,!1)},o.listenerCount=function(e,t){return "function"==typeof e.listenerCount?e.listenerCount(t):d.call(e,t)},o.prototype.listenerCount=d,o.prototype.eventNames=function(){return this._eventsCount>0?t(this._events):[]};},645:(e,t)=>{t.read=function(e,t,r,n,i){var o,s,a=8*i-n-1,u=(1<<a)-1,f=u>>1,h=-7,l=r?i-1:0,c=r?-1:1,d=e[t+l];for(l+=c,o=d&(1<<-h)-1,d>>=-h,h+=a;h>0;o=256*o+e[t+l],l+=c,h-=8);for(s=o&(1<<-h)-1,o>>=-h,h+=n;h>0;s=256*s+e[t+l],l+=c,h-=8);if(0===o)o=1-f;else {if(o===u)return s?NaN:1/0*(d?-1:1);s+=Math.pow(2,n),o-=f;}return (d?-1:1)*s*Math.pow(2,o-n)},t.write=function(e,t,r,n,i,o){var s,a,u,f=8*o-i-1,h=(1<<f)-1,l=h>>1,c=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=n?0:o-1,p=n?1:-1,g=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,s=h):(s=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-s))<1&&(s--,u*=2),(t+=s+l>=1?c/u:c*Math.pow(2,1-l))*u>=2&&(s++,u/=2),s+l>=h?(a=0,s=h):s+l>=1?(a=(t*u-1)*Math.pow(2,i),s+=l):(a=t*Math.pow(2,l-1)*Math.pow(2,i),s=0));i>=8;e[r+d]=255&a,d+=p,a/=256,i-=8);for(s=s<<i|a,f+=i;f>0;e[r+d]=255&s,d+=p,s/=256,f-=8);e[r+d-p]|=128*g;};},717:e=>{"function"==typeof Object.create?e.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}));}:e.exports=function(e,t){if(t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e;}};},155:e=>{var t,r,n=e.exports={};function i(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function s(e){if(t===setTimeout)return setTimeout(e,0);if((t===i||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(r){try{return t.call(null,e,0)}catch(r){return t.call(this,e,0)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:i;}catch(e){t=i;}try{r="function"==typeof clearTimeout?clearTimeout:o;}catch(e){r=o;}}();var a,u=[],f=!1,h=-1;function l(){f&&a&&(f=!1,a.length?u=a.concat(u):h=-1,u.length&&c());}function c(){if(!f){var e=s(l);f=!0;for(var t=u.length;t;){for(a=u,u=[];++h<t;)a&&a[h].run();h=-1,t=u.length;}a=null,f=!1,function(e){if(r===clearTimeout)return clearTimeout(e);if((r===o||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(e);try{r(e);}catch(t){try{return r.call(null,e)}catch(t){return r.call(this,e)}}}(e);}}function d(e,t){this.fun=e,this.array=t;}function p(){}n.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];u.push(new d(e,t)),1!==u.length||f||s(c);},d.prototype.run=function(){this.fun.apply(null,this.array);},n.title="browser",n.browser=!0,n.env={},n.argv=[],n.version="",n.versions={},n.on=p,n.addListener=p,n.once=p,n.off=p,n.removeListener=p,n.removeAllListeners=p,n.emit=p,n.prependListener=p,n.prependOnceListener=p,n.listeners=function(e){return []},n.binding=function(e){throw new Error("process.binding is not supported")},n.cwd=function(){return "/"},n.chdir=function(e){throw new Error("process.chdir is not supported")},n.umask=function(){return 0};},281:e=>{var t={};function r(e,r,n){n||(n=Error);var i=function(e){var t,n;function i(t,n,i){return e.call(this,function(e,t,n){return "string"==typeof r?r:r(e,t,n)}(t,n,i))||this}return n=e,(t=i).prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n,i}(n);i.prototype.name=n.name,i.prototype.code=e,t[e]=i;}function n(e,t){if(Array.isArray(e)){var r=e.length;return e=e.map((function(e){return String(e)})),r>2?"one of ".concat(t," ").concat(e.slice(0,r-1).join(", "),", or ")+e[r-1]:2===r?"one of ".concat(t," ").concat(e[0]," or ").concat(e[1]):"of ".concat(t," ").concat(e[0])}return "of ".concat(t," ").concat(String(e))}r("ERR_INVALID_OPT_VALUE",(function(e,t){return 'The value "'+t+'" is invalid for option "'+e+'"'}),TypeError),r("ERR_INVALID_ARG_TYPE",(function(e,t,r){var i,o,s,a,u;if("string"==typeof t&&(o="not ",t.substr(0,o.length)===o)?(i="must not be",t=t.replace(/^not /,"")):i="must be",function(e,t,r){return (void 0===r||r>e.length)&&(r=e.length),e.substring(r-t.length,r)===t}(e," argument"))s="The ".concat(e," ").concat(i," ").concat(n(t,"type"));else {var f=("number"!=typeof u&&(u=0),u+".".length>(a=e).length||-1===a.indexOf(".",u)?"argument":"property");s='The "'.concat(e,'" ').concat(f," ").concat(i," ").concat(n(t,"type"));}return s+". Received type ".concat(typeof r)}),TypeError),r("ERR_STREAM_PUSH_AFTER_EOF","stream.push() after EOF"),r("ERR_METHOD_NOT_IMPLEMENTED",(function(e){return "The "+e+" method is not implemented"})),r("ERR_STREAM_PREMATURE_CLOSE","Premature close"),r("ERR_STREAM_DESTROYED",(function(e){return "Cannot call "+e+" after a stream was destroyed"})),r("ERR_MULTIPLE_CALLBACK","Callback called multiple times"),r("ERR_STREAM_CANNOT_PIPE","Cannot pipe, not readable"),r("ERR_STREAM_WRITE_AFTER_END","write after end"),r("ERR_STREAM_NULL_VALUES","May not write null values to stream",TypeError),r("ERR_UNKNOWN_ENCODING",(function(e){return "Unknown encoding: "+e}),TypeError),r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT","stream.unshift() after end event"),e.exports.q=t;},753:(e,t,r)=>{var n=r(155),i=Object.keys||function(e){var t=[];for(var r in e)t.push(r);return t};e.exports=h;var o=r(481),s=r(229);r(717)(h,o);for(var a=i(s.prototype),u=0;u<a.length;u++){var f=a[u];h.prototype[f]||(h.prototype[f]=s.prototype[f]);}function h(e){if(!(this instanceof h))return new h(e);o.call(this,e),s.call(this,e),this.allowHalfOpen=!0,e&&(!1===e.readable&&(this.readable=!1),!1===e.writable&&(this.writable=!1),!1===e.allowHalfOpen&&(this.allowHalfOpen=!1,this.once("end",l)));}function l(){this._writableState.ended||n.nextTick(c,this);}function c(e){e.end();}Object.defineProperty(h.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(h.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(h.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(h.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&this._readableState.destroyed&&this._writableState.destroyed},set:function(e){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=e,this._writableState.destroyed=e);}});},725:(e,t,r)=>{e.exports=i;var n=r(605);function i(e){if(!(this instanceof i))return new i(e);n.call(this,e);}r(717)(i,n),i.prototype._transform=function(e,t,r){r(null,e);};},481:(e,t,r)=>{var n,i=r(155);e.exports=I,I.ReadableState=T,r(187).EventEmitter;var o,s=function(e,t){return e.listeners(t).length},a=r(503),u=r(764).Buffer,f=r.g.Uint8Array||function(){},h=r(616);o=h&&h.debuglog?h.debuglog("stream"):function(){};var l,c,d,p=r(327),g=r(195),y=r(457).getHighWaterMark,b=r(281).q,w=b.ERR_INVALID_ARG_TYPE,_=b.ERR_STREAM_PUSH_AFTER_EOF,m=b.ERR_METHOD_NOT_IMPLEMENTED,E=b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;r(717)(I,a);var v=g.errorOrDestroy,S=["error","close","destroy","pause","resume"];function T(e,t,i){n=n||r(753),e=e||{},"boolean"!=typeof i&&(i=t instanceof n),this.objectMode=!!e.objectMode,i&&(this.objectMode=this.objectMode||!!e.readableObjectMode),this.highWaterMark=y(this,e,"readableHighWaterMark",i),this.buffer=new p,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.paused=!0,this.emitClose=!1!==e.emitClose,this.autoDestroy=!!e.autoDestroy,this.destroyed=!1,this.defaultEncoding=e.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&&(l||(l=r(553).s),this.decoder=new l(e.encoding),this.encoding=e.encoding);}function I(e){if(n=n||r(753),!(this instanceof I))return new I(e);var t=this instanceof n;this._readableState=new T(e,this,t),this.readable=!0,e&&("function"==typeof e.read&&(this._read=e.read),"function"==typeof e.destroy&&(this._destroy=e.destroy)),a.call(this);}function A(e,t,r,n,i){o("readableAddChunk",t);var s,a=e._readableState;if(null===t)a.reading=!1,function(e,t){if(o("onEofChunk"),!t.ended){if(t.decoder){var r=t.decoder.end();r&&r.length&&(t.buffer.push(r),t.length+=t.objectMode?1:r.length);}t.ended=!0,t.sync?L(e):(t.needReadable=!1,t.emittedReadable||(t.emittedReadable=!0,N(e)));}}(e,a);else if(i||(s=function(e,t){var r,n;return n=t,u.isBuffer(n)||n instanceof f||"string"==typeof t||void 0===t||e.objectMode||(r=new w("chunk",["string","Buffer","Uint8Array"],t)),r}(a,t)),s)v(e,s);else if(a.objectMode||t&&t.length>0)if("string"==typeof t||a.objectMode||Object.getPrototypeOf(t)===u.prototype||(t=function(e){return u.from(e)}(t)),n)a.endEmitted?v(e,new E):B(e,a,t,!0);else if(a.ended)v(e,new _);else {if(a.destroyed)return !1;a.reading=!1,a.decoder&&!r?(t=a.decoder.write(t),a.objectMode||0!==t.length?B(e,a,t,!1):M(e,a)):B(e,a,t,!1);}else n||(a.reading=!1,M(e,a));return !a.ended&&(a.length<a.highWaterMark||0===a.length)}function B(e,t,r,n){t.flowing&&0===t.length&&!t.sync?(t.awaitDrain=0,e.emit("data",r)):(t.length+=t.objectMode?1:r.length,n?t.buffer.unshift(r):t.buffer.push(r),t.needReadable&&L(e)),M(e,t);}Object.defineProperty(I.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(e){this._readableState&&(this._readableState.destroyed=e);}}),I.prototype.destroy=g.destroy,I.prototype._undestroy=g.undestroy,I.prototype._destroy=function(e,t){t(e);},I.prototype.push=function(e,t){var r,n=this._readableState;return n.objectMode?r=!0:"string"==typeof e&&((t=t||n.defaultEncoding)!==n.encoding&&(e=u.from(e,t),t=""),r=!0),A(this,e,t,!1,r)},I.prototype.unshift=function(e){return A(this,e,null,!0,!1)},I.prototype.isPaused=function(){return !1===this._readableState.flowing},I.prototype.setEncoding=function(e){l||(l=r(553).s);var t=new l(e);this._readableState.decoder=t,this._readableState.encoding=this._readableState.decoder.encoding;for(var n=this._readableState.buffer.head,i="";null!==n;)i+=t.write(n.data),n=n.next;return this._readableState.buffer.clear(),""!==i&&this._readableState.buffer.push(i),this._readableState.length=i.length,this};var R=1073741824;function U(e,t){return e<=0||0===t.length&&t.ended?0:t.objectMode?1:e!=e?t.flowing&&t.length?t.buffer.head.data.length:t.length:(e>t.highWaterMark&&(t.highWaterMark=function(e){return e>=R?e=R:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function L(e){var t=e._readableState;o("emitReadable",t.needReadable,t.emittedReadable),t.needReadable=!1,t.emittedReadable||(o("emitReadable",t.flowing),t.emittedReadable=!0,i.nextTick(N,e));}function N(e){var t=e._readableState;o("emitReadable_",t.destroyed,t.length,t.ended),t.destroyed||!t.length&&!t.ended||(e.emit("readable"),t.emittedReadable=!1),t.needReadable=!t.flowing&&!t.ended&&t.length<=t.highWaterMark,j(e);}function M(e,t){t.readingMore||(t.readingMore=!0,i.nextTick(O,e,t));}function O(e,t){for(;!t.reading&&!t.ended&&(t.length<t.highWaterMark||t.flowing&&0===t.length);){var r=t.length;if(o("maybeReadMore read 0"),e.read(0),r===t.length)break}t.readingMore=!1;}function x(e){var t=e._readableState;t.readableListening=e.listenerCount("readable")>0,t.resumeScheduled&&!t.paused?t.flowing=!0:e.listenerCount("data")>0&&e.resume();}function k(e){o("readable nexttick read 0"),e.read(0);}function P(e,t){o("resume",t.reading),t.reading||e.read(0),t.resumeScheduled=!1,e.emit("resume"),j(e),t.flowing&&!t.reading&&e.read(0);}function j(e){var t=e._readableState;for(o("flow",t.flowing);t.flowing&&null!==e.read(););}function C(e,t){return 0===t.length?null:(t.objectMode?r=t.buffer.shift():!e||e>=t.length?(r=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.first():t.buffer.concat(t.length),t.buffer.clear()):r=t.buffer.consume(e,t.decoder),r);var r;}function F(e){var t=e._readableState;o("endReadable",t.endEmitted),t.endEmitted||(t.ended=!0,i.nextTick(D,t,e));}function D(e,t){if(o("endReadableNT",e.endEmitted,e.length),!e.endEmitted&&0===e.length&&(e.endEmitted=!0,t.readable=!1,t.emit("end"),e.autoDestroy)){var r=t._writableState;(!r||r.autoDestroy&&r.finished)&&t.destroy();}}function $(e,t){for(var r=0,n=e.length;r<n;r++)if(e[r]===t)return r;return -1}I.prototype.read=function(e){o("read",e),e=parseInt(e,10);var t=this._readableState,r=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&((0!==t.highWaterMark?t.length>=t.highWaterMark:t.length>0)||t.ended))return o("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?F(this):L(this),null;if(0===(e=U(e,t))&&t.ended)return 0===t.length&&F(this),null;var n,i=t.needReadable;return o("need readable",i),(0===t.length||t.length-e<t.highWaterMark)&&o("length less than watermark",i=!0),t.ended||t.reading?o("reading or ended",i=!1):i&&(o("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=U(r,t))),null===(n=e>0?C(e,t):null)?(t.needReadable=t.length<=t.highWaterMark,e=0):(t.length-=e,t.awaitDrain=0),0===t.length&&(t.ended||(t.needReadable=!0),r!==e&&t.ended&&F(this)),null!==n&&this.emit("data",n),n},I.prototype._read=function(e){v(this,new m("_read()"));},I.prototype.pipe=function(e,t){var r=this,n=this._readableState;switch(n.pipesCount){case 0:n.pipes=e;break;case 1:n.pipes=[n.pipes,e];break;default:n.pipes.push(e);}n.pipesCount+=1,o("pipe count=%d opts=%j",n.pipesCount,t);var a=t&&!1===t.end||e===i.stdout||e===i.stderr?g:u;function u(){o("onend"),e.end();}n.endEmitted?i.nextTick(a):r.once("end",a),e.on("unpipe",(function t(i,s){o("onunpipe"),i===r&&s&&!1===s.hasUnpiped&&(s.hasUnpiped=!0,o("cleanup"),e.removeListener("close",d),e.removeListener("finish",p),e.removeListener("drain",f),e.removeListener("error",c),e.removeListener("unpipe",t),r.removeListener("end",u),r.removeListener("end",g),r.removeListener("data",l),h=!0,!n.awaitDrain||e._writableState&&!e._writableState.needDrain||f());}));var f=function(e){return function(){var t=e._readableState;o("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&s(e,"data")&&(t.flowing=!0,j(e));}}(r);e.on("drain",f);var h=!1;function l(t){o("ondata");var i=e.write(t);o("dest.write",i),!1===i&&((1===n.pipesCount&&n.pipes===e||n.pipesCount>1&&-1!==$(n.pipes,e))&&!h&&(o("false write response, pause",n.awaitDrain),n.awaitDrain++),r.pause());}function c(t){o("onerror",t),g(),e.removeListener("error",c),0===s(e,"error")&&v(e,t);}function d(){e.removeListener("finish",p),g();}function p(){o("onfinish"),e.removeListener("close",d),g();}function g(){o("unpipe"),r.unpipe(e);}return r.on("data",l),function(e,t,r){if("function"==typeof e.prependListener)return e.prependListener(t,r);e._events&&e._events.error?Array.isArray(e._events.error)?e._events.error.unshift(r):e._events.error=[r,e._events.error]:e.on(t,r);}(e,"error",c),e.once("close",d),e.once("finish",p),e.emit("pipe",r),n.flowing||(o("pipe resume"),r.resume()),e},I.prototype.unpipe=function(e){var t=this._readableState,r={hasUnpiped:!1};if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes||(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this,r)),this;if(!e){var n=t.pipes,i=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var o=0;o<i;o++)n[o].emit("unpipe",this,{hasUnpiped:!1});return this}var s=$(t.pipes,e);return -1===s||(t.pipes.splice(s,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this,r)),this},I.prototype.on=function(e,t){var r=a.prototype.on.call(this,e,t),n=this._readableState;return "data"===e?(n.readableListening=this.listenerCount("readable")>0,!1!==n.flowing&&this.resume()):"readable"===e&&(n.endEmitted||n.readableListening||(n.readableListening=n.needReadable=!0,n.flowing=!1,n.emittedReadable=!1,o("on readable",n.length,n.reading),n.length?L(this):n.reading||i.nextTick(k,this))),r},I.prototype.addListener=I.prototype.on,I.prototype.removeListener=function(e,t){var r=a.prototype.removeListener.call(this,e,t);return "readable"===e&&i.nextTick(x,this),r},I.prototype.removeAllListeners=function(e){var t=a.prototype.removeAllListeners.apply(this,arguments);return "readable"!==e&&void 0!==e||i.nextTick(x,this),t},I.prototype.resume=function(){var e=this._readableState;return e.flowing||(o("resume"),e.flowing=!e.readableListening,function(e,t){t.resumeScheduled||(t.resumeScheduled=!0,i.nextTick(P,e,t));}(this,e)),e.paused=!1,this},I.prototype.pause=function(){return o("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(o("pause"),this._readableState.flowing=!1,this.emit("pause")),this._readableState.paused=!0,this},I.prototype.wrap=function(e){var t=this,r=this._readableState,n=!1;for(var i in e.on("end",(function(){if(o("wrapped end"),r.decoder&&!r.ended){var e=r.decoder.end();e&&e.length&&t.push(e);}t.push(null);})),e.on("data",(function(i){o("wrapped data"),r.decoder&&(i=r.decoder.write(i)),r.objectMode&&null==i||(r.objectMode||i&&i.length)&&(t.push(i)||(n=!0,e.pause()));})),e)void 0===this[i]&&"function"==typeof e[i]&&(this[i]=function(t){return function(){return e[t].apply(e,arguments)}}(i));for(var s=0;s<S.length;s++)e.on(S[s],this.emit.bind(this,S[s]));return this._read=function(t){o("wrapped _read",t),n&&(n=!1,e.resume());},this},"function"==typeof Symbol&&(I.prototype[Symbol.asyncIterator]=function(){return void 0===c&&(c=r(850)),c(this)}),Object.defineProperty(I.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),Object.defineProperty(I.prototype,"readableBuffer",{enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}}),Object.defineProperty(I.prototype,"readableFlowing",{enumerable:!1,get:function(){return this._readableState.flowing},set:function(e){this._readableState&&(this._readableState.flowing=e);}}),I._fromList=C,Object.defineProperty(I.prototype,"readableLength",{enumerable:!1,get:function(){return this._readableState.length}}),"function"==typeof Symbol&&(I.from=function(e,t){return void 0===d&&(d=r(167)),d(I,e,t)});},605:(e,t,r)=>{e.exports=h;var n=r(281).q,i=n.ERR_METHOD_NOT_IMPLEMENTED,o=n.ERR_MULTIPLE_CALLBACK,s=n.ERR_TRANSFORM_ALREADY_TRANSFORMING,a=n.ERR_TRANSFORM_WITH_LENGTH_0,u=r(753);function f(e,t){var r=this._transformState;r.transforming=!1;var n=r.writecb;if(null===n)return this.emit("error",new o);r.writechunk=null,r.writecb=null,null!=t&&this.push(t),n(e);var i=this._readableState;i.reading=!1,(i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark);}function h(e){if(!(this instanceof h))return new h(e);u.call(this,e),this._transformState={afterTransform:f.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,e&&("function"==typeof e.transform&&(this._transform=e.transform),"function"==typeof e.flush&&(this._flush=e.flush)),this.on("prefinish",l);}function l(){var e=this;"function"!=typeof this._flush||this._readableState.destroyed?c(this,null,null):this._flush((function(t,r){c(e,t,r);}));}function c(e,t,r){if(t)return e.emit("error",t);if(null!=r&&e.push(r),e._writableState.length)throw new a;if(e._transformState.transforming)throw new s;return e.push(null)}r(717)(h,u),h.prototype.push=function(e,t){return this._transformState.needTransform=!1,u.prototype.push.call(this,e,t)},h.prototype._transform=function(e,t,r){r(new i("_transform()"));},h.prototype._write=function(e,t,r){var n=this._transformState;if(n.writecb=r,n.writechunk=e,n.writeencoding=t,!n.transforming){var i=this._readableState;(n.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark);}},h.prototype._read=function(e){var t=this._transformState;null===t.writechunk||t.transforming?t.needTransform=!0:(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform));},h.prototype._destroy=function(e,t){u.prototype._destroy.call(this,e,(function(e){t(e);}));};},229:(e,t,r)=>{var n,i=r(155);function o(e){var t=this;this.next=null,this.entry=null,this.finish=function(){!function(e,t,r){var n=e.entry;for(e.entry=null;n;){var i=n.callback;t.pendingcb--,i(undefined),n=n.next;}t.corkedRequestsFree.next=e;}(t,e);};}e.exports=I,I.WritableState=T;var s,a={deprecate:r(927)},u=r(503),f=r(764).Buffer,h=r.g.Uint8Array||function(){},l=r(195),c=r(457).getHighWaterMark,d=r(281).q,p=d.ERR_INVALID_ARG_TYPE,g=d.ERR_METHOD_NOT_IMPLEMENTED,y=d.ERR_MULTIPLE_CALLBACK,b=d.ERR_STREAM_CANNOT_PIPE,w=d.ERR_STREAM_DESTROYED,_=d.ERR_STREAM_NULL_VALUES,m=d.ERR_STREAM_WRITE_AFTER_END,E=d.ERR_UNKNOWN_ENCODING,v=l.errorOrDestroy;function S(){}function T(e,t,s){n=n||r(753),e=e||{},"boolean"!=typeof s&&(s=t instanceof n),this.objectMode=!!e.objectMode,s&&(this.objectMode=this.objectMode||!!e.writableObjectMode),this.highWaterMark=c(this,e,"writableHighWaterMark",s),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var a=!1===e.decodeStrings;this.decodeStrings=!a,this.defaultEncoding=e.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){!function(e,t){var r=e._writableState,n=r.sync,o=r.writecb;if("function"!=typeof o)throw new y;if(function(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0;}(r),t)!function(e,t,r,n,o){--t.pendingcb,r?(i.nextTick(o,n),i.nextTick(N,e,t),e._writableState.errorEmitted=!0,v(e,n)):(o(n),e._writableState.errorEmitted=!0,v(e,n),N(e,t));}(e,r,n,t,o);else {var s=U(r)||e.destroyed;s||r.corked||r.bufferProcessing||!r.bufferedRequest||R(e,r),n?i.nextTick(B,e,r,s,o):B(e,r,s,o);}}(t,e);},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!1!==e.emitClose,this.autoDestroy=!!e.autoDestroy,this.bufferedRequestCount=0,this.corkedRequestsFree=new o(this);}function I(e){var t=this instanceof(n=n||r(753));if(!t&&!s.call(I,this))return new I(e);this._writableState=new T(e,this,t),this.writable=!0,e&&("function"==typeof e.write&&(this._write=e.write),"function"==typeof e.writev&&(this._writev=e.writev),"function"==typeof e.destroy&&(this._destroy=e.destroy),"function"==typeof e.final&&(this._final=e.final)),u.call(this);}function A(e,t,r,n,i,o,s){t.writelen=n,t.writecb=s,t.writing=!0,t.sync=!0,t.destroyed?t.onwrite(new w("write")):r?e._writev(i,t.onwrite):e._write(i,o,t.onwrite),t.sync=!1;}function B(e,t,r,n){r||function(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"));}(e,t),t.pendingcb--,n(),N(e,t);}function R(e,t){t.bufferProcessing=!0;var r=t.bufferedRequest;if(e._writev&&r&&r.next){var n=t.bufferedRequestCount,i=new Array(n),s=t.corkedRequestsFree;s.entry=r;for(var a=0,u=!0;r;)i[a]=r,r.isBuf||(u=!1),r=r.next,a+=1;i.allBuffers=u,A(e,t,!0,t.length,i,"",s.finish),t.pendingcb++,t.lastBufferedRequest=null,s.next?(t.corkedRequestsFree=s.next,s.next=null):t.corkedRequestsFree=new o(t),t.bufferedRequestCount=0;}else {for(;r;){var f=r.chunk,h=r.encoding,l=r.callback;if(A(e,t,!1,t.objectMode?1:f.length,f,h,l),r=r.next,t.bufferedRequestCount--,t.writing)break}null===r&&(t.lastBufferedRequest=null);}t.bufferedRequest=r,t.bufferProcessing=!1;}function U(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function L(e,t){e._final((function(r){t.pendingcb--,r&&v(e,r),t.prefinished=!0,e.emit("prefinish"),N(e,t);}));}function N(e,t){var r=U(t);if(r&&(function(e,t){t.prefinished||t.finalCalled||("function"!=typeof e._final||t.destroyed?(t.prefinished=!0,e.emit("prefinish")):(t.pendingcb++,t.finalCalled=!0,i.nextTick(L,e,t)));}(e,t),0===t.pendingcb&&(t.finished=!0,e.emit("finish"),t.autoDestroy))){var n=e._readableState;(!n||n.autoDestroy&&n.endEmitted)&&e.destroy();}return r}r(717)(I,u),T.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},function(){try{Object.defineProperty(T.prototype,"buffer",{get:a.deprecate((function(){return this.getBuffer()}),"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")});}catch(e){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(s=Function.prototype[Symbol.hasInstance],Object.defineProperty(I,Symbol.hasInstance,{value:function(e){return !!s.call(this,e)||this===I&&e&&e._writableState instanceof T}})):s=function(e){return e instanceof this},I.prototype.pipe=function(){v(this,new b);},I.prototype.write=function(e,t,r){var n,o=this._writableState,s=!1,a=!o.objectMode&&(n=e,f.isBuffer(n)||n instanceof h);return a&&!f.isBuffer(e)&&(e=function(e){return f.from(e)}(e)),"function"==typeof t&&(r=t,t=null),a?t="buffer":t||(t=o.defaultEncoding),"function"!=typeof r&&(r=S),o.ending?function(e,t){var r=new m;v(e,r),i.nextTick(t,r);}(this,r):(a||function(e,t,r,n){var o;return null===r?o=new _:"string"==typeof r||t.objectMode||(o=new p("chunk",["string","Buffer"],r)),!o||(v(e,o),i.nextTick(n,o),!1)}(this,o,e,r))&&(o.pendingcb++,s=function(e,t,r,n,i,o){if(!r){var s=function(e,t,r){return e.objectMode||!1===e.decodeStrings||"string"!=typeof t||(t=f.from(t,r)),t}(t,n,i);n!==s&&(r=!0,i="buffer",n=s);}var a=t.objectMode?1:n.length;t.length+=a;var u=t.length<t.highWaterMark;if(u||(t.needDrain=!0),t.writing||t.corked){var h=t.lastBufferedRequest;t.lastBufferedRequest={chunk:n,encoding:i,isBuf:r,callback:o,next:null},h?h.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1;}else A(e,t,!1,a,n,i,o);return u}(this,o,a,e,t,r)),s},I.prototype.cork=function(){this._writableState.corked++;},I.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.bufferProcessing||!e.bufferedRequest||R(this,e));},I.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())>-1))throw new E(e);return this._writableState.defaultEncoding=e,this},Object.defineProperty(I.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(I.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),I.prototype._write=function(e,t,r){r(new g("_write()"));},I.prototype._writev=null,I.prototype.end=function(e,t,r){var n=this._writableState;return "function"==typeof e?(r=e,e=null,t=null):"function"==typeof t&&(r=t,t=null),null!=e&&this.write(e,t),n.corked&&(n.corked=1,this.uncork()),n.ending||function(e,t,r){t.ending=!0,N(e,t),r&&(t.finished?i.nextTick(r):e.once("finish",r)),t.ended=!0,e.writable=!1;}(this,n,r),this},Object.defineProperty(I.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(I.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(e){this._writableState&&(this._writableState.destroyed=e);}}),I.prototype.destroy=l.destroy,I.prototype._undestroy=l.undestroy,I.prototype._destroy=function(e,t){t(e);};},850:(e,t,r)=>{var n,i=r(155);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var s=r(610),a=Symbol("lastResolve"),u=Symbol("lastReject"),f=Symbol("error"),h=Symbol("ended"),l=Symbol("lastPromise"),c=Symbol("handlePromise"),d=Symbol("stream");function p(e,t){return {value:e,done:t}}function g(e){var t=e[a];if(null!==t){var r=e[d].read();null!==r&&(e[l]=null,e[a]=null,e[u]=null,t(p(r,!1)));}}function y(e){i.nextTick(g,e);}var b=Object.getPrototypeOf((function(){})),w=Object.setPrototypeOf((o(n={get stream(){return this[d]},next:function(){var e=this,t=this[f];if(null!==t)return Promise.reject(t);if(this[h])return Promise.resolve(p(void 0,!0));if(this[d].destroyed)return new Promise((function(t,r){i.nextTick((function(){e[f]?r(e[f]):t(p(void 0,!0));}));}));var r,n=this[l];if(n)r=new Promise(function(e,t){return function(r,n){e.then((function(){t[h]?r(p(void 0,!0)):t[c](r,n);}),n);}}(n,this));else {var o=this[d].read();if(null!==o)return Promise.resolve(p(o,!1));r=new Promise(this[c]);}return this[l]=r,r}},Symbol.asyncIterator,(function(){return this})),o(n,"return",(function(){var e=this;return new Promise((function(t,r){e[d].destroy(null,(function(e){e?r(e):t(p(void 0,!0));}));}))})),n),b);e.exports=function(e){var t,r=Object.create(w,(o(t={},d,{value:e,writable:!0}),o(t,a,{value:null,writable:!0}),o(t,u,{value:null,writable:!0}),o(t,f,{value:null,writable:!0}),o(t,h,{value:e._readableState.endEmitted,writable:!0}),o(t,c,{value:function(e,t){var n=r[d].read();n?(r[l]=null,r[a]=null,r[u]=null,e(p(n,!1))):(r[a]=e,r[u]=t);},writable:!0}),t));return r[l]=null,s(e,(function(e){if(e&&"ERR_STREAM_PREMATURE_CLOSE"!==e.code){var t=r[u];return null!==t&&(r[l]=null,r[a]=null,r[u]=null,t(e)),void(r[f]=e)}var n=r[a];null!==n&&(r[l]=null,r[a]=null,r[u]=null,n(p(void 0,!0))),r[h]=!0;})),e.on("readable",y.bind(null,r)),r};},327:(e,t,r)=>{function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n);}return r}function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}var s=r(764).Buffer,a=r(361).inspect,u=a&&a.custom||"inspect";e.exports=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.head=null,this.tail=null,this.length=0;}var t,r;return t=e,r=[{key:"push",value:function(e){var t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length;}},{key:"unshift",value:function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length;}},{key:"shift",value:function(){if(0!==this.length){var e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}}},{key:"clear",value:function(){this.head=this.tail=null,this.length=0;}},{key:"join",value:function(e){if(0===this.length)return "";for(var t=this.head,r=""+t.data;t=t.next;)r+=e+t.data;return r}},{key:"concat",value:function(e){if(0===this.length)return s.alloc(0);for(var t,r,n,i=s.allocUnsafe(e>>>0),o=this.head,a=0;o;)t=o.data,r=i,n=a,s.prototype.copy.call(t,r,n),a+=o.data.length,o=o.next;return i}},{key:"consume",value:function(e,t){var r;return e<this.head.data.length?(r=this.head.data.slice(0,e),this.head.data=this.head.data.slice(e)):r=e===this.head.data.length?this.shift():t?this._getString(e):this._getBuffer(e),r}},{key:"first",value:function(){return this.head.data}},{key:"_getString",value:function(e){var t=this.head,r=1,n=t.data;for(e-=n.length;t=t.next;){var i=t.data,o=e>i.length?i.length:e;if(o===i.length?n+=i:n+=i.slice(0,e),0==(e-=o)){o===i.length?(++r,t.next?this.head=t.next:this.head=this.tail=null):(this.head=t,t.data=i.slice(o));break}++r;}return this.length-=r,n}},{key:"_getBuffer",value:function(e){var t=s.allocUnsafe(e),r=this.head,n=1;for(r.data.copy(t),e-=r.data.length;r=r.next;){var i=r.data,o=e>i.length?i.length:e;if(i.copy(t,t.length-e,0,o),0==(e-=o)){o===i.length?(++n,r.next?this.head=r.next:this.head=this.tail=null):(this.head=r,r.data=i.slice(o));break}++n;}return this.length-=n,t}},{key:u,value:function(e,t){return a(this,function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){i(e,t,r[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t));}));}return e}({},t,{depth:0,customInspect:!1}))}}],r&&o(t.prototype,r),e}();},195:(e,t,r)=>{var n=r(155);function i(e,t){s(e,t),o(e);}function o(e){e._writableState&&!e._writableState.emitClose||e._readableState&&!e._readableState.emitClose||e.emit("close");}function s(e,t){e.emit("error",t);}e.exports={destroy:function(e,t){var r=this,a=this._readableState&&this._readableState.destroyed,u=this._writableState&&this._writableState.destroyed;return a||u?(t?t(e):e&&(this._writableState?this._writableState.errorEmitted||(this._writableState.errorEmitted=!0,n.nextTick(s,this,e)):n.nextTick(s,this,e)),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(e||null,(function(e){!t&&e?r._writableState?r._writableState.errorEmitted?n.nextTick(o,r):(r._writableState.errorEmitted=!0,n.nextTick(i,r,e)):n.nextTick(i,r,e):t?(n.nextTick(o,r),t(e)):n.nextTick(o,r);})),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finalCalled=!1,this._writableState.prefinished=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1);},errorOrDestroy:function(e,t){var r=e._readableState,n=e._writableState;r&&r.autoDestroy||n&&n.autoDestroy?e.destroy(t):e.emit("error",t);}};},610:(e,t,r)=>{var n=r(281).q.ERR_STREAM_PREMATURE_CLOSE;function i(){}e.exports=function e(t,r,o){if("function"==typeof r)return e(t,null,r);r||(r={}),o=function(e){var t=!1;return function(){if(!t){t=!0;for(var r=arguments.length,n=new Array(r),i=0;i<r;i++)n[i]=arguments[i];e.apply(this,n);}}}(o||i);var s=r.readable||!1!==r.readable&&t.readable,a=r.writable||!1!==r.writable&&t.writable,u=function(){t.writable||h();},f=t._writableState&&t._writableState.finished,h=function(){a=!1,f=!0,s||o.call(t);},l=t._readableState&&t._readableState.endEmitted,c=function(){s=!1,l=!0,a||o.call(t);},d=function(e){o.call(t,e);},p=function(){var e;return s&&!l?(t._readableState&&t._readableState.ended||(e=new n),o.call(t,e)):a&&!f?(t._writableState&&t._writableState.ended||(e=new n),o.call(t,e)):void 0},g=function(){t.req.on("finish",h);};return function(e){return e.setHeader&&"function"==typeof e.abort}(t)?(t.on("complete",h),t.on("abort",p),t.req?g():t.on("request",g)):a&&!t._writableState&&(t.on("end",u),t.on("close",u)),t.on("end",c),t.on("finish",h),!1!==r.error&&t.on("error",d),t.on("close",p),function(){t.removeListener("complete",h),t.removeListener("abort",p),t.removeListener("request",g),t.req&&t.req.removeListener("finish",h),t.removeListener("end",u),t.removeListener("close",u),t.removeListener("finish",h),t.removeListener("end",c),t.removeListener("error",d),t.removeListener("close",p);}};},167:e=>{e.exports=function(){throw new Error("Readable.from is not available in the browser")};},946:(e,t,r)=>{var n,i=r(281).q,o=i.ERR_MISSING_ARGS,s=i.ERR_STREAM_DESTROYED;function a(e){if(e)throw e}function u(e,t,i,o){o=function(e){var t=!1;return function(){t||(t=!0,e.apply(void 0,arguments));}}(o);var a=!1;e.on("close",(function(){a=!0;})),void 0===n&&(n=r(610)),n(e,{readable:t,writable:i},(function(e){if(e)return o(e);a=!0,o();}));var u=!1;return function(t){if(!a&&!u)return u=!0,function(e){return e.setHeader&&"function"==typeof e.abort}(e)?e.abort():"function"==typeof e.destroy?e.destroy():void o(t||new s("pipe"))}}function f(e){e();}function h(e,t){return e.pipe(t)}function l(e){return e.length?"function"!=typeof e[e.length-1]?a:e.pop():a}e.exports=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var n,i=l(t);if(Array.isArray(t[0])&&(t=t[0]),t.length<2)throw new o("streams");var s=t.map((function(e,r){var o=r<t.length-1;return u(e,o,r>0,(function(e){n||(n=e),e&&s.forEach(f),o||(s.forEach(f),i(n));}))}));return t.reduce(h)};},457:(e,t,r)=>{var n=r(281).q.ERR_INVALID_OPT_VALUE;e.exports={getHighWaterMark:function(e,t,r,i){var o=function(e,t,r){return null!=e.highWaterMark?e.highWaterMark:t?e[r]:null}(t,i,r);if(null!=o){if(!isFinite(o)||Math.floor(o)!==o||o<0)throw new n(i?r:"highWaterMark",o);return Math.floor(o)}return e.objectMode?16:16384}};},503:(e,t,r)=>{e.exports=r(187).EventEmitter;},509:(e,t,r)=>{var n=r(764),i=n.Buffer;function o(e,t){for(var r in e)t[r]=e[r];}function s(e,t,r){return i(e,t,r)}i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow?e.exports=n:(o(n,t),t.Buffer=s),s.prototype=Object.create(i.prototype),o(i,s),s.from=function(e,t,r){if("number"==typeof e)throw new TypeError("Argument must not be a number");return i(e,t,r)},s.alloc=function(e,t,r){if("number"!=typeof e)throw new TypeError("Argument must be a number");var n=i(e);return void 0!==t?"string"==typeof r?n.fill(t,r):n.fill(t):n.fill(0),n},s.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return i(e)},s.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return n.SlowBuffer(e)};},830:(e,t,r)=>{e.exports=i;var n=r(187).EventEmitter;function i(){n.call(this);}r(717)(i,n),i.Readable=r(481),i.Writable=r(229),i.Duplex=r(753),i.Transform=r(605),i.PassThrough=r(725),i.finished=r(610),i.pipeline=r(946),i.Stream=i,i.prototype.pipe=function(e,t){var r=this;function i(t){e.writable&&!1===e.write(t)&&r.pause&&r.pause();}function o(){r.readable&&r.resume&&r.resume();}r.on("data",i),e.on("drain",o),e._isStdio||t&&!1===t.end||(r.on("end",a),r.on("close",u));var s=!1;function a(){s||(s=!0,e.end());}function u(){s||(s=!0,"function"==typeof e.destroy&&e.destroy());}function f(e){if(h(),0===n.listenerCount(this,"error"))throw e}function h(){r.removeListener("data",i),e.removeListener("drain",o),r.removeListener("end",a),r.removeListener("close",u),r.removeListener("error",f),e.removeListener("error",f),r.removeListener("end",h),r.removeListener("close",h),e.removeListener("close",h);}return r.on("error",f),e.on("error",f),r.on("end",h),r.on("close",h),e.on("close",h),e.emit("pipe",r),e};},553:(e,t,r)=>{var n=r(509).Buffer,i=n.isEncoding||function(e){switch((e=""+e)&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return !0;default:return !1}};function o(e){var t;switch(this.encoding=function(e){var t=function(e){if(!e)return "utf8";for(var t;;)switch(e){case"utf8":case"utf-8":return "utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return "utf16le";case"latin1":case"binary":return "latin1";case"base64":case"ascii":case"hex":return e;default:if(t)return;e=(""+e).toLowerCase(),t=!0;}}(e);if("string"!=typeof t&&(n.isEncoding===i||!i(e)))throw new Error("Unknown encoding: "+e);return t||e}(e),this.encoding){case"utf16le":this.text=u,this.end=f,t=4;break;case"utf8":this.fillLast=a,t=4;break;case"base64":this.text=h,this.end=l,t=3;break;default:return this.write=c,void(this.end=d)}this.lastNeed=0,this.lastTotal=0,this.lastChar=n.allocUnsafe(t);}function s(e){return e<=127?0:e>>5==6?2:e>>4==14?3:e>>3==30?4:e>>6==2?-1:-2}function a(e){var t=this.lastTotal-this.lastNeed,r=function(e,t,r){if(128!=(192&t[0]))return e.lastNeed=0,"�";if(e.lastNeed>1&&t.length>1){if(128!=(192&t[1]))return e.lastNeed=1,"�";if(e.lastNeed>2&&t.length>2&&128!=(192&t[2]))return e.lastNeed=2,"�"}}(this,e);return void 0!==r?r:this.lastNeed<=e.length?(e.copy(this.lastChar,t,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(e.copy(this.lastChar,t,0,e.length),void(this.lastNeed-=e.length))}function u(e,t){if((e.length-t)%2==0){var r=e.toString("utf16le",t);if(r){var n=r.charCodeAt(r.length-1);if(n>=55296&&n<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=e[e.length-1],e.toString("utf16le",t,e.length-1)}function f(e){var t=e&&e.length?this.write(e):"";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return t+this.lastChar.toString("utf16le",0,r)}return t}function h(e,t){var r=(e.length-t)%3;return 0===r?e.toString("base64",t):(this.lastNeed=3-r,this.lastTotal=3,1===r?this.lastChar[0]=e[e.length-1]:(this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1]),e.toString("base64",t,e.length-r))}function l(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+this.lastChar.toString("base64",0,3-this.lastNeed):t}function c(e){return e.toString(this.encoding)}function d(e){return e&&e.length?this.write(e):""}t.s=o,o.prototype.write=function(e){if(0===e.length)return "";var t,r;if(this.lastNeed){if(void 0===(t=this.fillLast(e)))return "";r=this.lastNeed,this.lastNeed=0;}else r=0;return r<e.length?t?t+this.text(e,r):this.text(e,r):t||""},o.prototype.end=function(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+"�":t},o.prototype.text=function(e,t){var r=function(e,t,r){var n=t.length-1;if(n<r)return 0;var i=s(t[n]);return i>=0?(i>0&&(e.lastNeed=i-1),i):--n<r||-2===i?0:(i=s(t[n]))>=0?(i>0&&(e.lastNeed=i-2),i):--n<r||-2===i?0:(i=s(t[n]))>=0?(i>0&&(2===i?i=0:e.lastNeed=i-3),i):0}(this,e,t);if(!this.lastNeed)return e.toString("utf8",t);this.lastTotal=r;var n=e.length-(r-this.lastNeed);return e.copy(this.lastChar,0,n),e.toString("utf8",t,n)},o.prototype.fillLast=function(e){if(this.lastNeed<=e.length)return e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,e.length),this.lastNeed-=e.length;};},927:(e,t,r)=>{function n(e){try{if(!r.g.localStorage)return !1}catch(e){return !1}var t=r.g.localStorage[e];return null!=t&&"true"===String(t).toLowerCase()}e.exports=function(e,t){if(n("noDeprecation"))return e;var r=!1;return function(){if(!r){if(n("throwDeprecation"))throw new Error(t);n("traceDeprecation")?console.trace(t):console.warn(t),r=!0;}return e.apply(this,arguments)}};},361:()=>{},616:()=>{}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var o=t[n]={exports:{}};return e[n](o,o.exports,r),o.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]});},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});};var n={};return (()=>{r.r(n),r.d(n,{Commented:()=>e.Commented,Decoder:()=>e.Decoder,Diagnose:()=>e.Diagnose,Encoder:()=>e.Encoder,Map:()=>e.Map,Simple:()=>e.Simple,Tagged:()=>e.Tagged,comment:()=>e.UI,decode:()=>e.Jx,decodeAll:()=>e.fI,decodeAllSync:()=>e.cc,decodeFirst:()=>e.h8,decodeFirstSync:()=>e.$u,diagnose:()=>e.M,encode:()=>e.cv,encodeAsync:()=>e.WR,encodeCanonical:()=>e.N2,encodeOne:()=>e.TG,leveldb:()=>e.ww,reset:()=>e.mc});var e=r(141);})(),n})()}));
    });

    /* src/components/decoders/CBOR.svelte generated by Svelte v3.48.0 */

    const { Object: Object_1 } = globals;
    const file$3 = "src/components/decoders/CBOR.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (21:12) {:else}
    function create_else_block$1(ctx) {
    	let t_value = /*cborObj*/ ctx[0][/*key*/ ctx[2]] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*cborObj*/ 1 && t_value !== (t_value = /*cborObj*/ ctx[0][/*key*/ ctx[2]] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(21:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (19:9) {#if typeof cborObj[key] == "object" && cborObj[key].buffer}
    function create_if_block$2(ctx) {
    	let t_value = arrayBufferToHex(/*cborObj*/ ctx[0][/*key*/ ctx[2]].buffer) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*cborObj*/ 1 && t_value !== (t_value = arrayBufferToHex(/*cborObj*/ ctx[0][/*key*/ ctx[2]].buffer) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(19:9) {#if typeof cborObj[key] == \\\"object\\\" && cborObj[key].buffer}",
    		ctx
    	});

    	return block;
    }

    // (12:2) {#each Object.keys(cborObj) as key}
    function create_each_block$1(ctx) {
    	let tr;
    	let th;
    	let t0_value = /*key*/ ctx[2] + "";
    	let t0;
    	let t1;
    	let td;
    	let td_class_value;
    	let t2;

    	function select_block_type(ctx, dirty) {
    		if (typeof /*cborObj*/ ctx[0][/*key*/ ctx[2]] == "object" && /*cborObj*/ ctx[0][/*key*/ ctx[2]].buffer) return create_if_block$2;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			th = element("th");
    			t0 = text(t0_value);
    			t1 = space();
    			td = element("td");
    			if_block.c();
    			t2 = space();
    			add_location(th, file$3, 13, 6, 337);

    			attr_dev(td, "class", td_class_value = typeof /*cborObj*/ ctx[0][/*key*/ ctx[2]] == "object" && /*cborObj*/ ctx[0][/*key*/ ctx[2]].buffer
    			? "bytes"
    			: "");

    			add_location(td, file$3, 14, 6, 358);
    			add_location(tr, file$3, 12, 4, 326);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, th);
    			append_dev(th, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td);
    			if_block.m(td, null);
    			append_dev(tr, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*cborObj*/ 1 && t0_value !== (t0_value = /*key*/ ctx[2] + "")) set_data_dev(t0, t0_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(td, null);
    				}
    			}

    			if (dirty & /*cborObj*/ 1 && td_class_value !== (td_class_value = typeof /*cborObj*/ ctx[0][/*key*/ ctx[2]] == "object" && /*cborObj*/ ctx[0][/*key*/ ctx[2]].buffer
    			? "bytes"
    			: "")) {
    				attr_dev(td, "class", td_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(12:2) {#each Object.keys(cborObj) as key}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let table;
    	let tr;
    	let td;
    	let t1;
    	let div;
    	let t2;
    	let each_value = Object.keys(/*cborObj*/ ctx[0]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			tr = element("tr");
    			td = element("td");
    			td.textContent = "Key/Value Pairs";
    			t1 = space();
    			div = element("div");
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(td, file$3, 8, 4, 226);
    			attr_dev(div, "class", "line");
    			add_location(div, file$3, 9, 4, 255);
    			attr_dev(tr, "class", "section-header");
    			add_location(tr, file$3, 7, 2, 194);
    			attr_dev(table, "class", "properties");
    			add_location(table, file$3, 6, 0, 165);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, tr);
    			append_dev(tr, td);
    			append_dev(tr, t1);
    			append_dev(tr, div);
    			append_dev(table, t2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(table, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*cborObj, Object, arrayBufferToHex*/ 1) {
    				each_value = Object.keys(/*cborObj*/ ctx[0]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(table, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let cborObj;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CBOR', slots, []);
    	let { result } = $$props;
    	const writable_props = ['result'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CBOR> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('result' in $$props) $$invalidate(1, result = $$props.result);
    	};

    	$$self.$capture_state = () => ({ arrayBufferToHex, result, cborObj });

    	$$self.$inject_state = $$props => {
    		if ('result' in $$props) $$invalidate(1, result = $$props.result);
    		if ('cborObj' in $$props) $$invalidate(0, cborObj = $$props.cborObj);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*result*/ 2) {
    			$$invalidate(0, cborObj = Object.fromEntries(result.value));
    		}
    	};

    	return [cborObj, result];
    }

    class CBOR extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { result: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CBOR",
    			options,
    			id: create_fragment$3.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*result*/ ctx[1] === undefined && !('result' in props)) {
    			console.warn("<CBOR> was created without expected prop 'result'");
    		}
    	}

    	get result() {
    		throw new Error("<CBOR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set result(value) {
    		throw new Error("<CBOR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var cborDecoder = {
        name: "CBOR",
        fullName: "Concise Binary Object Representation",
        rfc: 8949,
        inputType: "bytes",
        outputType: "cbor",
        display: CBOR,
        f: (bytes) => {
            try {
                let cbor$1 = cbor.decodeFirstSync(bytes);
                return [cbor$1, null];
            }
            catch (_a) {
                return [null, null];
            }
        }
    };

    /*
     * Taken from https://github.com/pugetive/plist_parser
     * Modified to be compatible with isolated modules
     */

    const parse = function(plist_xml){
      var parser = new DOMParser();
        plist_xml = parser.parseFromString(plist_xml, 'text/xml');

      var result = _xml_to_json(plist_xml.getElementsByTagName('plist').item(0));
      return result;
    };

    const _xml_to_json = function(xml_node) {
      var parent_node = xml_node;
      var parent_node_name = parent_node.nodeName;

      // console.log("Working on parent node: ");
      // console.log(parent_node);

      var child_nodes = [];
      for(var i = 0; i < parent_node.childNodes.length; ++i){
        var child = parent_node.childNodes.item(i);
        if (child.nodeName != '#text'){
          child_nodes.push(child);
        }  }
      switch(parent_node_name){

        case 'plist':
          if (child_nodes.length > 1){
            // I'm not actually sure if it is legal to have multiple
            // top-level nodes just below <plist>. But I originally
            // wrote it to handle an array of nodes at that level,
            // so I'm leaving this handling in for now.
            var plist_array = [];
            for(var i = 0; i < child_nodes.length; ++i){
               plist_array.push(_xml_to_json(child_nodes[i]));
            }        // var plist_hash = {};
            // plist_hash['plist'] = plist_array;
            // return plist_hash;
            return plist_array;
          } else {
            // THIS is the standard case. The top-most node under
            // <plist> is either a <dict> or an <array>.
            return _xml_to_json(child_nodes[0]);
          }

        case 'dict':

          var dictionary = {};
          var key_name;
          var key_value;
          for(var i = 0; i < child_nodes.length; ++i){
            var child = child_nodes[i];
            if (child.nodeName == '#text'); else if (child.nodeName == 'key'){
              key_name = _textValue(child.firstChild);
            } else {
              key_value = _xml_to_json(child);
              dictionary[key_name] = key_value;
            }
          }

          return dictionary;

        case 'array':

          var standard_array = [];
          for(var i = 0; i < child_nodes.length; ++i){
            var child = child_nodes[i];
            standard_array.push(_xml_to_json(child));
          }
          return standard_array;

        case 'string':

          return _textValue(parent_node);

        case 'date':

          var date = _parseDate(_textValue(parent_node));
          return date.toString();

        case 'integer':

          // Second argument (radix parameter) forces string to be interpreted in base 10.
          return parseInt(_textValue(parent_node), 10);

        case 'real':

          return parseFloat(_textValue(parent_node));

        case 'data':

          return _textValue(parent_node);

        case 'true':

          return true;

        case 'false':

          return false;
      }};


    const _textValue = function(node) {
      if (node.text){
        return node.text;
      } else {
        return node.textContent;
      }};

    // Handle date parsing in non-FF browsers
    // Thanks to http://www.west-wind.com/weblog/posts/729630.aspx
    const _parseDate = function(date_string){
      var reISO = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;
      var matched_date = reISO.exec(date_string);
      if (matched_date){
        return new Date(Date.UTC(+matched_date[1], +matched_date[2] - 1, +matched_date[3], +matched_date[4], +matched_date[5], +matched_date[6]));
      }};

    /* src/components/decoders/Plist.svelte generated by Svelte v3.48.0 */
    const file$2 = "src/components/decoders/Plist.svelte";

    function create_fragment$2(ctx) {
    	let p;
    	let t1;
    	let code;
    	let current;

    	code = new Code({
    			props: {
    				string: JSON.stringify(/*result*/ ctx[0].value, null, 4)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Plist properties displayed as JSON object";
    			t1 = space();
    			create_component(code.$$.fragment);
    			attr_dev(p, "class", "svelte-1wdvnvp");
    			add_location(p, file$2, 5, 0, 107);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(code, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const code_changes = {};
    			if (dirty & /*result*/ 1) code_changes.string = JSON.stringify(/*result*/ ctx[0].value, null, 4);
    			code.$set(code_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(code.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(code.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t1);
    			destroy_component(code, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Plist', slots, []);
    	let { result } = $$props;
    	const writable_props = ['result'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Plist> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('result' in $$props) $$invalidate(0, result = $$props.result);
    	};

    	$$self.$capture_state = () => ({ Code, result });

    	$$self.$inject_state = $$props => {
    		if ('result' in $$props) $$invalidate(0, result = $$props.result);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [result];
    }

    class Plist extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { result: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Plist",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*result*/ ctx[0] === undefined && !('result' in props)) {
    			console.warn("<Plist> was created without expected prop 'result'");
    		}
    	}

    	get result() {
    		throw new Error("<Plist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set result(value) {
    		throw new Error("<Plist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var plistDecoder = {
        name: "PLIST",
        fullName: "Apple Property List",
        inputType: "text",
        outputType: "json",
        display: Plist,
        f: (text) => {
            try {
                return [parse(text), null];
            }
            catch (err) {
                console.log(err);
                return [null, null];
            }
        }
    };

    let decoders = [
        hexDecoder,
        base64Decoder,
        base64urlDecoder,
        jsonDecoder,
        jwtDecoder,
        asn1Decoder,
        x509Decoder,
        csrDecoder,
        cmsDecoder,
        pemDecoder,
        cborDecoder,
        plistDecoder,
        uriencodingDecoder,
        asciiDecoder,
    ];
    const decodeRoot = (type, data) => {
        let results = decode([{
                type,
                value: data
            }]);
        return results.slice(1, results.length);
    };
    const decode = (previousDecodings) => {
        let lastDecoding = previousDecodings[previousDecodings.length - 1];
        let type = lastDecoding.type;
        let data = lastDecoding.value;
        let appropriateDecoders = decoders.filter((d) => d.inputType == type);
        for (var i = 0; i < appropriateDecoders.length; i++) {
            let decoder = appropriateDecoders[i];
            let [r, displayProps] = decoder.f(data);
            if (r) {
                return decode(previousDecodings.concat([{
                        decoder,
                        type: decoder.outputType,
                        displayProps,
                        value: r,
                    }]));
            }
        }
        return previousDecodings;
    };

    /* src/components/ResultsView.svelte generated by Svelte v3.48.0 */
    const file$1 = "src/components/ResultsView.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[6] = i;
    	return child_ctx;
    }

    // (26:4) {#each results as step, i}
    function create_each_block(ctx) {
    	let span;
    	let t1;
    	let button;
    	let current;

    	function func() {
    		return /*func*/ ctx[3](/*i*/ ctx[6]);
    	}

    	button = new Button({
    			props: {
    				title: /*step*/ ctx[4].decoder.name,
    				secondary: true,
    				active: /*selectedResult*/ ctx[2] == /*i*/ ctx[6],
    				onClick: func,
    				noBold: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "▸";
    			t1 = space();
    			create_component(button.$$.fragment);
    			attr_dev(span, "class", "arrow svelte-qgz5xd");
    			add_location(span, file$1, 26, 6, 584);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button_changes = {};
    			if (dirty & /*results*/ 1) button_changes.title = /*step*/ ctx[4].decoder.name;
    			if (dirty & /*selectedResult*/ 4) button_changes.active = /*selectedResult*/ ctx[2] == /*i*/ ctx[6];
    			if (dirty & /*selectedResult*/ 4) button_changes.onClick = func;
    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(26:4) {#each results as step, i}",
    		ctx
    	});

    	return block;
    }

    // (67:2) {:else}
    function create_else_block_1(ctx) {
    	let div;
    	let p;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			p.textContent = "Not sure what this is...";
    			add_location(p, file$1, 68, 6, 1783);
    			attr_dev(div, "class", "details svelte-qgz5xd");
    			add_location(div, file$1, 67, 4, 1755);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(67:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (39:2) {#if results.length > 0}
    function create_if_block$1(ctx) {
    	let div1;
    	let p;
    	let t0_value = /*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.name + "";
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let div0;
    	let current_block_type_index;
    	let if_block2;
    	let current;
    	let if_block0 = /*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.fullName && create_if_block_3(ctx);
    	let if_block1 = /*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.rfc && create_if_block_2(ctx);
    	const if_block_creators = [create_if_block_1, create_else_block];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.display) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			div0 = element("div");
    			if_block2.c();
    			attr_dev(p, "class", "title svelte-qgz5xd");
    			add_location(p, file$1, 40, 6, 892);
    			attr_dev(div0, "class", "decoderDisplay svelte-qgz5xd");
    			add_location(div0, file$1, 55, 6, 1401);
    			attr_dev(div1, "class", "details svelte-qgz5xd");
    			add_location(div1, file$1, 39, 4, 864);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, p);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			if (if_block0) if_block0.m(p, null);
    			append_dev(div1, t2);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*results, selectedResult*/ 5) && t0_value !== (t0_value = /*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.name + "")) set_data_dev(t0, t0_value);

    			if (/*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.fullName) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					if_block0.m(p, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.rfc) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2(ctx);
    					if_block1.c();
    					if_block1.m(div1, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div0, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(39:2) {#if results.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (43:8) {#if results[selectedResult].decoder.fullName}
    function create_if_block_3(ctx) {
    	let t0;
    	let t1_value = /*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.fullName + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text("(");
    			t1 = text(t1_value);
    			t2 = text(")");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*results, selectedResult*/ 5 && t1_value !== (t1_value = /*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.fullName + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(43:8) {#if results[selectedResult].decoder.fullName}",
    		ctx
    	});

    	return block;
    }

    // (47:6) {#if results[selectedResult].decoder.rfc}
    function create_if_block_2(ctx) {
    	let p;
    	let t0;
    	let a;
    	let t1;
    	let t2_value = /*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.rfc + "";
    	let t2;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Defined in: ");
    			a = element("a");
    			t1 = text("RFC ");
    			t2 = text(t2_value);
    			attr_dev(a, "href", a_href_value = "https://datatracker.ietf.org/doc/rfc" + /*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.rfc);
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$1, 48, 22, 1174);
    			add_location(p, file$1, 47, 8, 1148);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, a);
    			append_dev(a, t1);
    			append_dev(a, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*results, selectedResult*/ 5 && t2_value !== (t2_value = /*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.rfc + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*results, selectedResult*/ 5 && a_href_value !== (a_href_value = "https://datatracker.ietf.org/doc/rfc" + /*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.rfc)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(47:6) {#if results[selectedResult].decoder.rfc}",
    		ctx
    	});

    	return block;
    }

    // (62:8) {:else}
    function create_else_block(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No additional details.";
    			attr_dev(p, "class", "noDisplay svelte-qgz5xd");
    			add_location(p, file$1, 62, 10, 1655);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(62:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (57:8) {#if results[selectedResult].decoder.display}
    function create_if_block_1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.display;

    	function switch_props(ctx) {
    		return {
    			props: {
    				result: /*results*/ ctx[0][/*selectedResult*/ ctx[2]]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*results, selectedResult*/ 5) switch_instance_changes.result = /*results*/ ctx[0][/*selectedResult*/ ctx[2]];

    			if (switch_value !== (switch_value = /*results*/ ctx[0][/*selectedResult*/ ctx[2]].decoder.display)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(57:8) {#if results[selectedResult].decoder.display}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let div1;
    	let div0;
    	let p;
    	let t1;
    	let button;
    	let t2;
    	let t3;
    	let current_block_type_index;
    	let if_block;
    	let current;

    	button = new Button({
    			props: {
    				title: "Input - " + (/*inputType*/ ctx[1].charAt(0).toUpperCase() + /*inputType*/ ctx[1].substring(1, /*inputType*/ ctx[1].length)),
    				secondary: true,
    				disabled: true,
    				noBold: true
    			},
    			$$inline: true
    		});

    	let each_value = /*results*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const if_block_creators = [create_if_block$1, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*results*/ ctx[0].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			p.textContent = "Decoding steps:";
    			t1 = space();
    			create_component(button.$$.fragment);
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			if_block.c();
    			attr_dev(p, "class", "svelte-qgz5xd");
    			add_location(p, file$1, 17, 4, 352);
    			attr_dev(div0, "class", "steps svelte-qgz5xd");
    			add_location(div0, file$1, 16, 2, 328);
    			attr_dev(div1, "class", "results svelte-qgz5xd");
    			add_location(div1, file$1, 15, 0, 304);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(div0, t1);
    			mount_component(button, div0, null);
    			append_dev(div0, t2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div1, t3);
    			if_blocks[current_block_type_index].m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const button_changes = {};
    			if (dirty & /*inputType*/ 2) button_changes.title = "Input - " + (/*inputType*/ ctx[1].charAt(0).toUpperCase() + /*inputType*/ ctx[1].substring(1, /*inputType*/ ctx[1].length));
    			button.$set(button_changes);

    			if (dirty & /*results, selectedResult*/ 5) {
    				each_value = /*results*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div1, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(button);
    			destroy_each(each_blocks, detaching);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ResultsView', slots, []);
    	let { results } = $$props;
    	let { inputType } = $$props;
    	let selectedResult = results.length - 1;
    	const writable_props = ['results', 'inputType'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ResultsView> was created with unknown prop '${key}'`);
    	});

    	const func = i => {
    		$$invalidate(2, selectedResult = i);
    	};

    	$$self.$$set = $$props => {
    		if ('results' in $$props) $$invalidate(0, results = $$props.results);
    		if ('inputType' in $$props) $$invalidate(1, inputType = $$props.inputType);
    	};

    	$$self.$capture_state = () => ({
    		Button,
    		results,
    		inputType,
    		selectedResult
    	});

    	$$self.$inject_state = $$props => {
    		if ('results' in $$props) $$invalidate(0, results = $$props.results);
    		if ('inputType' in $$props) $$invalidate(1, inputType = $$props.inputType);
    		if ('selectedResult' in $$props) $$invalidate(2, selectedResult = $$props.selectedResult);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*results*/ 1) {
    			{
    				if (results.length > 0) {
    					$$invalidate(2, selectedResult = results.length - 1);
    				} else {
    					$$invalidate(2, selectedResult = 0);
    				}
    			}
    		}
    	};

    	return [results, inputType, selectedResult, func];
    }

    class ResultsView extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { results: 0, inputType: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ResultsView",
    			options,
    			id: create_fragment$1.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*results*/ ctx[0] === undefined && !('results' in props)) {
    			console.warn("<ResultsView> was created without expected prop 'results'");
    		}

    		if (/*inputType*/ ctx[1] === undefined && !('inputType' in props)) {
    			console.warn("<ResultsView> was created without expected prop 'inputType'");
    		}
    	}

    	get results() {
    		throw new Error("<ResultsView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set results(value) {
    		throw new Error("<ResultsView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputType() {
    		throw new Error("<ResultsView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputType(value) {
    		throw new Error("<ResultsView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/App.svelte generated by Svelte v3.48.0 */
    const file = "src/App.svelte";

    // (16:1) {#if decodedResults}
    function create_if_block(ctx) {
    	let br;
    	let t;
    	let resultsview;
    	let current;

    	resultsview = new ResultsView({
    			props: {
    				results: /*decodedResults*/ ctx[0],
    				inputType: /*inputType*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			br = element("br");
    			t = space();
    			create_component(resultsview.$$.fragment);
    			add_location(br, file, 16, 2, 524);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, br, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(resultsview, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const resultsview_changes = {};
    			if (dirty & /*decodedResults*/ 1) resultsview_changes.results = /*decodedResults*/ ctx[0];
    			if (dirty & /*inputType*/ 2) resultsview_changes.inputType = /*inputType*/ ctx[1];
    			resultsview.$set(resultsview_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(resultsview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(resultsview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t);
    			destroy_component(resultsview, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(16:1) {#if decodedResults}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let main;
    	let h1;
    	let t1;
    	let p;
    	let t3;
    	let inputbox;
    	let t4;
    	let current;

    	inputbox = new InputBox({
    			props: {
    				onInputConfirm: /*onInputConfirm*/ ctx[2]
    			},
    			$$inline: true
    		});

    	let if_block = /*decodedResults*/ ctx[0] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			h1 = element("h1");
    			h1.textContent = "Interpret";
    			t1 = space();
    			p = element("p");
    			p.textContent = "Universal data parser for developers, reverse engineering, and more!";
    			t3 = space();
    			create_component(inputbox.$$.fragment);
    			t4 = space();
    			if (if_block) if_block.c();
    			add_location(h1, file, 12, 1, 373);
    			attr_dev(p, "class", "svelte-n11s9c");
    			add_location(p, file, 13, 1, 393);
    			attr_dev(main, "class", "svelte-n11s9c");
    			add_location(main, file, 11, 0, 365);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h1);
    			append_dev(main, t1);
    			append_dev(main, p);
    			append_dev(main, t3);
    			mount_component(inputbox, main, null);
    			append_dev(main, t4);
    			if (if_block) if_block.m(main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*decodedResults*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*decodedResults*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inputbox.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inputbox.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(inputbox);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let decodedResults = null;
    	let inputType = "";

    	const onInputConfirm = (prettyName, dataType, data) => {
    		$$invalidate(1, inputType = prettyName);
    		$$invalidate(0, decodedResults = decodeRoot(dataType, data));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		InputBox,
    		ResultsView,
    		decodeRoot,
    		decodedResults,
    		inputType,
    		onInputConfirm
    	});

    	$$self.$inject_state = $$props => {
    		if ('decodedResults' in $$props) $$invalidate(0, decodedResults = $$props.decodedResults);
    		if ('inputType' in $$props) $$invalidate(1, inputType = $$props.inputType);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [decodedResults, inputType, onInputConfirm];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
        target: document.body,
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
